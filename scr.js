function TB(n, e) { for (var t = 0; t < e.length; t++) { const i = e[t]; if (typeof i != "string" && !Array.isArray(i)) { for (const r in i) if (r !== "default" && !(r in n)) { const s = Object.getOwnPropertyDescriptor(i, r); s && Object.defineProperty(n, r, s.get ? s : { enumerable: !0, get: () => i[r] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = t(r); fetch(r.href, s) } })(); function CC(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } function BB(n) { if (n.__esModule) return n; var e = n.default; if (typeof e == "function") { var t = function i() { if (this instanceof i) { var r = [null]; r.push.apply(r, arguments); var s = Function.bind.apply(e, r); return new s } return e.apply(this, arguments) }; t.prototype = e.prototype } else t = {}; return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function (i) { var r = Object.getOwnPropertyDescriptor(n, i); Object.defineProperty(t, i, r.get ? r : { enumerable: !0, get: function () { return n[i] } }) }), t } var wf = {}, PB = { get exports() { return wf }, set exports(n) { wf = n } }, i0 = {}, U = {}, RB = { get exports() { return U }, set exports(n) { U = n } }, _t = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ch = Symbol.for("react.element"), LB = Symbol.for("react.portal"), IB = Symbol.for("react.fragment"), DB = Symbol.for("react.strict_mode"), FB = Symbol.for("react.profiler"), kB = Symbol.for("react.provider"), NB = Symbol.for("react.context"), OB = Symbol.for("react.forward_ref"), zB = Symbol.for("react.suspense"), UB = Symbol.for("react.memo"), GB = Symbol.for("react.lazy"), $M = Symbol.iterator; function HB(n) { return n === null || typeof n != "object" ? null : (n = $M && n[$M] || n["@@iterator"], typeof n == "function" ? n : null) } var EC = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, bC = Object.assign, TC = {}; function Wc(n, e, t) { this.props = n, this.context = e, this.refs = TC, this.updater = t || EC } Wc.prototype.isReactComponent = {}; Wc.prototype.setState = function (n, e) { if (typeof n != "object" && typeof n != "function" && n != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, n, e, "setState") }; Wc.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, "forceUpdate") }; function BC() { } BC.prototype = Wc.prototype; function q2(n, e, t) { this.props = n, this.context = e, this.refs = TC, this.updater = t || EC } var Z2 = q2.prototype = new BC; Z2.constructor = q2; bC(Z2, Wc.prototype); Z2.isPureReactComponent = !0; var e_ = Array.isArray, PC = Object.prototype.hasOwnProperty, $2 = { current: null }, RC = { key: !0, ref: !0, __self: !0, __source: !0 }; function LC(n, e, t) { var i, r = {}, s = null, o = null; if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) PC.call(e, i) && !RC.hasOwnProperty(i) && (r[i] = e[i]); var a = arguments.length - 2; if (a === 1) r.children = t; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; r.children = l } if (n && n.defaultProps) for (i in a = n.defaultProps, a) r[i] === void 0 && (r[i] = a[i]); return { $$typeof: ch, type: n, key: s, ref: o, props: r, _owner: $2.current } } function VB(n, e) { return { $$typeof: ch, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner } } function ex(n) { return typeof n == "object" && n !== null && n.$$typeof === ch } function WB(n) { var e = { "=": "=0", ":": "=2" }; return "$" + n.replace(/[=:]/g, function (t) { return e[t] }) } var t_ = /\/+/g; function a1(n, e) { return typeof n == "object" && n !== null && n.key != null ? WB("" + n.key) : e.toString(36) } function Xp(n, e, t, i, r) { var s = typeof n; (s === "undefined" || s === "boolean") && (n = null); var o = !1; if (n === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (n.$$typeof) { case ch: case LB: o = !0 } }if (o) return o = n, r = r(o), n = i === "" ? "." + a1(o, 0) : i, e_(r) ? (t = "", n != null && (t = n.replace(t_, "$&/") + "/"), Xp(r, e, t, "", function (u) { return u })) : r != null && (ex(r) && (r = VB(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(t_, "$&/") + "/") + n)), e.push(r)), 1; if (o = 0, i = i === "" ? "." : i + ":", e_(n)) for (var a = 0; a < n.length; a++) { s = n[a]; var l = i + a1(s, a); o += Xp(s, e, t, l, r) } else if (l = HB(n), typeof l == "function") for (n = l.call(n), a = 0; !(s = n.next()).done;)s = s.value, l = i + a1(s, a++), o += Xp(s, e, t, l, r); else if (s === "object") throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function kd(n, e, t) { if (n == null) return n; var i = [], r = 0; return Xp(n, i, "", "", function (s) { return e.call(t, s, r++) }), i } function jB(n) { if (n._status === -1) { var e = n._result; e = e(), e.then(function (t) { (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t) }, function (t) { (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t) }), n._status === -1 && (n._status = 0, n._result = e) } if (n._status === 1) return n._result.default; throw n._result } var gi = { current: null }, Qp = { transition: null }, JB = { ReactCurrentDispatcher: gi, ReactCurrentBatchConfig: Qp, ReactCurrentOwner: $2 }; _t.Children = { map: kd, forEach: function (n, e, t) { kd(n, function () { e.apply(this, arguments) }, t) }, count: function (n) { var e = 0; return kd(n, function () { e++ }), e }, toArray: function (n) { return kd(n, function (e) { return e }) || [] }, only: function (n) { if (!ex(n)) throw Error("React.Children.only expected to receive a single React element child."); return n } }; _t.Component = Wc; _t.Fragment = IB; _t.Profiler = FB; _t.PureComponent = q2; _t.StrictMode = DB; _t.Suspense = zB; _t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = JB; _t.cloneElement = function (n, e, t) { if (n == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + "."); var i = bC({}, n.props), r = n.key, s = n.ref, o = n._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = $2.current), e.key !== void 0 && (r = "" + e.key), n.type && n.type.defaultProps) var a = n.type.defaultProps; for (l in e) PC.call(e, l) && !RC.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) i.children = t; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; i.children = a } return { $$typeof: ch, type: n.type, key: r, ref: s, props: i, _owner: o } }; _t.createContext = function (n) { return n = { $$typeof: NB, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: kB, _context: n }, n.Consumer = n }; _t.createElement = LC; _t.createFactory = function (n) { var e = LC.bind(null, n); return e.type = n, e }; _t.createRef = function () { return { current: null } }; _t.forwardRef = function (n) { return { $$typeof: OB, render: n } }; _t.isValidElement = ex; _t.lazy = function (n) { return { $$typeof: GB, _payload: { _status: -1, _result: n }, _init: jB } }; _t.memo = function (n, e) { return { $$typeof: UB, type: n, compare: e === void 0 ? null : e } }; _t.startTransition = function (n) { var e = Qp.transition; Qp.transition = {}; try { n() } finally { Qp.transition = e } }; _t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; _t.useCallback = function (n, e) { return gi.current.useCallback(n, e) }; _t.useContext = function (n) { return gi.current.useContext(n) }; _t.useDebugValue = function () { }; _t.useDeferredValue = function (n) { return gi.current.useDeferredValue(n) }; _t.useEffect = function (n, e) { return gi.current.useEffect(n, e) }; _t.useId = function () { return gi.current.useId() }; _t.useImperativeHandle = function (n, e, t) { return gi.current.useImperativeHandle(n, e, t) }; _t.useInsertionEffect = function (n, e) { return gi.current.useInsertionEffect(n, e) }; _t.useLayoutEffect = function (n, e) { return gi.current.useLayoutEffect(n, e) }; _t.useMemo = function (n, e) { return gi.current.useMemo(n, e) }; _t.useReducer = function (n, e, t) { return gi.current.useReducer(n, e, t) }; _t.useRef = function (n) { return gi.current.useRef(n) }; _t.useState = function (n) { return gi.current.useState(n) }; _t.useSyncExternalStore = function (n, e, t) { return gi.current.useSyncExternalStore(n, e, t) }; _t.useTransition = function () { return gi.current.useTransition() }; _t.version = "18.2.0"; (function (n) { n.exports = _t })(RB); const r0 = CC(U), Uy = TB({ __proto__: null, default: r0 }, [U]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var XB = U, QB = Symbol.for("react.element"), KB = Symbol.for("react.fragment"), YB = Object.prototype.hasOwnProperty, qB = XB.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ZB = { key: !0, ref: !0, __self: !0, __source: !0 }; function IC(n, e, t) { var i, r = {}, s = null, o = null; t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (i in e) YB.call(e, i) && !ZB.hasOwnProperty(i) && (r[i] = e[i]); if (n && n.defaultProps) for (i in e = n.defaultProps, e) r[i] === void 0 && (r[i] = e[i]); return { $$typeof: QB, type: n, key: s, ref: o, props: r, _owner: qB.current } } i0.Fragment = KB; i0.jsx = IC; i0.jsxs = IC; (function (n) { n.exports = i0 })(PB); const s0 = wf.Fragment, ue = wf.jsx, it = wf.jsxs; var Gy = {}, gm = {}, $B = { get exports() { return gm }, set exports(n) { gm = n } }, Qi = {}, Hy = {}, eP = { get exports() { return Hy }, set exports(n) { Hy = n } }, DC = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(N, H) { var W = N.length; N.push(H); e: for (; 0 < W;) { var se = W - 1 >>> 1, j = N[se]; if (0 < r(j, H)) N[se] = H, N[W] = j, W = se; else break e } } function t(N) { return N.length === 0 ? null : N[0] } function i(N) { if (N.length === 0) return null; var H = N[0], W = N.pop(); if (W !== H) { N[0] = W; e: for (var se = 0, j = N.length, oe = j >>> 1; se < oe;) { var ve = 2 * (se + 1) - 1, q = N[ve], Te = ve + 1, Se = N[Te]; if (0 > r(q, W)) Te < j && 0 > r(Se, q) ? (N[se] = Se, N[Te] = W, se = Te) : (N[se] = q, N[ve] = W, se = ve); else if (Te < j && 0 > r(Se, W)) N[se] = Se, N[Te] = W, se = Te; else break e } } return H } function r(N, H) { var W = N.sortIndex - H.sortIndex; return W !== 0 ? W : N.id - H.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); n.unstable_now = function () { return o.now() - a } } var l = [], u = [], h = 1, d = null, p = 3, m = !1, v = !1, y = !1, x = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M(N) { for (var H = t(u); H !== null;) { if (H.callback === null) i(u); else if (H.startTime <= N) i(u), H.sortIndex = H.expirationTime, e(l, H); else break; H = t(u) } } function S(N) { if (y = !1, M(N), !v) if (t(l) !== null) v = !0, ee(b); else { var H = t(u); H !== null && le(S, H.startTime - N) } } function b(N, H) { v = !1, y && (y = !1, A(E), E = -1), m = !0; var W = p; try { for (M(H), d = t(l); d !== null && (!(d.expirationTime > H) || N && !z());) { var se = d.callback; if (typeof se == "function") { d.callback = null, p = d.priorityLevel; var j = se(d.expirationTime <= H); H = n.unstable_now(), typeof j == "function" ? d.callback = j : d === t(l) && i(l), M(H) } else i(l); d = t(l) } if (d !== null) var oe = !0; else { var ve = t(u); ve !== null && le(S, ve.startTime - H), oe = !1 } return oe } finally { d = null, p = W, m = !1 } } var B = !1, R = null, E = -1, P = 5, L = -1; function z() { return !(n.unstable_now() - L < P) } function Z() { if (R !== null) { var N = n.unstable_now(); L = N; var H = !0; try { H = R(!0, N) } finally { H ? J() : (B = !1, R = null) } } else B = !1 } var J; if (typeof _ == "function") J = function () { _(Z) }; else if (typeof MessageChannel < "u") { var V = new MessageChannel, K = V.port2; V.port1.onmessage = Z, J = function () { K.postMessage(null) } } else J = function () { x(Z, 0) }; function ee(N) { R = N, B || (B = !0, J()) } function le(N, H) { E = x(function () { N(n.unstable_now()) }, H) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (N) { N.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, ee(b)) }, n.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < N ? Math.floor(1e3 / N) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (N) { switch (p) { case 1: case 2: case 3: var H = 3; break; default: H = p }var W = p; p = H; try { return N() } finally { p = W } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (N, H) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var W = p; p = N; try { return H() } finally { p = W } }, n.unstable_scheduleCallback = function (N, H, W) { var se = n.unstable_now(); switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? se + W : se) : W = se, N) { case 1: var j = -1; break; case 2: j = 250; break; case 5: j = 1073741823; break; case 4: j = 1e4; break; default: j = 5e3 }return j = W + j, N = { id: h++, callback: H, priorityLevel: N, startTime: W, expirationTime: j, sortIndex: -1 }, W > se ? (N.sortIndex = W, e(u, N), t(l) === null && N === t(u) && (y ? (A(E), E = -1) : y = !0, le(S, W - se))) : (N.sortIndex = j, e(l, N), v || m || (v = !0, ee(b))), N }, n.unstable_shouldYield = z, n.unstable_wrapCallback = function (N) { var H = p; return function () { var W = p; p = H; try { return N.apply(this, arguments) } finally { p = W } } } })(DC); (function (n) { n.exports = DC })(eP);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var FC = U, Wi = Hy; function Me(n) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var kC = new Set, Sf = {}; function ol(n, e) { Cc(n, e), Cc(n + "Capture", e) } function Cc(n, e) { for (Sf[n] = e, n = 0; n < e.length; n++)kC.add(e[n]) } var Gs = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Vy = Object.prototype.hasOwnProperty, tP = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, n_ = {}, i_ = {}; function nP(n) { return Vy.call(i_, n) ? !0 : Vy.call(n_, n) ? !1 : tP.test(n) ? i_[n] = !0 : (n_[n] = !0, !1) } function iP(n, e, t, i) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-"); default: return !1 } } function rP(n, e, t, i) { if (e === null || typeof e > "u" || iP(n, e, t, i)) return !0; if (i) return !1; if (t !== null) switch (t.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function yi(n, e, t, i, r, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var Jn = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { Jn[n] = new yi(n, 0, !1, n, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var e = n[0]; Jn[e] = new yi(e, 1, !1, n[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { Jn[n] = new yi(n, 2, !1, n.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { Jn[n] = new yi(n, 2, !1, n, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { Jn[n] = new yi(n, 3, !1, n.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (n) { Jn[n] = new yi(n, 3, !0, n, null, !1, !1) });["capture", "download"].forEach(function (n) { Jn[n] = new yi(n, 4, !1, n, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (n) { Jn[n] = new yi(n, 6, !1, n, null, !1, !1) });["rowSpan", "start"].forEach(function (n) { Jn[n] = new yi(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var tx = /[\-:]([a-z])/g; function nx(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var e = n.replace(tx, nx); Jn[e] = new yi(e, 1, !1, n, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var e = n.replace(tx, nx); Jn[e] = new yi(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var e = n.replace(tx, nx); Jn[e] = new yi(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (n) { Jn[n] = new yi(n, 1, !1, n.toLowerCase(), null, !1, !1) }); Jn.xlinkHref = new yi("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (n) { Jn[n] = new yi(n, 1, !1, n.toLowerCase(), null, !0, !0) }); function ix(n, e, t, i) { var r = Jn.hasOwnProperty(e) ? Jn[e] : null; (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (rP(e, t, r, i) && (t = null), i || r === null ? nP(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === !0 ? "" : "" + t, i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t)))) } var Qs = FC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Nd = Symbol.for("react.element"), Yl = Symbol.for("react.portal"), ql = Symbol.for("react.fragment"), rx = Symbol.for("react.strict_mode"), Wy = Symbol.for("react.profiler"), NC = Symbol.for("react.provider"), OC = Symbol.for("react.context"), sx = Symbol.for("react.forward_ref"), jy = Symbol.for("react.suspense"), Jy = Symbol.for("react.suspense_list"), ox = Symbol.for("react.memo"), yo = Symbol.for("react.lazy"), zC = Symbol.for("react.offscreen"), r_ = Symbol.iterator; function _u(n) { return n === null || typeof n != "object" ? null : (n = r_ && n[r_] || n["@@iterator"], typeof n == "function" ? n : null) } var on = Object.assign, l1; function qu(n) {
  if (l1 === void 0) try { throw Error() } catch (t) { var e = t.stack.trim().match(/\n( *(at )?)/); l1 = e && e[1] || "" } return `
`+ l1 + n
} var c1 = !1; function u1(n, e) {
  if (!n || c1) return ""; c1 = !0; var t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var i = u } Reflect.construct(n, [], e) } else { try { e.call() } catch (u) { i = u } n.call(e.prototype) } else { try { throw Error() } catch (u) { i = u } n() } } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (var r = u.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
          var l = `
`+ r[o].replace(" at new ", " at "); return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)), l
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { c1 = !1, Error.prepareStackTrace = t } return (n = n ? n.displayName || n.name : "") ? qu(n) : ""
} function sP(n) { switch (n.tag) { case 5: return qu(n.type); case 16: return qu("Lazy"); case 13: return qu("Suspense"); case 19: return qu("SuspenseList"); case 0: case 2: case 15: return n = u1(n.type, !1), n; case 11: return n = u1(n.type.render, !1), n; case 1: return n = u1(n.type, !0), n; default: return "" } } function Xy(n) { if (n == null) return null; if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n; switch (n) { case ql: return "Fragment"; case Yl: return "Portal"; case Wy: return "Profiler"; case rx: return "StrictMode"; case jy: return "Suspense"; case Jy: return "SuspenseList" }if (typeof n == "object") switch (n.$$typeof) { case OC: return (n.displayName || "Context") + ".Consumer"; case NC: return (n._context.displayName || "Context") + ".Provider"; case sx: var e = n.render; return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case ox: return e = n.displayName || null, e !== null ? e : Xy(n.type) || "Memo"; case yo: e = n._payload, n = n._init; try { return Xy(n(e)) } catch { } }return null } function oP(n) { var e = n.type; switch (n.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Xy(e); case 8: return e === rx ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function Uo(n) { switch (typeof n) { case "boolean": case "number": case "string": case "undefined": return n; case "object": return n; default: return "" } } function UC(n) { var e = n.type; return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function aP(n) { var e = UC(n) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e), i = "" + n[e]; if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") { var r = t.get, s = t.set; return Object.defineProperty(n, e, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { i = "" + o, s.call(this, o) } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = "" + o }, stopTracking: function () { n._valueTracker = null, delete n[e] } } } } function Od(n) { n._valueTracker || (n._valueTracker = aP(n)) } function GC(n) { if (!n) return !1; var e = n._valueTracker; if (!e) return !0; var t = e.getValue(), i = ""; return n && (i = UC(n) ? n.checked ? "true" : "false" : n.value), n = i, n !== t ? (e.setValue(n), !0) : !1 } function ym(n) { if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null; try { return n.activeElement || n.body } catch { return n.body } } function Qy(n, e) { var t = e.checked; return on({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked }) } function s_(n, e) { var t = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked; t = Uo(e.value != null ? e.value : t), n._wrapperState = { initialChecked: i, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function HC(n, e) { e = e.checked, e != null && ix(n, "checked", e, !1) } function Ky(n, e) { HC(n, e); var t = Uo(e.value), i = e.type; if (t != null) i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t); else if (i === "submit" || i === "reset") { n.removeAttribute("value"); return } e.hasOwnProperty("value") ? Yy(n, e.type, t) : e.hasOwnProperty("defaultValue") && Yy(n, e.type, Uo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked) } function o_(n, e, t) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var i = e.type; if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e } t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t) } function Yy(n, e, t) { (e !== "number" || ym(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t)) } var Zu = Array.isArray; function mc(n, e, t, i) { if (n = n.options, e) { e = {}; for (var r = 0; r < t.length; r++)e["$" + t[r]] = !0; for (t = 0; t < n.length; t++)r = e.hasOwnProperty("$" + n[t].value), n[t].selected !== r && (n[t].selected = r), r && i && (n[t].defaultSelected = !0) } else { for (t = "" + Uo(t), e = null, r = 0; r < n.length; r++) { if (n[r].value === t) { n[r].selected = !0, i && (n[r].defaultSelected = !0); return } e !== null || n[r].disabled || (e = n[r]) } e !== null && (e.selected = !0) } } function qy(n, e) { if (e.dangerouslySetInnerHTML != null) throw Error(Me(91)); return on({}, e, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue }) } function a_(n, e) { var t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(Me(92)); if (Zu(t)) { if (1 < t.length) throw Error(Me(93)); t = t[0] } e = t } e == null && (e = ""), t = e } n._wrapperState = { initialValue: Uo(t) } } function VC(n, e) { var t = Uo(e.value), i = Uo(e.defaultValue); t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), i != null && (n.defaultValue = "" + i) } function l_(n) { var e = n.textContent; e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e) } function WC(n) { switch (n) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Zy(n, e) { return n == null || n === "http://www.w3.org/1999/xhtml" ? WC(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n } var zd, jC = function (n) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, t, i, r) { MSApp.execUnsafeLocalFunction(function () { return n(e, t, i, r) }) } : n }(function (n, e) { if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) n.innerHTML = e; else { for (zd = zd || document.createElement("div"), zd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = zd.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (; e.firstChild;)n.appendChild(e.firstChild) } }); function Cf(n, e) { if (e) { var t = n.firstChild; if (t && t === n.lastChild && t.nodeType === 3) { t.nodeValue = e; return } } n.textContent = e } var rf = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, lP = ["Webkit", "ms", "Moz", "O"]; Object.keys(rf).forEach(function (n) { lP.forEach(function (e) { e = e + n.charAt(0).toUpperCase() + n.substring(1), rf[e] = rf[n] }) }); function JC(n, e, t) { return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || rf.hasOwnProperty(n) && rf[n] ? ("" + e).trim() : e + "px" } function XC(n, e) { n = n.style; for (var t in e) if (e.hasOwnProperty(t)) { var i = t.indexOf("--") === 0, r = JC(t, e[t], i); t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : n[t] = r } } var cP = on({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function $y(n, e) { if (e) { if (cP[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Me(137, n)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(Me(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Me(61)) } if (e.style != null && typeof e.style != "object") throw Error(Me(62)) } } function ev(n, e) { if (n.indexOf("-") === -1) return typeof e.is == "string"; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var tv = null; function ax(n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } var nv = null, gc = null, yc = null; function c_(n) { if (n = hh(n)) { if (typeof nv != "function") throw Error(Me(280)); var e = n.stateNode; e && (e = u0(e), nv(n.stateNode, n.type, e)) } } function QC(n) { gc ? yc ? yc.push(n) : yc = [n] : gc = n } function KC() { if (gc) { var n = gc, e = yc; if (yc = gc = null, c_(n), e) for (n = 0; n < e.length; n++)c_(e[n]) } } function YC(n, e) { return n(e) } function qC() { } var f1 = !1; function ZC(n, e, t) { if (f1) return n(e, t); f1 = !0; try { return YC(n, e, t) } finally { f1 = !1, (gc !== null || yc !== null) && (qC(), KC()) } } function Ef(n, e) { var t = n.stateNode; if (t === null) return null; var i = u0(t); if (i === null) return null; t = i[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (n = n.type, i = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !i; break e; default: n = !1 }if (n) return null; if (t && typeof t != "function") throw Error(Me(231, e, typeof t)); return t } var iv = !1; if (Gs) try { var wu = {}; Object.defineProperty(wu, "passive", { get: function () { iv = !0 } }), window.addEventListener("test", wu, wu), window.removeEventListener("test", wu, wu) } catch { iv = !1 } function uP(n, e, t, i, r, s, o, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(t, u) } catch (h) { this.onError(h) } } var sf = !1, vm = null, xm = !1, rv = null, fP = { onError: function (n) { sf = !0, vm = n } }; function hP(n, e, t, i, r, s, o, a, l) { sf = !1, vm = null, uP.apply(fP, arguments) } function dP(n, e, t, i, r, s, o, a, l) { if (hP.apply(this, arguments), sf) { if (sf) { var u = vm; sf = !1, vm = null } else throw Error(Me(198)); xm || (xm = !0, rv = u) } } function al(n) { var e = n, t = n; if (n.alternate) for (; e.return;)e = e.return; else { n = e; do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n) } return e.tag === 3 ? t : null } function $C(n) { if (n.tag === 13) { var e = n.memoizedState; if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated } return null } function u_(n) { if (al(n) !== n) throw Error(Me(188)) } function pP(n) { var e = n.alternate; if (!e) { if (e = al(n), e === null) throw Error(Me(188)); return e !== n ? null : n } for (var t = n, i = e; ;) { var r = t.return; if (r === null) break; var s = r.alternate; if (s === null) { if (i = r.return, i !== null) { t = i; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === t) return u_(r), n; if (s === i) return u_(r), e; s = s.sibling } throw Error(Me(188)) } if (t.return !== i.return) t = r, i = s; else { for (var o = !1, a = r.child; a;) { if (a === t) { o = !0, t = r, i = s; break } if (a === i) { o = !0, i = r, t = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === t) { o = !0, t = s, i = r; break } if (a === i) { o = !0, i = s, t = r; break } a = a.sibling } if (!o) throw Error(Me(189)) } } if (t.alternate !== i) throw Error(Me(190)) } if (t.tag !== 3) throw Error(Me(188)); return t.stateNode.current === t ? n : e } function eE(n) { return n = pP(n), n !== null ? tE(n) : null } function tE(n) { if (n.tag === 5 || n.tag === 6) return n; for (n = n.child; n !== null;) { var e = tE(n); if (e !== null) return e; n = n.sibling } return null } var nE = Wi.unstable_scheduleCallback, f_ = Wi.unstable_cancelCallback, mP = Wi.unstable_shouldYield, gP = Wi.unstable_requestPaint, vn = Wi.unstable_now, yP = Wi.unstable_getCurrentPriorityLevel, lx = Wi.unstable_ImmediatePriority, iE = Wi.unstable_UserBlockingPriority, Am = Wi.unstable_NormalPriority, vP = Wi.unstable_LowPriority, rE = Wi.unstable_IdlePriority, o0 = null, ns = null; function xP(n) { if (ns && typeof ns.onCommitFiberRoot == "function") try { ns.onCommitFiberRoot(o0, n, void 0, (n.current.flags & 128) === 128) } catch { } } var Ir = Math.clz32 ? Math.clz32 : _P, AP = Math.log, MP = Math.LN2; function _P(n) { return n >>>= 0, n === 0 ? 32 : 31 - (AP(n) / MP | 0) | 0 } var Ud = 64, Gd = 4194304; function $u(n) { switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return n & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return n } } function Mm(n, e) { var t = n.pendingLanes; if (t === 0) return 0; var i = 0, r = n.suspendedLanes, s = n.pingedLanes, o = t & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? i = $u(a) : (s &= o, s !== 0 && (i = $u(s))) } else o = t & ~r, o !== 0 ? i = $u(o) : s !== 0 && (i = $u(s)); if (i === 0) return 0; if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e; if (i & 4 && (i |= t & 16), e = n.entangledLanes, e !== 0) for (n = n.entanglements, e &= i; 0 < e;)t = 31 - Ir(e), r = 1 << t, i |= n[t], e &= ~r; return i } function wP(n, e) { switch (n) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function SP(n, e) { for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s;) { var o = 31 - Ir(s), a = 1 << o, l = r[o]; l === -1 ? (!(a & t) || a & i) && (r[o] = wP(a, e)) : l <= e && (n.expiredLanes |= a), s &= ~a } } function sv(n) { return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0 } function sE() { var n = Ud; return Ud <<= 1, !(Ud & 4194240) && (Ud = 64), n } function h1(n) { for (var e = [], t = 0; 31 > t; t++)e.push(n); return e } function uh(n, e, t) { n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - Ir(e), n[e] = t } function CP(n, e) { var t = n.pendingLanes & ~e; n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements; var i = n.eventTimes; for (n = n.expirationTimes; 0 < t;) { var r = 31 - Ir(t), s = 1 << r; e[r] = 0, i[r] = -1, n[r] = -1, t &= ~s } } function cx(n, e) { var t = n.entangledLanes |= e; for (n = n.entanglements; t;) { var i = 31 - Ir(t), r = 1 << i; r & e | n[i] & e && (n[i] |= e), t &= ~r } } var kt = 0; function oE(n) { return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1 } var aE, ux, lE, cE, uE, ov = !1, Hd = [], Bo = null, Po = null, Ro = null, bf = new Map, Tf = new Map, Mo = [], EP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function h_(n, e) { switch (n) { case "focusin": case "focusout": Bo = null; break; case "dragenter": case "dragleave": Po = null; break; case "mouseover": case "mouseout": Ro = null; break; case "pointerover": case "pointerout": bf.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Tf.delete(e.pointerId) } } function Su(n, e, t, i, r, s) { return n === null || n.nativeEvent !== s ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = hh(e), e !== null && ux(e)), n) : (n.eventSystemFlags |= i, e = n.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n) } function bP(n, e, t, i, r) { switch (e) { case "focusin": return Bo = Su(Bo, n, e, t, i, r), !0; case "dragenter": return Po = Su(Po, n, e, t, i, r), !0; case "mouseover": return Ro = Su(Ro, n, e, t, i, r), !0; case "pointerover": var s = r.pointerId; return bf.set(s, Su(bf.get(s) || null, n, e, t, i, r)), !0; case "gotpointercapture": return s = r.pointerId, Tf.set(s, Su(Tf.get(s) || null, n, e, t, i, r)), !0 }return !1 } function fE(n) { var e = Ia(n.target); if (e !== null) { var t = al(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = $C(t), e !== null) { n.blockedOn = e, uE(n.priority, function () { lE(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } } n.blockedOn = null } function Kp(n) { if (n.blockedOn !== null) return !1; for (var e = n.targetContainers; 0 < e.length;) { var t = av(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent); if (t === null) { t = n.nativeEvent; var i = new t.constructor(t.type, t); tv = i, t.target.dispatchEvent(i), tv = null } else return e = hh(t), e !== null && ux(e), n.blockedOn = t, !1; e.shift() } return !0 } function d_(n, e, t) { Kp(n) && t.delete(e) } function TP() { ov = !1, Bo !== null && Kp(Bo) && (Bo = null), Po !== null && Kp(Po) && (Po = null), Ro !== null && Kp(Ro) && (Ro = null), bf.forEach(d_), Tf.forEach(d_) } function Cu(n, e) { n.blockedOn === e && (n.blockedOn = null, ov || (ov = !0, Wi.unstable_scheduleCallback(Wi.unstable_NormalPriority, TP))) } function Bf(n) { function e(r) { return Cu(r, n) } if (0 < Hd.length) { Cu(Hd[0], n); for (var t = 1; t < Hd.length; t++) { var i = Hd[t]; i.blockedOn === n && (i.blockedOn = null) } } for (Bo !== null && Cu(Bo, n), Po !== null && Cu(Po, n), Ro !== null && Cu(Ro, n), bf.forEach(e), Tf.forEach(e), t = 0; t < Mo.length; t++)i = Mo[t], i.blockedOn === n && (i.blockedOn = null); for (; 0 < Mo.length && (t = Mo[0], t.blockedOn === null);)fE(t), t.blockedOn === null && Mo.shift() } var vc = Qs.ReactCurrentBatchConfig, _m = !0; function BP(n, e, t, i) { var r = kt, s = vc.transition; vc.transition = null; try { kt = 1, fx(n, e, t, i) } finally { kt = r, vc.transition = s } } function PP(n, e, t, i) { var r = kt, s = vc.transition; vc.transition = null; try { kt = 4, fx(n, e, t, i) } finally { kt = r, vc.transition = s } } function fx(n, e, t, i) { if (_m) { var r = av(n, e, t, i); if (r === null) _1(n, e, i, wm, t), h_(n, i); else if (bP(r, n, e, t, i)) i.stopPropagation(); else if (h_(n, i), e & 4 && -1 < EP.indexOf(n)) { for (; r !== null;) { var s = hh(r); if (s !== null && aE(s), s = av(n, e, t, i), s === null && _1(n, e, i, wm, t), s === r) break; r = s } r !== null && i.stopPropagation() } else _1(n, e, i, null, t) } } var wm = null; function av(n, e, t, i) { if (wm = null, n = ax(i), n = Ia(n), n !== null) if (e = al(n), e === null) n = null; else if (t = e.tag, t === 13) { if (n = $C(e), n !== null) return n; n = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; n = null } else e !== n && (n = null); return wm = n, null } function hE(n) { switch (n) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (yP()) { case lx: return 1; case iE: return 4; case Am: case vP: return 16; case rE: return 536870912; default: return 16 }default: return 16 } } var wo = null, hx = null, Yp = null; function dE() { if (Yp) return Yp; var n, e = hx, t = e.length, i, r = "value" in wo ? wo.value : wo.textContent, s = r.length; for (n = 0; n < t && e[n] === r[n]; n++); var o = t - n; for (i = 1; i <= o && e[t - i] === r[s - i]; i++); return Yp = r.slice(n, 1 < i ? 1 - i : void 0) } function qp(n) { var e = n.keyCode; return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0 } function Vd() { return !0 } function p_() { return !1 } function Ki(n) { function e(t, i, r, s, o) { this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in n) n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? Vd : p_, this.isPropagationStopped = p_, this } return on(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = Vd) }, stopPropagation: function () { var t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = Vd) }, persist: function () { }, isPersistent: Vd }), e } var jc = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, dx = Ki(jc), fh = on({}, jc, { view: 0, detail: 0 }), RP = Ki(fh), d1, p1, Eu, a0 = on({}, fh, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: px, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== Eu && (Eu && n.type === "mousemove" ? (d1 = n.screenX - Eu.screenX, p1 = n.screenY - Eu.screenY) : p1 = d1 = 0, Eu = n), d1) }, movementY: function (n) { return "movementY" in n ? n.movementY : p1 } }), m_ = Ki(a0), LP = on({}, a0, { dataTransfer: 0 }), IP = Ki(LP), DP = on({}, fh, { relatedTarget: 0 }), m1 = Ki(DP), FP = on({}, jc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), kP = Ki(FP), NP = on({}, jc, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } }), OP = Ki(NP), zP = on({}, jc, { data: 0 }), g_ = Ki(zP), UP = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, GP = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, HP = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function VP(n) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(n) : (n = HP[n]) ? !!e[n] : !1 } function px() { return VP } var WP = on({}, fh, { key: function (n) { if (n.key) { var e = UP[n.key] || n.key; if (e !== "Unidentified") return e } return n.type === "keypress" ? (n = qp(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? GP[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: px, charCode: function (n) { return n.type === "keypress" ? qp(n) : 0 }, keyCode: function (n) { return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 }, which: function (n) { return n.type === "keypress" ? qp(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 } }), jP = Ki(WP), JP = on({}, a0, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), y_ = Ki(JP), XP = on({}, fh, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: px }), QP = Ki(XP), KP = on({}, jc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), YP = Ki(KP), qP = on({}, a0, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), ZP = Ki(qP), $P = [9, 13, 27, 32], mx = Gs && "CompositionEvent" in window, of = null; Gs && "documentMode" in document && (of = document.documentMode); var e9 = Gs && "TextEvent" in window && !of, pE = Gs && (!mx || of && 8 < of && 11 >= of), v_ = String.fromCharCode(32), x_ = !1; function mE(n, e) { switch (n) { case "keyup": return $P.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function gE(n) { return n = n.detail, typeof n == "object" && "data" in n ? n.data : null } var Zl = !1; function t9(n, e) { switch (n) { case "compositionend": return gE(e); case "keypress": return e.which !== 32 ? null : (x_ = !0, v_); case "textInput": return n = e.data, n === v_ && x_ ? null : n; default: return null } } function n9(n, e) { if (Zl) return n === "compositionend" || !mx && mE(n, e) ? (n = dE(), Yp = hx = wo = null, Zl = !1, n) : null; switch (n) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return pE && e.locale !== "ko" ? null : e.data; default: return null } } var i9 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function A_(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e === "input" ? !!i9[n.type] : e === "textarea" } function yE(n, e, t, i) { QC(i), e = Sm(e, "onChange"), 0 < e.length && (t = new dx("onChange", "change", null, t, i), n.push({ event: t, listeners: e })) } var af = null, Pf = null; function r9(n) { TE(n, 0) } function l0(n) { var e = tc(n); if (GC(e)) return n } function s9(n, e) { if (n === "change") return e } var vE = !1; if (Gs) { var g1; if (Gs) { var y1 = "oninput" in document; if (!y1) { var M_ = document.createElement("div"); M_.setAttribute("oninput", "return;"), y1 = typeof M_.oninput == "function" } g1 = y1 } else g1 = !1; vE = g1 && (!document.documentMode || 9 < document.documentMode) } function __() { af && (af.detachEvent("onpropertychange", xE), Pf = af = null) } function xE(n) { if (n.propertyName === "value" && l0(Pf)) { var e = []; yE(e, Pf, n, ax(n)), ZC(r9, e) } } function o9(n, e, t) { n === "focusin" ? (__(), af = e, Pf = t, af.attachEvent("onpropertychange", xE)) : n === "focusout" && __() } function a9(n) { if (n === "selectionchange" || n === "keyup" || n === "keydown") return l0(Pf) } function l9(n, e) { if (n === "click") return l0(e) } function c9(n, e) { if (n === "input" || n === "change") return l0(e) } function u9(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var Nr = typeof Object.is == "function" ? Object.is : u9; function Rf(n, e) { if (Nr(n, e)) return !0; if (typeof n != "object" || n === null || typeof e != "object" || e === null) return !1; var t = Object.keys(n), i = Object.keys(e); if (t.length !== i.length) return !1; for (i = 0; i < t.length; i++) { var r = t[i]; if (!Vy.call(e, r) || !Nr(n[r], e[r])) return !1 } return !0 } function w_(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function S_(n, e) { var t = w_(n); n = 0; for (var i; t;) { if (t.nodeType === 3) { if (i = n + t.textContent.length, n <= e && i >= e) return { node: t, offset: e - n }; n = i } e: { for (; t;) { if (t.nextSibling) { t = t.nextSibling; break e } t = t.parentNode } t = void 0 } t = w_(t) } } function AE(n, e) { return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? AE(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1 } function ME() { for (var n = window, e = ym(); e instanceof n.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href == "string" } catch { t = !1 } if (t) n = e.contentWindow; else break; e = ym(n.document) } return e } function gx(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true") } function f9(n) { var e = ME(), t = n.focusedElem, i = n.selectionRange; if (e !== t && t && t.ownerDocument && AE(t.ownerDocument.documentElement, t)) { if (i !== null && gx(t)) { if (e = i.start, n = i.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); var r = t.textContent.length, s = Math.min(i.start, r); i = i.end === void 0 ? s : Math.min(i.end, r), !n.extend && s > i && (r = i, i = s, s = r), r = S_(t, s); var o = S_(t, i); r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n.removeAllRanges(), s > i ? (n.addRange(e), n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } var h9 = Gs && "documentMode" in document && 11 >= document.documentMode, $l = null, lv = null, lf = null, cv = !1; function C_(n, e, t) { var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; cv || $l == null || $l !== ym(i) || (i = $l, "selectionStart" in i && gx(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), lf && Rf(lf, i) || (lf = i, i = Sm(lv, "onSelect"), 0 < i.length && (e = new dx("onSelect", "select", null, e, t), n.push({ event: e, listeners: i }), e.target = $l))) } function Wd(n, e) { var t = {}; return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t } var ec = { animationend: Wd("Animation", "AnimationEnd"), animationiteration: Wd("Animation", "AnimationIteration"), animationstart: Wd("Animation", "AnimationStart"), transitionend: Wd("Transition", "TransitionEnd") }, v1 = {}, _E = {}; Gs && (_E = document.createElement("div").style, "AnimationEvent" in window || (delete ec.animationend.animation, delete ec.animationiteration.animation, delete ec.animationstart.animation), "TransitionEvent" in window || delete ec.transitionend.transition); function c0(n) { if (v1[n]) return v1[n]; if (!ec[n]) return n; var e = ec[n], t; for (t in e) if (e.hasOwnProperty(t) && t in _E) return v1[n] = e[t]; return n } var wE = c0("animationend"), SE = c0("animationiteration"), CE = c0("animationstart"), EE = c0("transitionend"), bE = new Map, E_ = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ko(n, e) { bE.set(n, e), ol(e, [n]) } for (var x1 = 0; x1 < E_.length; x1++) { var A1 = E_[x1], d9 = A1.toLowerCase(), p9 = A1[0].toUpperCase() + A1.slice(1); Ko(d9, "on" + p9) } Ko(wE, "onAnimationEnd"); Ko(SE, "onAnimationIteration"); Ko(CE, "onAnimationStart"); Ko("dblclick", "onDoubleClick"); Ko("focusin", "onFocus"); Ko("focusout", "onBlur"); Ko(EE, "onTransitionEnd"); Cc("onMouseEnter", ["mouseout", "mouseover"]); Cc("onMouseLeave", ["mouseout", "mouseover"]); Cc("onPointerEnter", ["pointerout", "pointerover"]); Cc("onPointerLeave", ["pointerout", "pointerover"]); ol("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); ol("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); ol("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); ol("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); ol("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); ol("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var ef = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), m9 = new Set("cancel close invalid load scroll toggle".split(" ").concat(ef)); function b_(n, e, t) { var i = n.type || "unknown-event"; n.currentTarget = t, dP(i, e, void 0, n), n.currentTarget = null } function TE(n, e) { e = (e & 4) !== 0; for (var t = 0; t < n.length; t++) { var i = n[t], r = i.event; i = i.listeners; e: { var s = void 0; if (e) for (var o = i.length - 1; 0 <= o; o--) { var a = i[o], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break e; b_(r, a, u), s = l } else for (o = 0; o < i.length; o++) { if (a = i[o], l = a.instance, u = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e; b_(r, a, u), s = l } } } if (xm) throw n = rv, xm = !1, rv = null, n } function Vt(n, e) { var t = e[pv]; t === void 0 && (t = e[pv] = new Set); var i = n + "__bubble"; t.has(i) || (BE(e, n, 2, !1), t.add(i)) } function M1(n, e, t) { var i = 0; e && (i |= 4), BE(t, n, i, e) } var jd = "_reactListening" + Math.random().toString(36).slice(2); function Lf(n) { if (!n[jd]) { n[jd] = !0, kC.forEach(function (t) { t !== "selectionchange" && (m9.has(t) || M1(t, !1, n), M1(t, !0, n)) }); var e = n.nodeType === 9 ? n : n.ownerDocument; e === null || e[jd] || (e[jd] = !0, M1("selectionchange", !1, e)) } } function BE(n, e, t, i) { switch (hE(e)) { case 1: var r = BP; break; case 4: r = PP; break; default: r = fx }t = r.bind(null, e, t, n), r = void 0, !iv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: r }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, { passive: r }) : n.addEventListener(e, t, !1) } function _1(n, e, t, i, r) { var s = i; if (!(e & 1) && !(e & 2) && i !== null) e: for (; ;) { if (i === null) return; var o = i.tag; if (o === 3 || o === 4) { var a = i.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = i.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = Ia(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { i = s = o; continue e } a = a.parentNode } } i = i.return } ZC(function () { var u = s, h = ax(t), d = []; e: { var p = bE.get(n); if (p !== void 0) { var m = dx, v = n; switch (n) { case "keypress": if (qp(t) === 0) break e; case "keydown": case "keyup": m = jP; break; case "focusin": v = "focus", m = m1; break; case "focusout": v = "blur", m = m1; break; case "beforeblur": case "afterblur": m = m1; break; case "click": if (t.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = m_; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = IP; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = QP; break; case wE: case SE: case CE: m = kP; break; case EE: m = YP; break; case "scroll": m = RP; break; case "wheel": m = ZP; break; case "copy": case "cut": case "paste": m = OP; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = y_ }var y = (e & 4) !== 0, x = !y && n === "scroll", A = y ? p !== null ? p + "Capture" : null : p; y = []; for (var _ = u, M; _ !== null;) { M = _; var S = M.stateNode; if (M.tag === 5 && S !== null && (M = S, A !== null && (S = Ef(_, A), S != null && y.push(If(_, S, M)))), x) break; _ = _.return } 0 < y.length && (p = new m(p, v, null, t, h), d.push({ event: p, listeners: y })) } } if (!(e & 7)) { e: { if (p = n === "mouseover" || n === "pointerover", m = n === "mouseout" || n === "pointerout", p && t !== tv && (v = t.relatedTarget || t.fromElement) && (Ia(v) || v[Hs])) break e; if ((m || p) && (p = h.window === h ? h : (p = h.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (v = t.relatedTarget || t.toElement, m = u, v = v ? Ia(v) : null, v !== null && (x = al(v), v !== x || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null, v = u), m !== v)) { if (y = m_, S = "onMouseLeave", A = "onMouseEnter", _ = "mouse", (n === "pointerout" || n === "pointerover") && (y = y_, S = "onPointerLeave", A = "onPointerEnter", _ = "pointer"), x = m == null ? p : tc(m), M = v == null ? p : tc(v), p = new y(S, _ + "leave", m, t, h), p.target = x, p.relatedTarget = M, S = null, Ia(h) === u && (y = new y(A, _ + "enter", v, t, h), y.target = M, y.relatedTarget = x, S = y), x = S, m && v) t: { for (y = m, A = v, _ = 0, M = y; M; M = Tl(M))_++; for (M = 0, S = A; S; S = Tl(S))M++; for (; 0 < _ - M;)y = Tl(y), _--; for (; 0 < M - _;)A = Tl(A), M--; for (; _--;) { if (y === A || A !== null && y === A.alternate) break t; y = Tl(y), A = Tl(A) } y = null } else y = null; m !== null && T_(d, p, m, y, !1), v !== null && x !== null && T_(d, x, v, y, !0) } } e: { if (p = u ? tc(u) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var b = s9; else if (A_(p)) if (vE) b = c9; else { b = a9; var B = o9 } else (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (b = l9); if (b && (b = b(n, u))) { yE(d, b, t, h); break e } B && B(n, p, u), n === "focusout" && (B = p._wrapperState) && B.controlled && p.type === "number" && Yy(p, "number", p.value) } switch (B = u ? tc(u) : window, n) { case "focusin": (A_(B) || B.contentEditable === "true") && ($l = B, lv = u, lf = null); break; case "focusout": lf = lv = $l = null; break; case "mousedown": cv = !0; break; case "contextmenu": case "mouseup": case "dragend": cv = !1, C_(d, t, h); break; case "selectionchange": if (h9) break; case "keydown": case "keyup": C_(d, t, h) }var R; if (mx) e: { switch (n) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else Zl ? mE(n, t) && (E = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (E = "onCompositionStart"); E && (pE && t.locale !== "ko" && (Zl || E !== "onCompositionStart" ? E === "onCompositionEnd" && Zl && (R = dE()) : (wo = h, hx = "value" in wo ? wo.value : wo.textContent, Zl = !0)), B = Sm(u, E), 0 < B.length && (E = new g_(E, n, null, t, h), d.push({ event: E, listeners: B }), R ? E.data = R : (R = gE(t), R !== null && (E.data = R)))), (R = e9 ? t9(n, t) : n9(n, t)) && (u = Sm(u, "onBeforeInput"), 0 < u.length && (h = new g_("onBeforeInput", "beforeinput", null, t, h), d.push({ event: h, listeners: u }), h.data = R)) } TE(d, e) }) } function If(n, e, t) { return { instance: n, listener: e, currentTarget: t } } function Sm(n, e) { for (var t = e + "Capture", i = []; n !== null;) { var r = n, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = Ef(n, t), s != null && i.unshift(If(n, s, r)), s = Ef(n, e), s != null && i.push(If(n, s, r))), n = n.return } return i } function Tl(n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5); return n || null } function T_(n, e, t, i, r) { for (var s = e._reactName, o = []; t !== null && t !== i;) { var a = t, l = a.alternate, u = a.stateNode; if (l !== null && l === i) break; a.tag === 5 && u !== null && (a = u, r ? (l = Ef(t, s), l != null && o.unshift(If(t, l, a))) : r || (l = Ef(t, s), l != null && o.push(If(t, l, a)))), t = t.return } o.length !== 0 && n.push({ event: e, listeners: o }) } var g9 = /\r\n?/g, y9 = /\u0000|\uFFFD/g; function B_(n) {
  return (typeof n == "string" ? n : "" + n).replace(g9, `
`).replace(y9, "")
} function Jd(n, e, t) { if (e = B_(e), B_(n) !== e && t) throw Error(Me(425)) } function Cm() { } var uv = null, fv = null; function hv(n, e) { return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var dv = typeof setTimeout == "function" ? setTimeout : void 0, v9 = typeof clearTimeout == "function" ? clearTimeout : void 0, P_ = typeof Promise == "function" ? Promise : void 0, x9 = typeof queueMicrotask == "function" ? queueMicrotask : typeof P_ < "u" ? function (n) { return P_.resolve(null).then(n).catch(A9) } : dv; function A9(n) { setTimeout(function () { throw n }) } function w1(n, e) { var t = e, i = 0; do { var r = t.nextSibling; if (n.removeChild(t), r && r.nodeType === 8) if (t = r.data, t === "/$") { if (i === 0) { n.removeChild(r), Bf(e); return } i-- } else t !== "$" && t !== "$?" && t !== "$!" || i++; t = r } while (t); Bf(e) } function Lo(n) { for (; n != null; n = n.nextSibling) { var e = n.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = n.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return n } function R_(n) { n = n.previousSibling; for (var e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "$" || t === "$!" || t === "$?") { if (e === 0) return n; e-- } else t === "/$" && e++ } n = n.previousSibling } return null } var Jc = Math.random().toString(36).slice(2), ts = "__reactFiber$" + Jc, Df = "__reactProps$" + Jc, Hs = "__reactContainer$" + Jc, pv = "__reactEvents$" + Jc, M9 = "__reactListeners$" + Jc, _9 = "__reactHandles$" + Jc; function Ia(n) { var e = n[ts]; if (e) return e; for (var t = n.parentNode; t;) { if (e = t[Hs] || t[ts]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n = R_(n); n !== null;) { if (t = n[ts]) return t; n = R_(n) } return e } n = t, t = n.parentNode } return null } function hh(n) { return n = n[ts] || n[Hs], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n } function tc(n) { if (n.tag === 5 || n.tag === 6) return n.stateNode; throw Error(Me(33)) } function u0(n) { return n[Df] || null } var mv = [], nc = -1; function Yo(n) { return { current: n } } function jt(n) { 0 > nc || (n.current = mv[nc], mv[nc] = null, nc--) } function Gt(n, e) { nc++, mv[nc] = n.current, n.current = e } var Go = {}, si = Yo(Go), Ei = Yo(!1), qa = Go; function Ec(n, e) { var t = n.type.contextTypes; if (!t) return Go; var i = n.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in t) r[s] = e[s]; return i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = r), r } function bi(n) { return n = n.childContextTypes, n != null } function Em() { jt(Ei), jt(si) } function L_(n, e, t) { if (si.current !== Go) throw Error(Me(168)); Gt(si, e), Gt(Ei, t) } function PE(n, e, t) { var i = n.stateNode; if (e = e.childContextTypes, typeof i.getChildContext != "function") return t; i = i.getChildContext(); for (var r in i) if (!(r in e)) throw Error(Me(108, oP(n) || "Unknown", r)); return on({}, t, i) } function bm(n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Go, qa = si.current, Gt(si, n), Gt(Ei, Ei.current), !0 } function I_(n, e, t) { var i = n.stateNode; if (!i) throw Error(Me(169)); t ? (n = PE(n, e, qa), i.__reactInternalMemoizedMergedChildContext = n, jt(Ei), jt(si), Gt(si, n)) : jt(Ei), Gt(Ei, t) } var Ts = null, f0 = !1, S1 = !1; function RE(n) { Ts === null ? Ts = [n] : Ts.push(n) } function w9(n) { f0 = !0, RE(n) } function qo() { if (!S1 && Ts !== null) { S1 = !0; var n = 0, e = kt; try { var t = Ts; for (kt = 1; n < t.length; n++) { var i = t[n]; do i = i(!0); while (i !== null) } Ts = null, f0 = !1 } catch (r) { throw Ts !== null && (Ts = Ts.slice(n + 1)), nE(lx, qo), r } finally { kt = e, S1 = !1 } } return null } var ic = [], rc = 0, Tm = null, Bm = 0, cr = [], ur = 0, Za = null, Rs = 1, Ls = ""; function wa(n, e) { ic[rc++] = Bm, ic[rc++] = Tm, Tm = n, Bm = e } function LE(n, e, t) { cr[ur++] = Rs, cr[ur++] = Ls, cr[ur++] = Za, Za = n; var i = Rs; n = Ls; var r = 32 - Ir(i) - 1; i &= ~(1 << r), t += 1; var s = 32 - Ir(e) + r; if (30 < s) { var o = r - r % 5; s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, Rs = 1 << 32 - Ir(e) + r | t << r | i, Ls = s + n } else Rs = 1 << s | t << r | i, Ls = n } function yx(n) { n.return !== null && (wa(n, 1), LE(n, 1, 0)) } function vx(n) { for (; n === Tm;)Tm = ic[--rc], ic[rc] = null, Bm = ic[--rc], ic[rc] = null; for (; n === Za;)Za = cr[--ur], cr[ur] = null, Ls = cr[--ur], cr[ur] = null, Rs = cr[--ur], cr[ur] = null } var Hi = null, Ui = null, Yt = !1, Pr = null; function IE(n, e) { var t = hr(5, null, null, 0); t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t) } function D_(n, e) { switch (n.tag) { case 5: var t = n.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, Hi = n, Ui = Lo(e.firstChild), !0) : !1; case 6: return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, Hi = n, Ui = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Za !== null ? { id: Rs, overflow: Ls } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = hr(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, Hi = n, Ui = null, !0) : !1; default: return !1 } } function gv(n) { return (n.mode & 1) !== 0 && (n.flags & 128) === 0 } function yv(n) { if (Yt) { var e = Ui; if (e) { var t = e; if (!D_(n, e)) { if (gv(n)) throw Error(Me(418)); e = Lo(t.nextSibling); var i = Hi; e && D_(n, e) ? IE(i, t) : (n.flags = n.flags & -4097 | 2, Yt = !1, Hi = n) } } else { if (gv(n)) throw Error(Me(418)); n.flags = n.flags & -4097 | 2, Yt = !1, Hi = n } } } function F_(n) { for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;)n = n.return; Hi = n } function Xd(n) { if (n !== Hi) return !1; if (!Yt) return F_(n), Yt = !0, !1; var e; if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !hv(n.type, n.memoizedProps)), e && (e = Ui)) { if (gv(n)) throw DE(), Error(Me(418)); for (; e;)IE(n, e), e = Lo(e.nextSibling) } if (F_(n), n.tag === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(Me(317)); e: { for (n = n.nextSibling, e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "/$") { if (e === 0) { Ui = Lo(n.nextSibling); break e } e-- } else t !== "$" && t !== "$!" && t !== "$?" || e++ } n = n.nextSibling } Ui = null } } else Ui = Hi ? Lo(n.stateNode.nextSibling) : null; return !0 } function DE() { for (var n = Ui; n;)n = Lo(n.nextSibling) } function bc() { Ui = Hi = null, Yt = !1 } function xx(n) { Pr === null ? Pr = [n] : Pr.push(n) } var S9 = Qs.ReactCurrentBatchConfig; function br(n, e) { if (n && n.defaultProps) { e = on({}, e), n = n.defaultProps; for (var t in n) e[t] === void 0 && (e[t] = n[t]); return e } return e } var Pm = Yo(null), Rm = null, sc = null, Ax = null; function Mx() { Ax = sc = Rm = null } function _x(n) { var e = Pm.current; jt(Pm), n._currentValue = e } function vv(n, e, t) { for (; n !== null;) { var i = n.alternate; if ((n.childLanes & e) !== e ? (n.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n === t) break; n = n.return } } function xc(n, e) { Rm = n, Ax = sc = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (Ci = !0), n.firstContext = null) } function mr(n) { var e = n._currentValue; if (Ax !== n) if (n = { context: n, memoizedValue: e, next: null }, sc === null) { if (Rm === null) throw Error(Me(308)); sc = n, Rm.dependencies = { lanes: 0, firstContext: n } } else sc = sc.next = n; return e } var Da = null; function wx(n) { Da === null ? Da = [n] : Da.push(n) } function FE(n, e, t, i) { var r = e.interleaved; return r === null ? (t.next = t, wx(e)) : (t.next = r.next, r.next = t), e.interleaved = t, Vs(n, i) } function Vs(n, e) { n.lanes |= e; var t = n.alternate; for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;)n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return; return t.tag === 3 ? t.stateNode : null } var vo = !1; function Sx(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function kE(n, e) { n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function Ns(n, e) { return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null } } function Io(n, e, t) { var i = n.updateQueue; if (i === null) return null; if (i = i.shared, Bt & 2) { var r = i.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Vs(n, t) } return r = i.interleaved, r === null ? (e.next = e, wx(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Vs(n, t) } function Zp(n, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { var i = e.lanes; i &= n.pendingLanes, t |= i, e.lanes = t, cx(n, t) } } function k_(n, e) { var t = n.updateQueue, i = n.alternate; if (i !== null && (i = i.updateQueue, t === i)) { var r = null, s = null; if (t = t.firstBaseUpdate, t !== null) { do { var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; s === null ? r = s = o : s = s.next = o, t = t.next } while (t !== null); s === null ? r = s = e : s = s.next = e } else r = s = e; t = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, n.updateQueue = t; return } n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e } function Lm(n, e, t, i) { var r = n.updateQueue; vo = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, u = l.next; l.next = null, o === null ? s = u : o.next = u, o = l; var h = n.alternate; h !== null && (h = h.updateQueue, a = h.lastBaseUpdate, a !== o && (a === null ? h.firstBaseUpdate = u : a.next = u, h.lastBaseUpdate = l)) } if (s !== null) { var d = r.baseState; o = 0, h = u = l = null, a = s; do { var p = a.lane, m = a.eventTime; if ((i & p) === p) { h !== null && (h = h.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var v = n, y = a; switch (p = e, m = t, y.tag) { case 1: if (v = y.payload, typeof v == "function") { d = v.call(m, d, p); break e } d = v; break e; case 3: v.flags = v.flags & -65537 | 128; case 0: if (v = y.payload, p = typeof v == "function" ? v.call(m, d, p) : v, p == null) break e; d = on({}, d, p); break e; case 2: vo = !0 } } a.callback !== null && a.lane !== 0 && (n.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a)) } else m = { eventTime: m, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, h === null ? (u = h = m, l = d) : h = h.next = m, o |= p; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null } } while (1); if (h === null && (l = d), r.baseState = l, r.firstBaseUpdate = u, r.lastBaseUpdate = h, e = r.shared.interleaved, e !== null) { r = e; do o |= r.lane, r = r.next; while (r !== e) } else s === null && (r.shared.lanes = 0); el |= o, n.lanes = o, n.memoizedState = d } } function N_(n, e, t) { if (n = e.effects, e.effects = null, n !== null) for (e = 0; e < n.length; e++) { var i = n[e], r = i.callback; if (r !== null) { if (i.callback = null, i = t, typeof r != "function") throw Error(Me(191, r)); r.call(i) } } } var NE = new FC.Component().refs; function xv(n, e, t, i) { e = n.memoizedState, t = t(i, e), t = t == null ? e : on({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t) } var h0 = { isMounted: function (n) { return (n = n._reactInternals) ? al(n) === n : !1 }, enqueueSetState: function (n, e, t) { n = n._reactInternals; var i = mi(), r = Fo(n), s = Ns(i, r); s.payload = e, t != null && (s.callback = t), e = Io(n, s, r), e !== null && (Dr(e, n, r, i), Zp(e, n, r)) }, enqueueReplaceState: function (n, e, t) { n = n._reactInternals; var i = mi(), r = Fo(n), s = Ns(i, r); s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Io(n, s, r), e !== null && (Dr(e, n, r, i), Zp(e, n, r)) }, enqueueForceUpdate: function (n, e) { n = n._reactInternals; var t = mi(), i = Fo(n), r = Ns(t, i); r.tag = 2, e != null && (r.callback = e), e = Io(n, r, i), e !== null && (Dr(e, n, i, t), Zp(e, n, i)) } }; function O_(n, e, t, i, r, s, o) { return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Rf(t, i) || !Rf(r, s) : !0 } function OE(n, e, t) { var i = !1, r = Go, s = e.contextType; return typeof s == "object" && s !== null ? s = mr(s) : (r = bi(e) ? qa : si.current, i = e.contextTypes, s = (i = i != null) ? Ec(n, r) : Go), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = h0, n.stateNode = e, e._reactInternals = n, i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = r, n.__reactInternalMemoizedMaskedChildContext = s), e } function z_(n, e, t, i) { n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n && h0.enqueueReplaceState(e, e.state, null) } function Av(n, e, t, i) { var r = n.stateNode; r.props = t, r.state = n.memoizedState, r.refs = NE, Sx(n); var s = e.contextType; typeof s == "object" && s !== null ? r.context = mr(s) : (s = bi(e) ? qa : si.current, r.context = Ec(n, s)), r.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (xv(n, e, s, t), r.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && h0.enqueueReplaceState(r, r.state, null), Lm(n, t, r, i), r.state = n.memoizedState), typeof r.componentDidMount == "function" && (n.flags |= 4194308) } function bu(n, e, t) { if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(Me(309)); var i = t.stateNode } if (!i) throw Error(Me(147, n)); var r = i, s = "" + n; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = r.refs; a === NE && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof n != "string") throw Error(Me(284)); if (!t._owner) throw Error(Me(290, n)) } return n } function Qd(n, e) { throw n = Object.prototype.toString.call(e), Error(Me(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n)) } function U_(n) { var e = n._init; return e(n._payload) } function zE(n) { function e(A, _) { if (n) { var M = A.deletions; M === null ? (A.deletions = [_], A.flags |= 16) : M.push(_) } } function t(A, _) { if (!n) return null; for (; _ !== null;)e(A, _), _ = _.sibling; return null } function i(A, _) { for (A = new Map; _ !== null;)_.key !== null ? A.set(_.key, _) : A.set(_.index, _), _ = _.sibling; return A } function r(A, _) { return A = ko(A, _), A.index = 0, A.sibling = null, A } function s(A, _, M) { return A.index = M, n ? (M = A.alternate, M !== null ? (M = M.index, M < _ ? (A.flags |= 2, _) : M) : (A.flags |= 2, _)) : (A.flags |= 1048576, _) } function o(A) { return n && A.alternate === null && (A.flags |= 2), A } function a(A, _, M, S) { return _ === null || _.tag !== 6 ? (_ = R1(M, A.mode, S), _.return = A, _) : (_ = r(_, M), _.return = A, _) } function l(A, _, M, S) { var b = M.type; return b === ql ? h(A, _, M.props.children, S, M.key) : _ !== null && (_.elementType === b || typeof b == "object" && b !== null && b.$$typeof === yo && U_(b) === _.type) ? (S = r(_, M.props), S.ref = bu(A, _, M), S.return = A, S) : (S = rm(M.type, M.key, M.props, null, A.mode, S), S.ref = bu(A, _, M), S.return = A, S) } function u(A, _, M, S) { return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== M.containerInfo || _.stateNode.implementation !== M.implementation ? (_ = L1(M, A.mode, S), _.return = A, _) : (_ = r(_, M.children || []), _.return = A, _) } function h(A, _, M, S, b) { return _ === null || _.tag !== 7 ? (_ = Wa(M, A.mode, S, b), _.return = A, _) : (_ = r(_, M), _.return = A, _) } function d(A, _, M) { if (typeof _ == "string" && _ !== "" || typeof _ == "number") return _ = R1("" + _, A.mode, M), _.return = A, _; if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case Nd: return M = rm(_.type, _.key, _.props, null, A.mode, M), M.ref = bu(A, null, _), M.return = A, M; case Yl: return _ = L1(_, A.mode, M), _.return = A, _; case yo: var S = _._init; return d(A, S(_._payload), M) }if (Zu(_) || _u(_)) return _ = Wa(_, A.mode, M, null), _.return = A, _; Qd(A, _) } return null } function p(A, _, M, S) { var b = _ !== null ? _.key : null; if (typeof M == "string" && M !== "" || typeof M == "number") return b !== null ? null : a(A, _, "" + M, S); if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case Nd: return M.key === b ? l(A, _, M, S) : null; case Yl: return M.key === b ? u(A, _, M, S) : null; case yo: return b = M._init, p(A, _, b(M._payload), S) }if (Zu(M) || _u(M)) return b !== null ? null : h(A, _, M, S, null); Qd(A, M) } return null } function m(A, _, M, S, b) { if (typeof S == "string" && S !== "" || typeof S == "number") return A = A.get(M) || null, a(_, A, "" + S, b); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Nd: return A = A.get(S.key === null ? M : S.key) || null, l(_, A, S, b); case Yl: return A = A.get(S.key === null ? M : S.key) || null, u(_, A, S, b); case yo: var B = S._init; return m(A, _, M, B(S._payload), b) }if (Zu(S) || _u(S)) return A = A.get(M) || null, h(_, A, S, b, null); Qd(_, S) } return null } function v(A, _, M, S) { for (var b = null, B = null, R = _, E = _ = 0, P = null; R !== null && E < M.length; E++) { R.index > E ? (P = R, R = null) : P = R.sibling; var L = p(A, R, M[E], S); if (L === null) { R === null && (R = P); break } n && R && L.alternate === null && e(A, R), _ = s(L, _, E), B === null ? b = L : B.sibling = L, B = L, R = P } if (E === M.length) return t(A, R), Yt && wa(A, E), b; if (R === null) { for (; E < M.length; E++)R = d(A, M[E], S), R !== null && (_ = s(R, _, E), B === null ? b = R : B.sibling = R, B = R); return Yt && wa(A, E), b } for (R = i(A, R); E < M.length; E++)P = m(R, A, E, M[E], S), P !== null && (n && P.alternate !== null && R.delete(P.key === null ? E : P.key), _ = s(P, _, E), B === null ? b = P : B.sibling = P, B = P); return n && R.forEach(function (z) { return e(A, z) }), Yt && wa(A, E), b } function y(A, _, M, S) { var b = _u(M); if (typeof b != "function") throw Error(Me(150)); if (M = b.call(M), M == null) throw Error(Me(151)); for (var B = b = null, R = _, E = _ = 0, P = null, L = M.next(); R !== null && !L.done; E++, L = M.next()) { R.index > E ? (P = R, R = null) : P = R.sibling; var z = p(A, R, L.value, S); if (z === null) { R === null && (R = P); break } n && R && z.alternate === null && e(A, R), _ = s(z, _, E), B === null ? b = z : B.sibling = z, B = z, R = P } if (L.done) return t(A, R), Yt && wa(A, E), b; if (R === null) { for (; !L.done; E++, L = M.next())L = d(A, L.value, S), L !== null && (_ = s(L, _, E), B === null ? b = L : B.sibling = L, B = L); return Yt && wa(A, E), b } for (R = i(A, R); !L.done; E++, L = M.next())L = m(R, A, E, L.value, S), L !== null && (n && L.alternate !== null && R.delete(L.key === null ? E : L.key), _ = s(L, _, E), B === null ? b = L : B.sibling = L, B = L); return n && R.forEach(function (Z) { return e(A, Z) }), Yt && wa(A, E), b } function x(A, _, M, S) { if (typeof M == "object" && M !== null && M.type === ql && M.key === null && (M = M.props.children), typeof M == "object" && M !== null) { switch (M.$$typeof) { case Nd: e: { for (var b = M.key, B = _; B !== null;) { if (B.key === b) { if (b = M.type, b === ql) { if (B.tag === 7) { t(A, B.sibling), _ = r(B, M.props.children), _.return = A, A = _; break e } } else if (B.elementType === b || typeof b == "object" && b !== null && b.$$typeof === yo && U_(b) === B.type) { t(A, B.sibling), _ = r(B, M.props), _.ref = bu(A, B, M), _.return = A, A = _; break e } t(A, B); break } else e(A, B); B = B.sibling } M.type === ql ? (_ = Wa(M.props.children, A.mode, S, M.key), _.return = A, A = _) : (S = rm(M.type, M.key, M.props, null, A.mode, S), S.ref = bu(A, _, M), S.return = A, A = S) } return o(A); case Yl: e: { for (B = M.key; _ !== null;) { if (_.key === B) if (_.tag === 4 && _.stateNode.containerInfo === M.containerInfo && _.stateNode.implementation === M.implementation) { t(A, _.sibling), _ = r(_, M.children || []), _.return = A, A = _; break e } else { t(A, _); break } else e(A, _); _ = _.sibling } _ = L1(M, A.mode, S), _.return = A, A = _ } return o(A); case yo: return B = M._init, x(A, _, B(M._payload), S) }if (Zu(M)) return v(A, _, M, S); if (_u(M)) return y(A, _, M, S); Qd(A, M) } return typeof M == "string" && M !== "" || typeof M == "number" ? (M = "" + M, _ !== null && _.tag === 6 ? (t(A, _.sibling), _ = r(_, M), _.return = A, A = _) : (t(A, _), _ = R1(M, A.mode, S), _.return = A, A = _), o(A)) : t(A, _) } return x } var Tc = zE(!0), UE = zE(!1), dh = {}, is = Yo(dh), Ff = Yo(dh), kf = Yo(dh); function Fa(n) { if (n === dh) throw Error(Me(174)); return n } function Cx(n, e) { switch (Gt(kf, e), Gt(Ff, n), Gt(is, dh), n = e.nodeType, n) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Zy(null, ""); break; default: n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = Zy(e, n) }jt(is), Gt(is, e) } function Bc() { jt(is), jt(Ff), jt(kf) } function GE(n) { Fa(kf.current); var e = Fa(is.current), t = Zy(e, n.type); e !== t && (Gt(Ff, n), Gt(is, t)) } function Ex(n) { Ff.current === n && (jt(is), jt(Ff)) } var en = Yo(0); function Im(n) { for (var e = n; e !== null;) { if (e.tag === 13) { var t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var C1 = []; function bx() { for (var n = 0; n < C1.length; n++)C1[n]._workInProgressVersionPrimary = null; C1.length = 0 } var $p = Qs.ReactCurrentDispatcher, E1 = Qs.ReactCurrentBatchConfig, $a = 0, sn = null, Tn = null, Nn = null, Dm = !1, cf = !1, Nf = 0, C9 = 0; function Zn() { throw Error(Me(321)) } function Tx(n, e) { if (e === null) return !1; for (var t = 0; t < e.length && t < n.length; t++)if (!Nr(n[t], e[t])) return !1; return !0 } function Bx(n, e, t, i, r, s) { if ($a = s, sn = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, $p.current = n === null || n.memoizedState === null ? B9 : P9, n = t(i, r), cf) { s = 0; do { if (cf = !1, Nf = 0, 25 <= s) throw Error(Me(301)); s += 1, Nn = Tn = null, e.updateQueue = null, $p.current = R9, n = t(i, r) } while (cf) } if ($p.current = Fm, e = Tn !== null && Tn.next !== null, $a = 0, Nn = Tn = sn = null, Dm = !1, e) throw Error(Me(300)); return n } function Px() { var n = Nf !== 0; return Nf = 0, n } function $r() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Nn === null ? sn.memoizedState = Nn = n : Nn = Nn.next = n, Nn } function gr() { if (Tn === null) { var n = sn.alternate; n = n !== null ? n.memoizedState : null } else n = Tn.next; var e = Nn === null ? sn.memoizedState : Nn.next; if (e !== null) Nn = e, Tn = n; else { if (n === null) throw Error(Me(310)); Tn = n, n = { memoizedState: Tn.memoizedState, baseState: Tn.baseState, baseQueue: Tn.baseQueue, queue: Tn.queue, next: null }, Nn === null ? sn.memoizedState = Nn = n : Nn = Nn.next = n } return Nn } function Of(n, e) { return typeof e == "function" ? e(n) : e } function b1(n) { var e = gr(), t = e.queue; if (t === null) throw Error(Me(311)); t.lastRenderedReducer = n; var i = Tn, r = i.baseQueue, s = t.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } i.baseQueue = r = s, t.pending = null } if (r !== null) { s = r.next, i = i.baseState; var a = o = null, l = null, u = s; do { var h = u.lane; if (($a & h) === h) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), i = u.hasEagerState ? u.eagerState : n(i, u.action); else { var d = { lane: h, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = d, o = i) : l = l.next = d, sn.lanes |= h, el |= h } u = u.next } while (u !== null && u !== s); l === null ? o = i : l.next = a, Nr(i, e.memoizedState) || (Ci = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = l, t.lastRenderedState = i } if (n = t.interleaved, n !== null) { r = n; do s = r.lane, sn.lanes |= s, el |= s, r = r.next; while (r !== n) } else r === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function T1(n) { var e = gr(), t = e.queue; if (t === null) throw Error(Me(311)); t.lastRenderedReducer = n; var i = t.dispatch, r = t.pending, s = e.memoizedState; if (r !== null) { t.pending = null; var o = r = r.next; do s = n(s, o.action), o = o.next; while (o !== r); Nr(s, e.memoizedState) || (Ci = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s } return [s, i] } function HE() { } function VE(n, e) { var t = sn, i = gr(), r = e(), s = !Nr(i.memoizedState, r); if (s && (i.memoizedState = r, Ci = !0), i = i.queue, Rx(JE.bind(null, t, i, n), [n]), i.getSnapshot !== e || s || Nn !== null && Nn.memoizedState.tag & 1) { if (t.flags |= 2048, zf(9, jE.bind(null, t, i, r, e), void 0, null), On === null) throw Error(Me(349)); $a & 30 || WE(t, e, r) } return r } function WE(n, e, t) { n.flags |= 16384, n = { getSnapshot: e, value: t }, e = sn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, sn.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n)) } function jE(n, e, t, i) { e.value = t, e.getSnapshot = i, XE(e) && QE(n) } function JE(n, e, t) { return t(function () { XE(e) && QE(n) }) } function XE(n) { var e = n.getSnapshot; n = n.value; try { var t = e(); return !Nr(n, t) } catch { return !0 } } function QE(n) { var e = Vs(n, 1); e !== null && Dr(e, n, 1, -1) } function G_(n) { var e = $r(); return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Of, lastRenderedState: n }, e.queue = n, n = n.dispatch = T9.bind(null, sn, n), [e.memoizedState, n] } function zf(n, e, t, i) { return n = { tag: n, create: e, destroy: t, deps: i, next: null }, e = sn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, sn.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (i = t.next, t.next = n, n.next = i, e.lastEffect = n)), n } function KE() { return gr().memoizedState } function em(n, e, t, i) { var r = $r(); sn.flags |= n, r.memoizedState = zf(1 | e, t, void 0, i === void 0 ? null : i) } function d0(n, e, t, i) { var r = gr(); i = i === void 0 ? null : i; var s = void 0; if (Tn !== null) { var o = Tn.memoizedState; if (s = o.destroy, i !== null && Tx(i, o.deps)) { r.memoizedState = zf(e, t, s, i); return } } sn.flags |= n, r.memoizedState = zf(1 | e, t, s, i) } function H_(n, e) { return em(8390656, 8, n, e) } function Rx(n, e) { return d0(2048, 8, n, e) } function YE(n, e) { return d0(4, 2, n, e) } function qE(n, e) { return d0(4, 4, n, e) } function ZE(n, e) { if (typeof e == "function") return n = n(), e(n), function () { e(null) }; if (e != null) return n = n(), e.current = n, function () { e.current = null } } function $E(n, e, t) { return t = t != null ? t.concat([n]) : null, d0(4, 4, ZE.bind(null, e, n), t) } function Lx() { } function eb(n, e) { var t = gr(); e = e === void 0 ? null : e; var i = t.memoizedState; return i !== null && e !== null && Tx(e, i[1]) ? i[0] : (t.memoizedState = [n, e], n) } function tb(n, e) { var t = gr(); e = e === void 0 ? null : e; var i = t.memoizedState; return i !== null && e !== null && Tx(e, i[1]) ? i[0] : (n = n(), t.memoizedState = [n, e], n) } function nb(n, e, t) { return $a & 21 ? (Nr(t, e) || (t = sE(), sn.lanes |= t, el |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, Ci = !0), n.memoizedState = t) } function E9(n, e) { var t = kt; kt = t !== 0 && 4 > t ? t : 4, n(!0); var i = E1.transition; E1.transition = {}; try { n(!1), e() } finally { kt = t, E1.transition = i } } function ib() { return gr().memoizedState } function b9(n, e, t) { var i = Fo(n); if (t = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }, rb(n)) sb(e, t); else if (t = FE(n, e, t, i), t !== null) { var r = mi(); Dr(t, n, i, r), ob(t, e, i) } } function T9(n, e, t) { var i = Fo(n), r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }; if (rb(n)) sb(e, r); else { var s = n.alternate; if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, t); if (r.hasEagerState = !0, r.eagerState = a, Nr(a, o)) { var l = e.interleaved; l === null ? (r.next = r, wx(e)) : (r.next = l.next, l.next = r), e.interleaved = r; return } } catch { } finally { } t = FE(n, e, r, i), t !== null && (r = mi(), Dr(t, n, i, r), ob(t, e, i)) } } function rb(n) { var e = n.alternate; return n === sn || e !== null && e === sn } function sb(n, e) { cf = Dm = !0; var t = n.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e } function ob(n, e, t) { if (t & 4194240) { var i = e.lanes; i &= n.pendingLanes, t |= i, e.lanes = t, cx(n, t) } } var Fm = { readContext: mr, useCallback: Zn, useContext: Zn, useEffect: Zn, useImperativeHandle: Zn, useInsertionEffect: Zn, useLayoutEffect: Zn, useMemo: Zn, useReducer: Zn, useRef: Zn, useState: Zn, useDebugValue: Zn, useDeferredValue: Zn, useTransition: Zn, useMutableSource: Zn, useSyncExternalStore: Zn, useId: Zn, unstable_isNewReconciler: !1 }, B9 = { readContext: mr, useCallback: function (n, e) { return $r().memoizedState = [n, e === void 0 ? null : e], n }, useContext: mr, useEffect: H_, useImperativeHandle: function (n, e, t) { return t = t != null ? t.concat([n]) : null, em(4194308, 4, ZE.bind(null, e, n), t) }, useLayoutEffect: function (n, e) { return em(4194308, 4, n, e) }, useInsertionEffect: function (n, e) { return em(4, 2, n, e) }, useMemo: function (n, e) { var t = $r(); return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n }, useReducer: function (n, e, t) { var i = $r(); return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, i.queue = n, n = n.dispatch = b9.bind(null, sn, n), [i.memoizedState, n] }, useRef: function (n) { var e = $r(); return n = { current: n }, e.memoizedState = n }, useState: G_, useDebugValue: Lx, useDeferredValue: function (n) { return $r().memoizedState = n }, useTransition: function () { var n = G_(!1), e = n[0]; return n = E9.bind(null, n[1]), $r().memoizedState = n, [e, n] }, useMutableSource: function () { }, useSyncExternalStore: function (n, e, t) { var i = sn, r = $r(); if (Yt) { if (t === void 0) throw Error(Me(407)); t = t() } else { if (t = e(), On === null) throw Error(Me(349)); $a & 30 || WE(i, e, t) } r.memoizedState = t; var s = { value: t, getSnapshot: e }; return r.queue = s, H_(JE.bind(null, i, s, n), [n]), i.flags |= 2048, zf(9, jE.bind(null, i, s, t, e), void 0, null), t }, useId: function () { var n = $r(), e = On.identifierPrefix; if (Yt) { var t = Ls, i = Rs; t = (i & ~(1 << 32 - Ir(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Nf++, 0 < t && (e += "H" + t.toString(32)), e += ":" } else t = C9++, e = ":" + e + "r" + t.toString(32) + ":"; return n.memoizedState = e }, unstable_isNewReconciler: !1 }, P9 = { readContext: mr, useCallback: eb, useContext: mr, useEffect: Rx, useImperativeHandle: $E, useInsertionEffect: YE, useLayoutEffect: qE, useMemo: tb, useReducer: b1, useRef: KE, useState: function () { return b1(Of) }, useDebugValue: Lx, useDeferredValue: function (n) { var e = gr(); return nb(e, Tn.memoizedState, n) }, useTransition: function () { var n = b1(Of)[0], e = gr().memoizedState; return [n, e] }, useMutableSource: HE, useSyncExternalStore: VE, useId: ib, unstable_isNewReconciler: !1 }, R9 = { readContext: mr, useCallback: eb, useContext: mr, useEffect: Rx, useImperativeHandle: $E, useInsertionEffect: YE, useLayoutEffect: qE, useMemo: tb, useReducer: T1, useRef: KE, useState: function () { return T1(Of) }, useDebugValue: Lx, useDeferredValue: function (n) { var e = gr(); return Tn === null ? e.memoizedState = n : nb(e, Tn.memoizedState, n) }, useTransition: function () { var n = T1(Of)[0], e = gr().memoizedState; return [n, e] }, useMutableSource: HE, useSyncExternalStore: VE, useId: ib, unstable_isNewReconciler: !1 }; function Pc(n, e) {
  try { var t = "", i = e; do t += sP(i), i = i.return; while (i); var r = t } catch (s) {
    r = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: n, source: e, stack: r, digest: null }
} function B1(n, e, t) { return { value: n, source: null, stack: t ?? null, digest: e ?? null } } function Mv(n, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } var L9 = typeof WeakMap == "function" ? WeakMap : Map; function ab(n, e, t) { t = Ns(-1, t), t.tag = 3, t.payload = { element: null }; var i = e.value; return t.callback = function () { Nm || (Nm = !0, Rv = i), Mv(n, e) }, t } function lb(n, e, t) { t = Ns(-1, t), t.tag = 3; var i = n.type.getDerivedStateFromError; if (typeof i == "function") { var r = e.value; t.payload = function () { return i(r) }, t.callback = function () { Mv(n, e) } } var s = n.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function () { Mv(n, e), typeof i != "function" && (Do === null ? Do = new Set([this]) : Do.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), t } function V_(n, e, t) { var i = n.pingCache; if (i === null) { i = n.pingCache = new L9; var r = new Set; i.set(e, r) } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r)); r.has(t) || (r.add(t), n = J9.bind(null, n, e, t), e.then(n, n)) } function W_(n) { do { var e; if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n; n = n.return } while (n !== null); return null } function j_(n, e, t, i, r) { return n.mode & 1 ? (n.flags |= 65536, n.lanes = r, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Ns(-1, 1), e.tag = 2, Io(t, e, 1))), t.lanes |= 1), n) } var I9 = Qs.ReactCurrentOwner, Ci = !1; function pi(n, e, t, i) { e.child = n === null ? UE(e, null, t, i) : Tc(e, n.child, t, i) } function J_(n, e, t, i, r) { t = t.render; var s = e.ref; return xc(e, r), i = Bx(n, e, t, i, s, r), t = Px(), n !== null && !Ci ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Ws(n, e, r)) : (Yt && t && yx(e), e.flags |= 1, pi(n, e, i, r), e.child) } function X_(n, e, t, i, r) { if (n === null) { var s = t.type; return typeof s == "function" && !Ux(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, cb(n, e, s, i, r)) : (n = rm(t.type, null, i, e, e.mode, r), n.ref = e.ref, n.return = e, e.child = n) } if (s = n.child, !(n.lanes & r)) { var o = s.memoizedProps; if (t = t.compare, t = t !== null ? t : Rf, t(o, i) && n.ref === e.ref) return Ws(n, e, r) } return e.flags |= 1, n = ko(s, i), n.ref = e.ref, n.return = e, e.child = n } function cb(n, e, t, i, r) { if (n !== null) { var s = n.memoizedProps; if (Rf(s, i) && n.ref === e.ref) if (Ci = !1, e.pendingProps = i = s, (n.lanes & r) !== 0) n.flags & 131072 && (Ci = !0); else return e.lanes = n.lanes, Ws(n, e, r) } return _v(n, e, t, i, r) } function ub(n, e, t) { var i = e.pendingProps, r = i.children, s = n !== null ? n.memoizedState : null; if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Gt(ac, Oi), Oi |= t; else { if (!(t & 1073741824)) return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, Gt(ac, Oi), Oi |= n, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : t, Gt(ac, Oi), Oi |= i } else s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, Gt(ac, Oi), Oi |= i; return pi(n, e, r, t), e.child } function fb(n, e) { var t = e.ref; (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function _v(n, e, t, i, r) { var s = bi(t) ? qa : si.current; return s = Ec(e, s), xc(e, r), t = Bx(n, e, t, i, s, r), i = Px(), n !== null && !Ci ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Ws(n, e, r)) : (Yt && i && yx(e), e.flags |= 1, pi(n, e, t, r), e.child) } function Q_(n, e, t, i, r) { if (bi(t)) { var s = !0; bm(e) } else s = !1; if (xc(e, r), e.stateNode === null) tm(n, e), OE(e, t, i), Av(e, t, i, r), i = !0; else if (n === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, u = t.contextType; typeof u == "object" && u !== null ? u = mr(u) : (u = bi(t) ? qa : si.current, u = Ec(e, u)); var h = t.getDerivedStateFromProps, d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function"; d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== u) && z_(e, o, i, u), vo = !1; var p = e.memoizedState; o.state = p, Lm(e, i, o, r), l = e.memoizedState, a !== i || p !== l || Ei.current || vo ? (typeof h == "function" && (xv(e, t, h, i), l = e.memoizedState), (a = vo || O_(e, t, a, i, p, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = u, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1) } else { o = e.stateNode, kE(n, e), a = e.memoizedProps, u = e.type === e.elementType ? a : br(e.type, a), o.props = u, d = e.pendingProps, p = o.context, l = t.contextType, typeof l == "object" && l !== null ? l = mr(l) : (l = bi(t) ? qa : si.current, l = Ec(e, l)); var m = t.getDerivedStateFromProps; (h = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== l) && z_(e, o, i, l), vo = !1, p = e.memoizedState, o.state = p, Lm(e, i, o, r); var v = e.memoizedState; a !== d || p !== v || Ei.current || vo ? (typeof m == "function" && (xv(e, t, m, i), v = e.memoizedState), (u = vo || O_(e, t, u, i, p, v, l) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = v), o.props = i, o.state = v, o.context = l, i = u) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), i = !1) } return wv(n, e, t, i, s, r) } function wv(n, e, t, i, r, s) { fb(n, e); var o = (e.flags & 128) !== 0; if (!i && !o) return r && I_(e, t, !1), Ws(n, e, s); i = e.stateNode, I9.current = e; var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render(); return e.flags |= 1, n !== null && o ? (e.child = Tc(e, n.child, null, s), e.child = Tc(e, null, a, s)) : pi(n, e, a, s), e.memoizedState = i.state, r && I_(e, t, !0), e.child } function hb(n) { var e = n.stateNode; e.pendingContext ? L_(n, e.pendingContext, e.pendingContext !== e.context) : e.context && L_(n, e.context, !1), Cx(n, e.containerInfo) } function K_(n, e, t, i, r) { return bc(), xx(r), e.flags |= 256, pi(n, e, t, i), e.child } var Sv = { dehydrated: null, treeContext: null, retryLane: 0 }; function Cv(n) { return { baseLanes: n, cachePool: null, transitions: null } } function db(n, e, t) { var i = e.pendingProps, r = en.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1), Gt(en, r & 1), n === null) return yv(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = g0(o, i, 0, null), n = Wa(n, i, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = Cv(t), e.memoizedState = Sv, n) : Ix(e, o)); if (r = n.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return D9(n, e, o, i, a, r, t); if (s) { s = i.fallback, o = e.mode, r = n.child, a = r.sibling; var l = { mode: "hidden", children: i.children }; return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = ko(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = ko(a, s) : (s = Wa(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n.child.memoizedState, o = o === null ? Cv(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n.childLanes & ~t, e.memoizedState = Sv, i } return s = n.child, n = s.sibling, i = ko(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = i, e.memoizedState = null, i } function Ix(n, e) { return e = g0({ mode: "visible", children: e }, n.mode, 0, null), e.return = n, n.child = e } function Kd(n, e, t, i) { return i !== null && xx(i), Tc(e, n.child, null, t), n = Ix(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n } function D9(n, e, t, i, r, s, o) { if (t) return e.flags & 256 ? (e.flags &= -257, i = B1(Error(Me(422))), Kd(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = g0({ mode: "visible", children: i.children }, r, 0, null), s = Wa(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && Tc(e, n.child, null, o), e.child.memoizedState = Cv(o), e.memoizedState = Sv, s); if (!(e.mode & 1)) return Kd(n, e, o, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst; return i = a, s = Error(Me(419)), i = B1(s, i, void 0), Kd(n, e, o, i) } if (a = (o & n.childLanes) !== 0, Ci || a) { if (i = On, i !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Vs(n, r), Dr(i, n, r, -1)) } return zx(), i = B1(Error(Me(421))), Kd(n, e, o, i) } return r.data === "$?" ? (e.flags |= 128, e.child = n.child, e = X9.bind(null, n), r._reactRetry = e, null) : (n = s.treeContext, Ui = Lo(r.nextSibling), Hi = e, Yt = !0, Pr = null, n !== null && (cr[ur++] = Rs, cr[ur++] = Ls, cr[ur++] = Za, Rs = n.id, Ls = n.overflow, Za = e), e = Ix(e, i.children), e.flags |= 4096, e) } function Y_(n, e, t) { n.lanes |= e; var i = n.alternate; i !== null && (i.lanes |= e), vv(n.return, e, t) } function P1(n, e, t, i, r) { var s = n.memoizedState; s === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r) } function pb(n, e, t) { var i = e.pendingProps, r = i.revealOrder, s = i.tail; if (pi(n, e, i.children, t), i = en.current, i & 2) i = i & 1 | 2, e.flags |= 128; else { if (n !== null && n.flags & 128) e: for (n = e.child; n !== null;) { if (n.tag === 13) n.memoizedState !== null && Y_(n, t, e); else if (n.tag === 19) Y_(n, t, e); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (; n.sibling === null;) { if (n.return === null || n.return === e) break e; n = n.return } n.sibling.return = n.return, n = n.sibling } i &= 1 } if (Gt(en, i), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (t = e.child, r = null; t !== null;)n = t.alternate, n !== null && Im(n) === null && (r = t), t = t.sibling; t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), P1(e, !1, r, t, s); break; case "backwards": for (t = null, r = e.child, e.child = null; r !== null;) { if (n = r.alternate, n !== null && Im(n) === null) { e.child = r; break } n = r.sibling, r.sibling = t, t = r, r = n } P1(e, !0, t, null, s); break; case "together": P1(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function tm(n, e) { !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2) } function Ws(n, e, t) { if (n !== null && (e.dependencies = n.dependencies), el |= e.lanes, !(t & e.childLanes)) return null; if (n !== null && e.child !== n.child) throw Error(Me(153)); if (e.child !== null) { for (n = e.child, t = ko(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;)n = n.sibling, t = t.sibling = ko(n, n.pendingProps), t.return = e; t.sibling = null } return e.child } function F9(n, e, t) { switch (e.tag) { case 3: hb(e), bc(); break; case 5: GE(e); break; case 1: bi(e.type) && bm(e); break; case 4: Cx(e, e.stateNode.containerInfo); break; case 10: var i = e.type._context, r = e.memoizedProps.value; Gt(Pm, i._currentValue), i._currentValue = r; break; case 13: if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (Gt(en, en.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? db(n, e, t) : (Gt(en, en.current & 1), n = Ws(n, e, t), n !== null ? n.sibling : null); Gt(en, en.current & 1); break; case 19: if (i = (t & e.childLanes) !== 0, n.flags & 128) { if (i) return pb(n, e, t); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Gt(en, en.current), i) break; return null; case 22: case 23: return e.lanes = 0, ub(n, e, t) }return Ws(n, e, t) } var mb, Ev, gb, yb; mb = function (n, e) { for (var t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return } t.sibling.return = t.return, t = t.sibling } }; Ev = function () { }; gb = function (n, e, t, i) { var r = n.memoizedProps; if (r !== i) { n = e.stateNode, Fa(is.current); var s = null; switch (t) { case "input": r = Qy(n, r), i = Qy(n, i), s = []; break; case "select": r = on({}, r, { value: void 0 }), i = on({}, i, { value: void 0 }), s = []; break; case "textarea": r = qy(n, r), i = qy(n, i), s = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Cm) }$y(t, i); var o; t = null; for (u in r) if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null) if (u === "style") { var a = r[u]; for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Sf.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in i) { var l = i[u]; if (a = r != null ? r[u] : void 0, i.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o]) } else t || (s || (s = []), s.push(u, t)), t = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (Sf.hasOwnProperty(u) ? (l != null && u === "onScroll" && Vt("scroll", n), s || a === l || (s = [])) : (s = s || []).push(u, l)) } t && (s = s || []).push("style", t); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; yb = function (n, e, t, i) { t !== i && (e.flags |= 4) }; function Tu(n, e) { if (!Yt) switch (n.tailMode) { case "hidden": e = n.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? n.tail = null : t.sibling = null; break; case "collapsed": t = n.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null } } function $n(n) { var e = n.alternate !== null && n.alternate.child === n.child, t = 0, i = 0; if (e) for (var r = n.child; r !== null;)t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n, r = r.sibling; else for (r = n.child; r !== null;)t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n, r = r.sibling; return n.subtreeFlags |= i, n.childLanes = t, e } function k9(n, e, t) { var i = e.pendingProps; switch (vx(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return $n(e), null; case 1: return bi(e.type) && Em(), $n(e), null; case 3: return i = e.stateNode, Bc(), jt(Ei), jt(si), bx(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n === null || n.child === null) && (Xd(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Pr !== null && (Dv(Pr), Pr = null))), Ev(n, e), $n(e), null; case 5: Ex(e); var r = Fa(kf.current); if (t = e.type, n !== null && e.stateNode != null) gb(n, e, t, i, r), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!i) { if (e.stateNode === null) throw Error(Me(166)); return $n(e), null } if (n = Fa(is.current), Xd(e)) { i = e.stateNode, t = e.type; var s = e.memoizedProps; switch (i[ts] = e, i[Df] = s, n = (e.mode & 1) !== 0, t) { case "dialog": Vt("cancel", i), Vt("close", i); break; case "iframe": case "object": case "embed": Vt("load", i); break; case "video": case "audio": for (r = 0; r < ef.length; r++)Vt(ef[r], i); break; case "source": Vt("error", i); break; case "img": case "image": case "link": Vt("error", i), Vt("load", i); break; case "details": Vt("toggle", i); break; case "input": s_(i, s), Vt("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!s.multiple }, Vt("invalid", i); break; case "textarea": a_(i, s), Vt("invalid", i) }$y(t, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Jd(i.textContent, a, n), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Jd(i.textContent, a, n), r = ["children", "" + a]) : Sf.hasOwnProperty(o) && a != null && o === "onScroll" && Vt("scroll", i) } switch (t) { case "input": Od(i), o_(i, s, !0); break; case "textarea": Od(i), l_(i); break; case "select": case "option": break; default: typeof s.onClick == "function" && (i.onclick = Cm) }i = r, e.updateQueue = i, i !== null && (e.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = WC(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, { is: i.is }) : (n = o.createElement(t), t === "select" && (o = n, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t), n[ts] = e, n[Df] = i, mb(n, e, !1, !1), e.stateNode = n; e: { switch (o = ev(t, i), t) { case "dialog": Vt("cancel", n), Vt("close", n), r = i; break; case "iframe": case "object": case "embed": Vt("load", n), r = i; break; case "video": case "audio": for (r = 0; r < ef.length; r++)Vt(ef[r], n); r = i; break; case "source": Vt("error", n), r = i; break; case "img": case "image": case "link": Vt("error", n), Vt("load", n), r = i; break; case "details": Vt("toggle", n), r = i; break; case "input": s_(n, i), r = Qy(n, i), Vt("invalid", n); break; case "option": r = i; break; case "select": n._wrapperState = { wasMultiple: !!i.multiple }, r = on({}, i, { value: void 0 }), Vt("invalid", n); break; case "textarea": a_(n, i), r = qy(n, i), Vt("invalid", n); break; default: r = i }$y(t, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? XC(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && jC(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Cf(n, l) : typeof l == "number" && Cf(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Sf.hasOwnProperty(s) ? l != null && s === "onScroll" && Vt("scroll", n) : l != null && ix(n, s, l, o)) } switch (t) { case "input": Od(n), o_(n, i, !1); break; case "textarea": Od(n), l_(n); break; case "option": i.value != null && n.setAttribute("value", "" + Uo(i.value)); break; case "select": n.multiple = !!i.multiple, s = i.value, s != null ? mc(n, !!i.multiple, s, !1) : i.defaultValue != null && mc(n, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (n.onclick = Cm) }switch (t) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return $n(e), null; case 6: if (n && e.stateNode != null) yb(n, e, n.memoizedProps, i); else { if (typeof i != "string" && e.stateNode === null) throw Error(Me(166)); if (t = Fa(kf.current), Fa(is.current), Xd(e)) { if (i = e.stateNode, t = e.memoizedProps, i[ts] = e, (s = i.nodeValue !== t) && (n = Hi, n !== null)) switch (n.tag) { case 3: Jd(i.nodeValue, t, (n.mode & 1) !== 0); break; case 5: n.memoizedProps.suppressHydrationWarning !== !0 && Jd(i.nodeValue, t, (n.mode & 1) !== 0) }s && (e.flags |= 4) } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[ts] = e, e.stateNode = i } return $n(e), null; case 13: if (jt(en), i = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (Yt && Ui !== null && e.mode & 1 && !(e.flags & 128)) DE(), bc(), e.flags |= 98560, s = !1; else if (s = Xd(e), i !== null && i.dehydrated !== null) { if (n === null) { if (!s) throw Error(Me(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Me(317)); s[ts] = e } else bc(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; $n(e), s = !1 } else Pr !== null && (Dv(Pr), Pr = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n === null || en.current & 1 ? Bn === 0 && (Bn = 3) : zx())), e.updateQueue !== null && (e.flags |= 4), $n(e), null); case 4: return Bc(), Ev(n, e), n === null && Lf(e.stateNode.containerInfo), $n(e), null; case 10: return _x(e.type._context), $n(e), null; case 17: return bi(e.type) && Em(), $n(e), null; case 19: if (jt(en), s = e.memoizedState, s === null) return $n(e), null; if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) Tu(s, !1); else { if (Bn !== 0 || n !== null && n.flags & 128) for (n = e.child; n !== null;) { if (o = Im(n), o !== null) { for (e.flags |= 128, Tu(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null;)s = t, n = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n = o.dependencies, s.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling; return Gt(en, en.current & 1 | 2), e.child } n = n.sibling } s.tail !== null && vn() > Rc && (e.flags |= 128, i = !0, Tu(s, !1), e.lanes = 4194304) } else { if (!i) if (n = Im(o), n !== null) { if (e.flags |= 128, i = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Tu(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Yt) return $n(e), null } else 2 * vn() - s.renderingStartTime > Rc && t !== 1073741824 && (e.flags |= 128, i = !0, Tu(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = vn(), e.sibling = null, t = en.current, Gt(en, i ? t & 1 | 2 : t & 1), e) : ($n(e), null); case 22: case 23: return Ox(), i = e.memoizedState !== null, n !== null && n.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? Oi & 1073741824 && ($n(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : $n(e), null; case 24: return null; case 25: return null }throw Error(Me(156, e.tag)) } function N9(n, e) { switch (vx(e), e.tag) { case 1: return bi(e.type) && Em(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 3: return Bc(), jt(Ei), jt(si), bx(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null; case 5: return Ex(e), null; case 13: if (jt(en), n = e.memoizedState, n !== null && n.dehydrated !== null) { if (e.alternate === null) throw Error(Me(340)); bc() } return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 19: return jt(en), null; case 4: return Bc(), null; case 10: return _x(e.type._context), null; case 22: case 23: return Ox(), null; case 24: return null; default: return null } } var Yd = !1, ii = !1, O9 = typeof WeakSet == "function" ? WeakSet : Set, He = null; function oc(n, e) { var t = n.ref; if (t !== null) if (typeof t == "function") try { t(null) } catch (i) { dn(n, e, i) } else t.current = null } function bv(n, e, t) { try { t() } catch (i) { dn(n, e, i) } } var q_ = !1; function z9(n, e) { if (uv = _m, n = ME(), gx(n)) { if ("selectionStart" in n) var t = { start: n.selectionStart, end: n.selectionEnd }; else e: { t = (t = n.ownerDocument) && t.defaultView || window; var i = t.getSelection && t.getSelection(); if (i && i.rangeCount !== 0) { t = i.anchorNode; var r = i.anchorOffset, s = i.focusNode; i = i.focusOffset; try { t.nodeType, s.nodeType } catch { t = null; break e } var o = 0, a = -1, l = -1, u = 0, h = 0, d = n, p = null; t: for (; ;) { for (var m; d !== t || r !== 0 && d.nodeType !== 3 || (a = o + r), d !== s || i !== 0 && d.nodeType !== 3 || (l = o + i), d.nodeType === 3 && (o += d.nodeValue.length), (m = d.firstChild) !== null;)p = d, d = m; for (; ;) { if (d === n) break t; if (p === t && ++u === r && (a = o), p === s && ++h === i && (l = o), (m = d.nextSibling) !== null) break; d = p, p = d.parentNode } d = m } t = a === -1 || l === -1 ? null : { start: a, end: l } } else t = null } t = t || { start: 0, end: 0 } } else t = null; for (fv = { focusedElem: n, selectionRange: t }, _m = !1, He = e; He !== null;)if (e = He, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null) n.return = e, He = n; else for (; He !== null;) { e = He; try { var v = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (v !== null) { var y = v.memoizedProps, x = v.memoizedState, A = e.stateNode, _ = A.getSnapshotBeforeUpdate(e.elementType === e.type ? y : br(e.type, y), x); A.__reactInternalSnapshotBeforeUpdate = _ } break; case 3: var M = e.stateNode.containerInfo; M.nodeType === 1 ? M.textContent = "" : M.nodeType === 9 && M.documentElement && M.removeChild(M.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(Me(163)) } } catch (S) { dn(e, e.return, S) } if (n = e.sibling, n !== null) { n.return = e.return, He = n; break } He = e.return } return v = q_, q_ = !1, v } function uf(n, e, t) { var i = e.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & n) === n) { var s = r.destroy; r.destroy = void 0, s !== void 0 && bv(e, t, s) } r = r.next } while (r !== i) } } function p0(n, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var t = e = e.next; do { if ((t.tag & n) === n) { var i = t.create; t.destroy = i() } t = t.next } while (t !== e) } } function Tv(n) { var e = n.ref; if (e !== null) { var t = n.stateNode; switch (n.tag) { case 5: n = t; break; default: n = t }typeof e == "function" ? e(n) : e.current = n } } function vb(n) { var e = n.alternate; e !== null && (n.alternate = null, vb(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[ts], delete e[Df], delete e[pv], delete e[M9], delete e[_9])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } function xb(n) { return n.tag === 5 || n.tag === 3 || n.tag === 4 } function Z_(n) { e: for (; ;) { for (; n.sibling === null;) { if (n.return === null || xb(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.flags & 2 || n.child === null || n.tag === 4) continue e; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function Bv(n, e, t) { var i = n.tag; if (i === 5 || i === 6) n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Cm)); else if (i !== 4 && (n = n.child, n !== null)) for (Bv(n, e, t), n = n.sibling; n !== null;)Bv(n, e, t), n = n.sibling } function Pv(n, e, t) { var i = n.tag; if (i === 5 || i === 6) n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n); else if (i !== 4 && (n = n.child, n !== null)) for (Pv(n, e, t), n = n.sibling; n !== null;)Pv(n, e, t), n = n.sibling } var Gn = null, Tr = !1; function oo(n, e, t) { for (t = t.child; t !== null;)Ab(n, e, t), t = t.sibling } function Ab(n, e, t) { if (ns && typeof ns.onCommitFiberUnmount == "function") try { ns.onCommitFiberUnmount(o0, t) } catch { } switch (t.tag) { case 5: ii || oc(t, e); case 6: var i = Gn, r = Tr; Gn = null, oo(n, e, t), Gn = i, Tr = r, Gn !== null && (Tr ? (n = Gn, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Gn.removeChild(t.stateNode)); break; case 18: Gn !== null && (Tr ? (n = Gn, t = t.stateNode, n.nodeType === 8 ? w1(n.parentNode, t) : n.nodeType === 1 && w1(n, t), Bf(n)) : w1(Gn, t.stateNode)); break; case 4: i = Gn, r = Tr, Gn = t.stateNode.containerInfo, Tr = !0, oo(n, e, t), Gn = i, Tr = r; break; case 0: case 11: case 14: case 15: if (!ii && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && bv(t, e, o), r = r.next } while (r !== i) } oo(n, e, t); break; case 1: if (!ii && (oc(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount() } catch (a) { dn(t, e, a) } oo(n, e, t); break; case 21: oo(n, e, t); break; case 22: t.mode & 1 ? (ii = (i = ii) || t.memoizedState !== null, oo(n, e, t), ii = i) : oo(n, e, t); break; default: oo(n, e, t) } } function $_(n) { var e = n.updateQueue; if (e !== null) { n.updateQueue = null; var t = n.stateNode; t === null && (t = n.stateNode = new O9), e.forEach(function (i) { var r = Q9.bind(null, n, i); t.has(i) || (t.add(i), i.then(r, r)) }) } } function wr(n, e) { var t = e.deletions; if (t !== null) for (var i = 0; i < t.length; i++) { var r = t[i]; try { var s = n, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Gn = a.stateNode, Tr = !1; break e; case 3: Gn = a.stateNode.containerInfo, Tr = !0; break e; case 4: Gn = a.stateNode.containerInfo, Tr = !0; break e }a = a.return } if (Gn === null) throw Error(Me(160)); Ab(s, o, r), Gn = null, Tr = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (u) { dn(r, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)Mb(e, n), e = e.sibling } function Mb(n, e) { var t = n.alternate, i = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: if (wr(e, n), qr(n), i & 4) { try { uf(3, n, n.return), p0(3, n) } catch (y) { dn(n, n.return, y) } try { uf(5, n, n.return) } catch (y) { dn(n, n.return, y) } } break; case 1: wr(e, n), qr(n), i & 512 && t !== null && oc(t, t.return); break; case 5: if (wr(e, n), qr(n), i & 512 && t !== null && oc(t, t.return), n.flags & 32) { var r = n.stateNode; try { Cf(r, "") } catch (y) { dn(n, n.return, y) } } if (i & 4 && (r = n.stateNode, r != null)) { var s = n.memoizedProps, o = t !== null ? t.memoizedProps : s, a = n.type, l = n.updateQueue; if (n.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && HC(r, s), ev(a, o); var u = ev(a, s); for (o = 0; o < l.length; o += 2) { var h = l[o], d = l[o + 1]; h === "style" ? XC(r, d) : h === "dangerouslySetInnerHTML" ? jC(r, d) : h === "children" ? Cf(r, d) : ix(r, h, d, u) } switch (a) { case "input": Ky(r, s); break; case "textarea": VC(r, s); break; case "select": var p = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var m = s.value; m != null ? mc(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? mc(r, !!s.multiple, s.defaultValue, !0) : mc(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[Df] = s } catch (y) { dn(n, n.return, y) } } break; case 6: if (wr(e, n), qr(n), i & 4) { if (n.stateNode === null) throw Error(Me(162)); r = n.stateNode, s = n.memoizedProps; try { r.nodeValue = s } catch (y) { dn(n, n.return, y) } } break; case 3: if (wr(e, n), qr(n), i & 4 && t !== null && t.memoizedState.isDehydrated) try { Bf(e.containerInfo) } catch (y) { dn(n, n.return, y) } break; case 4: wr(e, n), qr(n); break; case 13: wr(e, n), qr(n), r = n.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (kx = vn())), i & 4 && $_(n); break; case 22: if (h = t !== null && t.memoizedState !== null, n.mode & 1 ? (ii = (u = ii) || h, wr(e, n), ii = u) : wr(e, n), qr(n), i & 8192) { if (u = n.memoizedState !== null, (n.stateNode.isHidden = u) && !h && n.mode & 1) for (He = n, h = n.child; h !== null;) { for (d = He = h; He !== null;) { switch (p = He, m = p.child, p.tag) { case 0: case 11: case 14: case 15: uf(4, p, p.return); break; case 1: oc(p, p.return); var v = p.stateNode; if (typeof v.componentWillUnmount == "function") { i = p, t = p.return; try { e = i, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount() } catch (y) { dn(i, t, y) } } break; case 5: oc(p, p.return); break; case 22: if (p.memoizedState !== null) { tw(d); continue } }m !== null ? (m.return = p, He = m) : tw(d) } h = h.sibling } e: for (h = null, d = n; ;) { if (d.tag === 5) { if (h === null) { h = d; try { r = d.stateNode, u ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = JC("display", o)) } catch (y) { dn(n, n.return, y) } } } else if (d.tag === 6) { if (h === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (y) { dn(n, n.return, y) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === n) break e; for (; d.sibling === null;) { if (d.return === null || d.return === n) break e; h === d && (h = null), d = d.return } h === d && (h = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: wr(e, n), qr(n), i & 4 && $_(n); break; case 21: break; default: wr(e, n), qr(n) } } function qr(n) { var e = n.flags; if (e & 2) { try { e: { for (var t = n.return; t !== null;) { if (xb(t)) { var i = t; break e } t = t.return } throw Error(Me(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (Cf(r, ""), i.flags &= -33); var s = Z_(n); Pv(n, s, r); break; case 3: case 4: var o = i.stateNode.containerInfo, a = Z_(n); Bv(n, a, o); break; default: throw Error(Me(161)) } } catch (l) { dn(n, n.return, l) } n.flags &= -3 } e & 4096 && (n.flags &= -4097) } function U9(n, e, t) { He = n, _b(n) } function _b(n, e, t) { for (var i = (n.mode & 1) !== 0; He !== null;) { var r = He, s = r.child; if (r.tag === 22 && i) { var o = r.memoizedState !== null || Yd; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || ii; a = Yd; var u = ii; if (Yd = o, (ii = l) && !u) for (He = r; He !== null;)o = He, l = o.child, o.tag === 22 && o.memoizedState !== null ? nw(r) : l !== null ? (l.return = o, He = l) : nw(r); for (; s !== null;)He = s, _b(s), s = s.sibling; He = r, Yd = a, ii = u } ew(n) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, He = s) : ew(n) } } function ew(n) { for (; He !== null;) { var e = He; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: ii || p0(5, e); break; case 1: var i = e.stateNode; if (e.flags & 4 && !ii) if (t === null) i.componentDidMount(); else { var r = e.elementType === e.type ? t.memoizedProps : br(e.type, t.memoizedProps); i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && N_(e, s, i); break; case 3: var o = e.updateQueue; if (o !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5: t = e.child.stateNode; break; case 1: t = e.child.stateNode }N_(e, o, t) } break; case 5: var a = e.stateNode; if (t === null && e.flags & 4) { t = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && t.focus(); break; case "img": l.src && (t.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var h = u.memoizedState; if (h !== null) { var d = h.dehydrated; d !== null && Bf(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(Me(163)) }ii || e.flags & 512 && Tv(e) } catch (p) { dn(e, e.return, p) } } if (e === n) { He = null; break } if (t = e.sibling, t !== null) { t.return = e.return, He = t; break } He = e.return } } function tw(n) { for (; He !== null;) { var e = He; if (e === n) { He = null; break } var t = e.sibling; if (t !== null) { t.return = e.return, He = t; break } He = e.return } } function nw(n) { for (; He !== null;) { var e = He; try { switch (e.tag) { case 0: case 11: case 15: var t = e.return; try { p0(4, e) } catch (l) { dn(e, t, l) } break; case 1: var i = e.stateNode; if (typeof i.componentDidMount == "function") { var r = e.return; try { i.componentDidMount() } catch (l) { dn(e, r, l) } } var s = e.return; try { Tv(e) } catch (l) { dn(e, s, l) } break; case 5: var o = e.return; try { Tv(e) } catch (l) { dn(e, o, l) } } } catch (l) { dn(e, e.return, l) } if (e === n) { He = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, He = a; break } He = e.return } } var G9 = Math.ceil, km = Qs.ReactCurrentDispatcher, Dx = Qs.ReactCurrentOwner, dr = Qs.ReactCurrentBatchConfig, Bt = 0, On = null, Cn = null, Wn = 0, Oi = 0, ac = Yo(0), Bn = 0, Uf = null, el = 0, m0 = 0, Fx = 0, ff = null, wi = null, kx = 0, Rc = 1 / 0, bs = null, Nm = !1, Rv = null, Do = null, qd = !1, So = null, Om = 0, hf = 0, Lv = null, nm = -1, im = 0; function mi() { return Bt & 6 ? vn() : nm !== -1 ? nm : nm = vn() } function Fo(n) { return n.mode & 1 ? Bt & 2 && Wn !== 0 ? Wn & -Wn : S9.transition !== null ? (im === 0 && (im = sE()), im) : (n = kt, n !== 0 || (n = window.event, n = n === void 0 ? 16 : hE(n.type)), n) : 1 } function Dr(n, e, t, i) { if (50 < hf) throw hf = 0, Lv = null, Error(Me(185)); uh(n, t, i), (!(Bt & 2) || n !== On) && (n === On && (!(Bt & 2) && (m0 |= t), Bn === 4 && _o(n, Wn)), Ti(n, i), t === 1 && Bt === 0 && !(e.mode & 1) && (Rc = vn() + 500, f0 && qo())) } function Ti(n, e) { var t = n.callbackNode; SP(n, e); var i = Mm(n, n === On ? Wn : 0); if (i === 0) t !== null && f_(t), n.callbackNode = null, n.callbackPriority = 0; else if (e = i & -i, n.callbackPriority !== e) { if (t != null && f_(t), e === 1) n.tag === 0 ? w9(iw.bind(null, n)) : RE(iw.bind(null, n)), x9(function () { !(Bt & 6) && qo() }), t = null; else { switch (oE(i)) { case 1: t = lx; break; case 4: t = iE; break; case 16: t = Am; break; case 536870912: t = rE; break; default: t = Am }t = Pb(t, wb.bind(null, n)) } n.callbackPriority = e, n.callbackNode = t } } function wb(n, e) { if (nm = -1, im = 0, Bt & 6) throw Error(Me(327)); var t = n.callbackNode; if (Ac() && n.callbackNode !== t) return null; var i = Mm(n, n === On ? Wn : 0); if (i === 0) return null; if (i & 30 || i & n.expiredLanes || e) e = zm(n, i); else { e = i; var r = Bt; Bt |= 2; var s = Cb(); (On !== n || Wn !== e) && (bs = null, Rc = vn() + 500, Va(n, e)); do try { W9(); break } catch (a) { Sb(n, a) } while (1); Mx(), km.current = s, Bt = r, Cn !== null ? e = 0 : (On = null, Wn = 0, e = Bn) } if (e !== 0) { if (e === 2 && (r = sv(n), r !== 0 && (i = r, e = Iv(n, r))), e === 1) throw t = Uf, Va(n, 0), _o(n, i), Ti(n, vn()), t; if (e === 6) _o(n, i); else { if (r = n.current.alternate, !(i & 30) && !H9(r) && (e = zm(n, i), e === 2 && (s = sv(n), s !== 0 && (i = s, e = Iv(n, s))), e === 1)) throw t = Uf, Va(n, 0), _o(n, i), Ti(n, vn()), t; switch (n.finishedWork = r, n.finishedLanes = i, e) { case 0: case 1: throw Error(Me(345)); case 2: Sa(n, wi, bs); break; case 3: if (_o(n, i), (i & 130023424) === i && (e = kx + 500 - vn(), 10 < e)) { if (Mm(n, 0) !== 0) break; if (r = n.suspendedLanes, (r & i) !== i) { mi(), n.pingedLanes |= n.suspendedLanes & r; break } n.timeoutHandle = dv(Sa.bind(null, n, wi, bs), e); break } Sa(n, wi, bs); break; case 4: if (_o(n, i), (i & 4194240) === i) break; for (e = n.eventTimes, r = -1; 0 < i;) { var o = 31 - Ir(i); s = 1 << o, o = e[o], o > r && (r = o), i &= ~s } if (i = r, i = vn() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * G9(i / 1960)) - i, 10 < i) { n.timeoutHandle = dv(Sa.bind(null, n, wi, bs), i); break } Sa(n, wi, bs); break; case 5: Sa(n, wi, bs); break; default: throw Error(Me(329)) } } } return Ti(n, vn()), n.callbackNode === t ? wb.bind(null, n) : null } function Iv(n, e) { var t = ff; return n.current.memoizedState.isDehydrated && (Va(n, e).flags |= 256), n = zm(n, e), n !== 2 && (e = wi, wi = t, e !== null && Dv(e)), n } function Dv(n) { wi === null ? wi = n : wi.push.apply(wi, n) } function H9(n) { for (var e = n; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (var i = 0; i < t.length; i++) { var r = t[i], s = r.getSnapshot; r = r.value; try { if (!Nr(s(), r)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t; else { if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function _o(n, e) { for (e &= ~Fx, e &= ~m0, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e;) { var t = 31 - Ir(e), i = 1 << t; n[t] = -1, e &= ~i } } function iw(n) { if (Bt & 6) throw Error(Me(327)); Ac(); var e = Mm(n, 0); if (!(e & 1)) return Ti(n, vn()), null; var t = zm(n, e); if (n.tag !== 0 && t === 2) { var i = sv(n); i !== 0 && (e = i, t = Iv(n, i)) } if (t === 1) throw t = Uf, Va(n, 0), _o(n, e), Ti(n, vn()), t; if (t === 6) throw Error(Me(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = e, Sa(n, wi, bs), Ti(n, vn()), null } function Nx(n, e) { var t = Bt; Bt |= 1; try { return n(e) } finally { Bt = t, Bt === 0 && (Rc = vn() + 500, f0 && qo()) } } function tl(n) { So !== null && So.tag === 0 && !(Bt & 6) && Ac(); var e = Bt; Bt |= 1; var t = dr.transition, i = kt; try { if (dr.transition = null, kt = 1, n) return n() } finally { kt = i, dr.transition = t, Bt = e, !(Bt & 6) && qo() } } function Ox() { Oi = ac.current, jt(ac) } function Va(n, e) { n.finishedWork = null, n.finishedLanes = 0; var t = n.timeoutHandle; if (t !== -1 && (n.timeoutHandle = -1, v9(t)), Cn !== null) for (t = Cn.return; t !== null;) { var i = t; switch (vx(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && Em(); break; case 3: Bc(), jt(Ei), jt(si), bx(); break; case 5: Ex(i); break; case 4: Bc(); break; case 13: jt(en); break; case 19: jt(en); break; case 10: _x(i.type._context); break; case 22: case 23: Ox() }t = t.return } if (On = n, Cn = n = ko(n.current, null), Wn = Oi = e, Bn = 0, Uf = null, Fx = m0 = el = 0, wi = ff = null, Da !== null) { for (e = 0; e < Da.length; e++)if (t = Da[e], i = t.interleaved, i !== null) { t.interleaved = null; var r = i.next, s = t.pending; if (s !== null) { var o = s.next; s.next = r, i.next = o } t.pending = i } Da = null } return n } function Sb(n, e) { do { var t = Cn; try { if (Mx(), $p.current = Fm, Dm) { for (var i = sn.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } Dm = !1 } if ($a = 0, Nn = Tn = sn = null, cf = !1, Nf = 0, Dx.current = null, t === null || t.return === null) { Bn = 1, Uf = e, Cn = null; break } e: { var s = n, o = t.return, a = t, l = e; if (e = Wn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, h = a, d = h.tag; if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) { var p = h.alternate; p ? (h.updateQueue = p.updateQueue, h.memoizedState = p.memoizedState, h.lanes = p.lanes) : (h.updateQueue = null, h.memoizedState = null) } var m = W_(o); if (m !== null) { m.flags &= -257, j_(m, o, a, s, e), m.mode & 1 && V_(s, u, e), e = m, l = u; var v = e.updateQueue; if (v === null) { var y = new Set; y.add(l), e.updateQueue = y } else v.add(l); break e } else { if (!(e & 1)) { V_(s, u, e), zx(); break e } l = Error(Me(426)) } } else if (Yt && a.mode & 1) { var x = W_(o); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), j_(x, o, a, s, e), xx(Pc(l, a)); break e } } s = l = Pc(l, a), Bn !== 4 && (Bn = 2), ff === null ? ff = [s] : ff.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var A = ab(s, l, e); k_(s, A); break e; case 1: a = l; var _ = s.type, M = s.stateNode; if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (Do === null || !Do.has(M)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = lb(s, a, e); k_(s, S); break e } }s = s.return } while (s !== null) } bb(t) } catch (b) { e = b, Cn === t && t !== null && (Cn = t = t.return); continue } break } while (1) } function Cb() { var n = km.current; return km.current = Fm, n === null ? Fm : n } function zx() { (Bn === 0 || Bn === 3 || Bn === 2) && (Bn = 4), On === null || !(el & 268435455) && !(m0 & 268435455) || _o(On, Wn) } function zm(n, e) { var t = Bt; Bt |= 2; var i = Cb(); (On !== n || Wn !== e) && (bs = null, Va(n, e)); do try { V9(); break } catch (r) { Sb(n, r) } while (1); if (Mx(), Bt = t, km.current = i, Cn !== null) throw Error(Me(261)); return On = null, Wn = 0, Bn } function V9() { for (; Cn !== null;)Eb(Cn) } function W9() { for (; Cn !== null && !mP();)Eb(Cn) } function Eb(n) { var e = Bb(n.alternate, n, Oi); n.memoizedProps = n.pendingProps, e === null ? bb(n) : Cn = e, Dx.current = null } function bb(n) { var e = n; do { var t = e.alternate; if (n = e.return, e.flags & 32768) { if (t = N9(t, e), t !== null) { t.flags &= 32767, Cn = t; return } if (n !== null) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { Bn = 6, Cn = null; return } } else if (t = k9(t, e, Oi), t !== null) { Cn = t; return } if (e = e.sibling, e !== null) { Cn = e; return } Cn = e = n } while (e !== null); Bn === 0 && (Bn = 5) } function Sa(n, e, t) { var i = kt, r = dr.transition; try { dr.transition = null, kt = 1, j9(n, e, t, i) } finally { dr.transition = r, kt = i } return null } function j9(n, e, t, i) { do Ac(); while (So !== null); if (Bt & 6) throw Error(Me(327)); t = n.finishedWork; var r = n.finishedLanes; if (t === null) return null; if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(Me(177)); n.callbackNode = null, n.callbackPriority = 0; var s = t.lanes | t.childLanes; if (CP(n, s), n === On && (Cn = On = null, Wn = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || qd || (qd = !0, Pb(Am, function () { return Ac(), null })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) { s = dr.transition, dr.transition = null; var o = kt; kt = 1; var a = Bt; Bt |= 4, Dx.current = null, z9(n, t), Mb(t, n), f9(fv), _m = !!uv, fv = uv = null, n.current = t, U9(t), gP(), Bt = a, kt = o, dr.transition = s } else n.current = t; if (qd && (qd = !1, So = n, Om = r), s = n.pendingLanes, s === 0 && (Do = null), xP(t.stateNode), Ti(n, vn()), e !== null) for (i = n.onRecoverableError, t = 0; t < e.length; t++)r = e[t], i(r.value, { componentStack: r.stack, digest: r.digest }); if (Nm) throw Nm = !1, n = Rv, Rv = null, n; return Om & 1 && n.tag !== 0 && Ac(), s = n.pendingLanes, s & 1 ? n === Lv ? hf++ : (hf = 0, Lv = n) : hf = 0, qo(), null } function Ac() { if (So !== null) { var n = oE(Om), e = dr.transition, t = kt; try { if (dr.transition = null, kt = 16 > n ? 16 : n, So === null) var i = !1; else { if (n = So, So = null, Om = 0, Bt & 6) throw Error(Me(331)); var r = Bt; for (Bt |= 4, He = n.current; He !== null;) { var s = He, o = s.child; if (He.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (He = u; He !== null;) { var h = He; switch (h.tag) { case 0: case 11: case 15: uf(8, h, s) }var d = h.child; if (d !== null) d.return = h, He = d; else for (; He !== null;) { h = He; var p = h.sibling, m = h.return; if (vb(h), h === u) { He = null; break } if (p !== null) { p.return = m, He = p; break } He = m } } } var v = s.alternate; if (v !== null) { var y = v.child; if (y !== null) { v.child = null; do { var x = y.sibling; y.sibling = null, y = x } while (y !== null) } } He = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, He = o; else e: for (; He !== null;) { if (s = He, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: uf(9, s, s.return) }var A = s.sibling; if (A !== null) { A.return = s.return, He = A; break e } He = s.return } } var _ = n.current; for (He = _; He !== null;) { o = He; var M = o.child; if (o.subtreeFlags & 2064 && M !== null) M.return = o, He = M; else e: for (o = _; He !== null;) { if (a = He, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: p0(9, a) } } catch (b) { dn(a, a.return, b) } if (a === o) { He = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, He = S; break e } He = a.return } } if (Bt = r, qo(), ns && typeof ns.onPostCommitFiberRoot == "function") try { ns.onPostCommitFiberRoot(o0, n) } catch { } i = !0 } return i } finally { kt = t, dr.transition = e } } return !1 } function rw(n, e, t) { e = Pc(t, e), e = ab(n, e, 1), n = Io(n, e, 1), e = mi(), n !== null && (uh(n, 1, e), Ti(n, e)) } function dn(n, e, t) { if (n.tag === 3) rw(n, n, t); else for (; e !== null;) { if (e.tag === 3) { rw(e, n, t); break } else if (e.tag === 1) { var i = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Do === null || !Do.has(i))) { n = Pc(t, n), n = lb(e, n, 1), e = Io(e, n, 1), n = mi(), e !== null && (uh(e, 1, n), Ti(e, n)); break } } e = e.return } } function J9(n, e, t) { var i = n.pingCache; i !== null && i.delete(e), e = mi(), n.pingedLanes |= n.suspendedLanes & t, On === n && (Wn & t) === t && (Bn === 4 || Bn === 3 && (Wn & 130023424) === Wn && 500 > vn() - kx ? Va(n, 0) : Fx |= t), Ti(n, e) } function Tb(n, e) { e === 0 && (n.mode & 1 ? (e = Gd, Gd <<= 1, !(Gd & 130023424) && (Gd = 4194304)) : e = 1); var t = mi(); n = Vs(n, e), n !== null && (uh(n, e, t), Ti(n, t)) } function X9(n) { var e = n.memoizedState, t = 0; e !== null && (t = e.retryLane), Tb(n, t) } function Q9(n, e) { var t = 0; switch (n.tag) { case 13: var i = n.stateNode, r = n.memoizedState; r !== null && (t = r.retryLane); break; case 19: i = n.stateNode; break; default: throw Error(Me(314)) }i !== null && i.delete(e), Tb(n, t) } var Bb; Bb = function (n, e, t) { if (n !== null) if (n.memoizedProps !== e.pendingProps || Ei.current) Ci = !0; else { if (!(n.lanes & t) && !(e.flags & 128)) return Ci = !1, F9(n, e, t); Ci = !!(n.flags & 131072) } else Ci = !1, Yt && e.flags & 1048576 && LE(e, Bm, e.index); switch (e.lanes = 0, e.tag) { case 2: var i = e.type; tm(n, e), n = e.pendingProps; var r = Ec(e, si.current); xc(e, t), r = Bx(null, e, i, n, r, t); var s = Px(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, bi(i) ? (s = !0, bm(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, Sx(e), r.updater = h0, e.stateNode = r, r._reactInternals = e, Av(e, i, n, t), e = wv(null, e, i, !0, s, t)) : (e.tag = 0, Yt && s && yx(e), pi(null, e, r, t), e = e.child), e; case 16: i = e.elementType; e: { switch (tm(n, e), n = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = Y9(i), n = br(i, n), r) { case 0: e = _v(null, e, i, n, t); break e; case 1: e = Q_(null, e, i, n, t); break e; case 11: e = J_(null, e, i, n, t); break e; case 14: e = X_(null, e, i, br(i.type, n), t); break e }throw Error(Me(306, i, "")) } return e; case 0: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : br(i, r), _v(n, e, i, r, t); case 1: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : br(i, r), Q_(n, e, i, r, t); case 3: e: { if (hb(e), n === null) throw Error(Me(387)); i = e.pendingProps, s = e.memoizedState, r = s.element, kE(n, e), Lm(e, i, null, t); var o = e.memoizedState; if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { r = Pc(Error(Me(423)), e), e = K_(n, e, i, t, r); break e } else if (i !== r) { r = Pc(Error(Me(424)), e), e = K_(n, e, i, t, r); break e } else for (Ui = Lo(e.stateNode.containerInfo.firstChild), Hi = e, Yt = !0, Pr = null, t = UE(e, null, i, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (bc(), i === r) { e = Ws(n, e, t); break e } pi(n, e, i, t) } e = e.child } return e; case 5: return GE(e), n === null && yv(e), i = e.type, r = e.pendingProps, s = n !== null ? n.memoizedProps : null, o = r.children, hv(i, r) ? o = null : s !== null && hv(i, s) && (e.flags |= 32), fb(n, e), pi(n, e, o, t), e.child; case 6: return n === null && yv(e), null; case 13: return db(n, e, t); case 4: return Cx(e, e.stateNode.containerInfo), i = e.pendingProps, n === null ? e.child = Tc(e, null, i, t) : pi(n, e, i, t), e.child; case 11: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : br(i, r), J_(n, e, i, r, t); case 7: return pi(n, e, e.pendingProps, t), e.child; case 8: return pi(n, e, e.pendingProps.children, t), e.child; case 12: return pi(n, e, e.pendingProps.children, t), e.child; case 10: e: { if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, Gt(Pm, i._currentValue), i._currentValue = o, s !== null) if (Nr(s.value, o)) { if (s.children === r.children && !Ei.current) { e = Ws(n, e, t); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === i) { if (s.tag === 1) { l = Ns(-1, t & -t), l.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var h = u.pending; h === null ? l.next = l : (l.next = h.next, h.next = l), u.pending = l } } s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), vv(s.return, t, e), a.lanes |= t; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(Me(341)); o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), vv(o, t, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } pi(n, e, r.children, t), e = e.child } return e; case 9: return r = e.type, i = e.pendingProps.children, xc(e, t), r = mr(r), i = i(r), e.flags |= 1, pi(n, e, i, t), e.child; case 14: return i = e.type, r = br(i, e.pendingProps), r = br(i.type, r), X_(n, e, i, r, t); case 15: return cb(n, e, e.type, e.pendingProps, t); case 17: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : br(i, r), tm(n, e), e.tag = 1, bi(i) ? (n = !0, bm(e)) : n = !1, xc(e, t), OE(e, i, r), Av(e, i, r, t), wv(null, e, i, !0, n, t); case 19: return pb(n, e, t); case 22: return ub(n, e, t) }throw Error(Me(156, e.tag)) }; function Pb(n, e) { return nE(n, e) } function K9(n, e, t, i) { this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function hr(n, e, t, i) { return new K9(n, e, t, i) } function Ux(n) { return n = n.prototype, !(!n || !n.isReactComponent) } function Y9(n) { if (typeof n == "function") return Ux(n) ? 1 : 0; if (n != null) { if (n = n.$$typeof, n === sx) return 11; if (n === ox) return 14 } return 2 } function ko(n, e) { var t = n.alternate; return t === null ? (t = hr(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t } function rm(n, e, t, i, r, s) { var o = 2; if (i = n, typeof n == "function") Ux(n) && (o = 1); else if (typeof n == "string") o = 5; else e: switch (n) { case ql: return Wa(t.children, r, s, e); case rx: o = 8, r |= 8; break; case Wy: return n = hr(12, t, e, r | 2), n.elementType = Wy, n.lanes = s, n; case jy: return n = hr(13, t, e, r), n.elementType = jy, n.lanes = s, n; case Jy: return n = hr(19, t, e, r), n.elementType = Jy, n.lanes = s, n; case zC: return g0(t, r, s, e); default: if (typeof n == "object" && n !== null) switch (n.$$typeof) { case NC: o = 10; break e; case OC: o = 9; break e; case sx: o = 11; break e; case ox: o = 14; break e; case yo: o = 16, i = null; break e }throw Error(Me(130, n == null ? n : typeof n, "")) }return e = hr(o, t, e, r), e.elementType = n, e.type = i, e.lanes = s, e } function Wa(n, e, t, i) { return n = hr(7, n, i, e), n.lanes = t, n } function g0(n, e, t, i) { return n = hr(22, n, i, e), n.elementType = zC, n.lanes = t, n.stateNode = { isHidden: !1 }, n } function R1(n, e, t) { return n = hr(6, n, null, e), n.lanes = t, n } function L1(n, e, t) { return e = hr(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e } function q9(n, e, t, i, r) { this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = h1(0), this.expirationTimes = h1(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = h1(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function Gx(n, e, t, i, r, s, o, a, l) { return n = new q9(n, e, t, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = hr(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Sx(s), n } function Z9(n, e, t) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Yl, key: i == null ? null : "" + i, children: n, containerInfo: e, implementation: t } } function Rb(n) { if (!n) return Go; n = n._reactInternals; e: { if (al(n) !== n || n.tag !== 1) throw Error(Me(170)); var e = n; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (bi(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(Me(171)) } if (n.tag === 1) { var t = n.type; if (bi(t)) return PE(n, t, e) } return e } function Lb(n, e, t, i, r, s, o, a, l) { return n = Gx(t, i, !0, n, r, s, o, a, l), n.context = Rb(null), t = n.current, i = mi(), r = Fo(t), s = Ns(i, r), s.callback = e ?? null, Io(t, s, r), n.current.lanes = r, uh(n, r, i), Ti(n, i), n } function y0(n, e, t, i) { var r = e.current, s = mi(), o = Fo(r); return t = Rb(t), e.context === null ? e.context = t : e.pendingContext = t, e = Ns(s, o), e.payload = { element: n }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n = Io(r, e, o), n !== null && (Dr(n, r, o, s), Zp(n, r, o)), o } function Um(n) { if (n = n.current, !n.child) return null; switch (n.child.tag) { case 5: return n.child.stateNode; default: return n.child.stateNode } } function sw(n, e) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { var t = n.retryLane; n.retryLane = t !== 0 && t < e ? t : e } } function Hx(n, e) { sw(n, e), (n = n.alternate) && sw(n, e) } function $9() { return null } var Ib = typeof reportError == "function" ? reportError : function (n) { console.error(n) }; function Vx(n) { this._internalRoot = n } v0.prototype.render = Vx.prototype.render = function (n) { var e = this._internalRoot; if (e === null) throw Error(Me(409)); y0(n, e, null, null) }; v0.prototype.unmount = Vx.prototype.unmount = function () { var n = this._internalRoot; if (n !== null) { this._internalRoot = null; var e = n.containerInfo; tl(function () { y0(null, n, null, null) }), e[Hs] = null } }; function v0(n) { this._internalRoot = n } v0.prototype.unstable_scheduleHydration = function (n) { if (n) { var e = cE(); n = { blockedOn: null, target: n, priority: e }; for (var t = 0; t < Mo.length && e !== 0 && e < Mo[t].priority; t++); Mo.splice(t, 0, n), t === 0 && fE(n) } }; function Wx(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function x0(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable ")) } function ow() { } function eR(n, e, t, i, r) { if (r) { if (typeof i == "function") { var s = i; i = function () { var u = Um(o); s.call(u) } } var o = Lb(e, i, n, 0, null, !1, !1, "", ow); return n._reactRootContainer = o, n[Hs] = o.current, Lf(n.nodeType === 8 ? n.parentNode : n), tl(), o } for (; r = n.lastChild;)n.removeChild(r); if (typeof i == "function") { var a = i; i = function () { var u = Um(l); a.call(u) } } var l = Gx(n, 0, !1, null, null, !1, !1, "", ow); return n._reactRootContainer = l, n[Hs] = l.current, Lf(n.nodeType === 8 ? n.parentNode : n), tl(function () { y0(e, l, t, i) }), l } function A0(n, e, t, i, r) { var s = t._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = Um(o); a.call(l) } } y0(e, o, n, r) } else o = eR(t, e, n, r, i); return Um(o) } aE = function (n) { switch (n.tag) { case 3: var e = n.stateNode; if (e.current.memoizedState.isDehydrated) { var t = $u(e.pendingLanes); t !== 0 && (cx(e, t | 1), Ti(e, vn()), !(Bt & 6) && (Rc = vn() + 500, qo())) } break; case 13: tl(function () { var i = Vs(n, 1); if (i !== null) { var r = mi(); Dr(i, n, 1, r) } }), Hx(n, 1) } }; ux = function (n) { if (n.tag === 13) { var e = Vs(n, 134217728); if (e !== null) { var t = mi(); Dr(e, n, 134217728, t) } Hx(n, 134217728) } }; lE = function (n) { if (n.tag === 13) { var e = Fo(n), t = Vs(n, e); if (t !== null) { var i = mi(); Dr(t, n, e, i) } Hx(n, e) } }; cE = function () { return kt }; uE = function (n, e) { var t = kt; try { return kt = n, e() } finally { kt = t } }; nv = function (n, e, t) { switch (e) { case "input": if (Ky(n, t), e = t.name, t.type === "radio" && e != null) { for (t = n; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) { var i = t[e]; if (i !== n && i.form === n.form) { var r = u0(i); if (!r) throw Error(Me(90)); GC(i), Ky(i, r) } } } break; case "textarea": VC(n, t); break; case "select": e = t.value, e != null && mc(n, !!t.multiple, e, !1) } }; YC = Nx; qC = tl; var tR = { usingClientEntryPoint: !1, Events: [hh, tc, u0, QC, KC, Nx] }, Bu = { findFiberByHostInstance: Ia, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, nR = { bundleType: Bu.bundleType, version: Bu.version, rendererPackageName: Bu.rendererPackageName, rendererConfig: Bu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Qs.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return n = eE(n), n === null ? null : n.stateNode }, findFiberByHostInstance: Bu.findFiberByHostInstance || $9, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Zd = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Zd.isDisabled && Zd.supportsFiber) try { o0 = Zd.inject(nR), ns = Zd } catch { } } Qi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tR; Qi.createPortal = function (n, e) { var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Wx(e)) throw Error(Me(200)); return Z9(n, e, null, t) }; Qi.createRoot = function (n, e) { if (!Wx(n)) throw Error(Me(299)); var t = !1, i = "", r = Ib; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = Gx(n, 1, !1, null, null, t, !1, i, r), n[Hs] = e.current, Lf(n.nodeType === 8 ? n.parentNode : n), new Vx(e) }; Qi.findDOMNode = function (n) { if (n == null) return null; if (n.nodeType === 1) return n; var e = n._reactInternals; if (e === void 0) throw typeof n.render == "function" ? Error(Me(188)) : (n = Object.keys(n).join(","), Error(Me(268, n))); return n = eE(e), n = n === null ? null : n.stateNode, n }; Qi.flushSync = function (n) { return tl(n) }; Qi.hydrate = function (n, e, t) { if (!x0(e)) throw Error(Me(200)); return A0(null, n, e, !0, t) }; Qi.hydrateRoot = function (n, e, t) { if (!Wx(n)) throw Error(Me(405)); var i = t != null && t.hydratedSources || null, r = !1, s = "", o = Ib; if (t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = Lb(e, null, n, 1, t ?? null, r, !1, s, o), n[Hs] = e.current, Lf(n), i) for (n = 0; n < i.length; n++)t = i[n], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r); return new v0(e) }; Qi.render = function (n, e, t) { if (!x0(e)) throw Error(Me(200)); return A0(null, n, e, !1, t) }; Qi.unmountComponentAtNode = function (n) { if (!x0(n)) throw Error(Me(40)); return n._reactRootContainer ? (tl(function () { A0(null, null, n, !1, function () { n._reactRootContainer = null, n[Hs] = null }) }), !0) : !1 }; Qi.unstable_batchedUpdates = Nx; Qi.unstable_renderSubtreeIntoContainer = function (n, e, t, i) { if (!x0(t)) throw Error(Me(200)); if (n == null || n._reactInternals === void 0) throw Error(Me(38)); return A0(n, e, t, !1, i) }; Qi.version = "18.2.0-next-9e3b772b8-20220608"; (function (n) { function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } e(), n.exports = Qi })($B); var Db, aw = gm; Db = Gy.createRoot = aw.createRoot, Gy.hydrateRoot = aw.hydrateRoot;/**
 * @remix-run/router v1.3.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Gf() { return Gf = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, Gf.apply(this, arguments) } var ka; (function (n) { n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE" })(ka || (ka = {})); const lw = "popstate"; function iR(n) { n === void 0 && (n = {}); function e(i, r) { let { pathname: s, search: o, hash: a } = i.location; return Fv("", { pathname: s, search: o, hash: a }, r.state && r.state.usr || null, r.state && r.state.key || "default") } function t(i, r) { return typeof r == "string" ? r : Gm(r) } return sR(e, t, null, n) } function No(n, e) { if (n === !1 || n === null || typeof n > "u") throw new Error(e) } function rR() { return Math.random().toString(36).substr(2, 8) } function cw(n, e) { return { usr: n.state, key: n.key, idx: e } } function Fv(n, e, t, i) { return t === void 0 && (t = null), Gf({ pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" }, typeof e == "string" ? M0(e) : e, { state: t, key: e && e.key || i || rR() }) } function Gm(n) { let { pathname: e = "/", search: t = "", hash: i = "" } = n; return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e } function M0(n) { let e = {}; if (n) { let t = n.indexOf("#"); t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t)); let i = n.indexOf("?"); i >= 0 && (e.search = n.substr(i), n = n.substr(0, i)), n && (e.pathname = n) } return e } function sR(n, e, t, i) { i === void 0 && (i = {}); let { window: r = document.defaultView, v5Compat: s = !1 } = i, o = r.history, a = ka.Pop, l = null, u = h(); u == null && (u = 0, o.replaceState(Gf({}, o.state, { idx: u }), "")); function h() { return (o.state || { idx: null }).idx } function d() { a = ka.Pop; let x = h(), A = x == null ? null : x - u; u = x, l && l({ action: a, location: y.location, delta: A }) } function p(x, A) { a = ka.Push; let _ = Fv(y.location, x, A); t && t(_, x), u = h() + 1; let M = cw(_, u), S = y.createHref(_); try { o.pushState(M, "", S) } catch { r.location.assign(S) } s && l && l({ action: a, location: y.location, delta: 1 }) } function m(x, A) { a = ka.Replace; let _ = Fv(y.location, x, A); t && t(_, x), u = h(); let M = cw(_, u), S = y.createHref(_); o.replaceState(M, "", S), s && l && l({ action: a, location: y.location, delta: 0 }) } function v(x) { let A = r.location.origin !== "null" ? r.location.origin : r.location.href, _ = typeof x == "string" ? x : Gm(x); return No(A, "No window.location.(origin|href) available to create URL for href: " + _), new URL(_, A) } let y = { get action() { return a }, get location() { return n(r, o) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return r.addEventListener(lw, d), l = x, () => { r.removeEventListener(lw, d), l = null } }, createHref(x) { return e(r, x) }, createURL: v, encodeLocation(x) { let A = v(x); return { pathname: A.pathname, search: A.search, hash: A.hash } }, push: p, replace: m, go(x) { return o.go(x) } }; return y } var uw; (function (n) { n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error" })(uw || (uw = {})); function Fb(n, e) { if (e === "/") return n; if (!n.toLowerCase().startsWith(e.toLowerCase())) return null; let t = e.endsWith("/") ? e.length - 1 : e.length, i = n.charAt(t); return i && i !== "/" ? null : n.slice(t) || "/" } function oR(n, e) { e === void 0 && (e = "/"); let { pathname: t, search: i = "", hash: r = "" } = typeof n == "string" ? M0(n) : n; return { pathname: t ? t.startsWith("/") ? t : aR(t, e) : e, search: lR(i), hash: cR(r) } } function aR(n, e) { let t = e.replace(/\/+$/, "").split("/"); return n.split("/").forEach(r => { r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r) }), t.length > 1 ? t.join("/") : "/" } function I1(n, e, t, i) { return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + t + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function kb(n) { return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0) } function Nb(n, e, t, i) { i === void 0 && (i = !1); let r; typeof n == "string" ? r = M0(n) : (r = Gf({}, n), No(!r.pathname || !r.pathname.includes("?"), I1("?", "pathname", "search", r)), No(!r.pathname || !r.pathname.includes("#"), I1("#", "pathname", "hash", r)), No(!r.search || !r.search.includes("#"), I1("#", "search", "hash", r))); let s = n === "" || r.pathname === "", o = s ? "/" : r.pathname, a; if (i || o == null) a = t; else { let d = e.length - 1; if (o.startsWith("..")) { let p = o.split("/"); for (; p[0] === "..";)p.shift(), d -= 1; r.pathname = p.join("/") } a = d >= 0 ? e[d] : "/" } let l = oR(r, a), u = o && o !== "/" && o.endsWith("/"), h = (s || o === ".") && t.endsWith("/"); return !l.pathname.endsWith("/") && (u || h) && (l.pathname += "/"), l } const Ob = n => n.join("/").replace(/\/\/+/g, "/"), lR = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, cR = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n, uR = ["post", "put", "patch", "delete"];[...uR];/**
 * React Router v6.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function fR(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } const hR = typeof Object.is == "function" ? Object.is : fR, { useState: dR, useEffect: pR, useLayoutEffect: mR, useDebugValue: gR } = Uy; function yR(n, e, t) { const i = e(), [{ inst: r }, s] = dR({ inst: { value: i, getSnapshot: e } }); return mR(() => { r.value = i, r.getSnapshot = e, D1(r) && s({ inst: r }) }, [n, i, e]), pR(() => (D1(r) && s({ inst: r }), n(() => { D1(r) && s({ inst: r }) })), [n]), gR(i), i } function D1(n) { const e = n.getSnapshot, t = n.value; try { const i = e(); return !hR(t, i) } catch { return !0 } } function vR(n, e, t) { return e() } const xR = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", AR = !xR, MR = AR ? vR : yR; "useSyncExternalStore" in Uy && (n => n.useSyncExternalStore)(Uy); const _0 = U.createContext(null), jx = U.createContext(null), zb = U.createContext({ outlet: null, matches: [] }); function _R(n, e) { let { relative: t } = e === void 0 ? {} : e; w0() || No(!1); let { basename: i, navigator: r } = U.useContext(_0), { hash: s, pathname: o, search: a } = Ub(n, { relative: t }), l = o; return i !== "/" && (l = o === "/" ? i : Ob([i, o])), r.createHref({ pathname: l, search: a, hash: s }) } function w0() { return U.useContext(jx) != null } function Jx() { return w0() || No(!1), U.useContext(jx).location } function wR() { w0() || No(!1); let { basename: n, navigator: e } = U.useContext(_0), { matches: t } = U.useContext(zb), { pathname: i } = Jx(), r = JSON.stringify(kb(t).map(a => a.pathnameBase)), s = U.useRef(!1); return U.useEffect(() => { s.current = !0 }), U.useCallback(function (a, l) { if (l === void 0 && (l = {}), !s.current) return; if (typeof a == "number") { e.go(a); return } let u = Nb(a, JSON.parse(r), i, l.relative === "path"); n !== "/" && (u.pathname = u.pathname === "/" ? n : Ob([n, u.pathname])), (l.replace ? e.replace : e.push)(u, l.state, l) }, [n, e, r, i]) } function Ub(n, e) { let { relative: t } = e === void 0 ? {} : e, { matches: i } = U.useContext(zb), { pathname: r } = Jx(), s = JSON.stringify(kb(i).map(o => o.pathnameBase)); return U.useMemo(() => Nb(n, JSON.parse(s), r, t === "path"), [n, s, r, t]) } var fw; (function (n) { n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator" })(fw || (fw = {})); var hw; (function (n) { n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator" })(hw || (hw = {})); function SR(n) { let { basename: e = "/", children: t = null, location: i, navigationType: r = ka.Pop, navigator: s, static: o = !1 } = n; w0() && No(!1); let a = e.replace(/^\/*/, "/"), l = U.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]); typeof i == "string" && (i = M0(i)); let { pathname: u = "/", search: h = "", hash: d = "", state: p = null, key: m = "default" } = i, v = U.useMemo(() => { let y = Fb(u, a); return y == null ? null : { pathname: y, search: h, hash: d, state: p, key: m } }, [a, u, h, d, p, m]); return v == null ? null : U.createElement(_0.Provider, { value: l }, U.createElement(jx.Provider, { children: t, value: { location: v, navigationType: r } })) } var dw; (function (n) { n[n.pending = 0] = "pending", n[n.success = 1] = "success", n[n.error = 2] = "error" })(dw || (dw = {})); new Promise(() => { });/**
 * React Router DOM v6.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function kv() { return kv = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, kv.apply(this, arguments) } function CR(n, e) { if (n == null) return {}; var t = {}, i = Object.keys(n), r, s; for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]); return t } function ER(n) { return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) } function bR(n, e) { return n.button === 0 && (!e || e === "_self") && !ER(n) } const TR = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"]; function BR(n) { let { basename: e, children: t, window: i } = n, r = U.useRef(); r.current == null && (r.current = iR({ window: i, v5Compat: !0 })); let s = r.current, [o, a] = U.useState({ action: s.action, location: s.location }); return U.useLayoutEffect(() => s.listen(a), [s]), U.createElement(SR, { basename: e, children: t, location: o.location, navigationType: o.action, navigator: s }) } const PR = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", RR = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, LR = U.forwardRef(function (e, t) { let { onClick: i, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: u, preventScrollReset: h } = e, d = CR(e, TR), { basename: p } = U.useContext(_0), m, v = !1; if (typeof u == "string" && RR.test(u) && (m = u, PR)) { let _ = new URL(window.location.href), M = u.startsWith("//") ? new URL(_.protocol + u) : new URL(u), S = Fb(M.pathname, p); M.origin === _.origin && S != null ? u = S + M.search + M.hash : v = !0 } let y = _R(u, { relative: r }), x = IR(u, { replace: o, state: a, target: l, preventScrollReset: h, relative: r }); function A(_) { i && i(_), _.defaultPrevented || x(_) } return U.createElement("a", kv({}, d, { href: m || y, onClick: v || s ? i : A, ref: t, target: l })) }); var pw; (function (n) { n.UseScrollRestoration = "useScrollRestoration", n.UseSubmitImpl = "useSubmitImpl", n.UseFetcher = "useFetcher" })(pw || (pw = {})); var mw; (function (n) { n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration" })(mw || (mw = {})); function IR(n, e) { let { target: t, replace: i, state: r, preventScrollReset: s, relative: o } = e === void 0 ? {} : e, a = wR(), l = Jx(), u = Ub(n, { relative: o }); return U.useCallback(h => { if (bR(h, t)) { h.preventDefault(); let d = i !== void 0 ? i : Gm(l) === Gm(u); a(n, { replace: d, state: r, preventScrollReset: s, relative: o }) } }, [l, a, u, i, r, t, n, s, o]) }/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const S0 = "150", Ca = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Ea = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, Gb = 0, Nv = 1, Hb = 2, DR = 3, Vb = 0, C0 = 1, df = 2, Na = 3, as = 0, Bi = 1, Lr = 2, FR = 2, Os = 0, ja = 1, Ov = 2, zv = 3, Uv = 4, Wb = 5, Ra = 100, jb = 101, Jb = 102, Gv = 103, Hv = 104, Xb = 200, Qb = 201, Kb = 202, Yb = 203, Xx = 204, Qx = 205, qb = 206, Zb = 207, $b = 208, e5 = 209, t5 = 210, n5 = 0, i5 = 1, r5 = 2, Hm = 3, s5 = 4, o5 = 5, a5 = 6, l5 = 7, ph = 0, c5 = 1, u5 = 2, Fr = 0, f5 = 1, h5 = 2, d5 = 3, Kx = 4, p5 = 5, E0 = 300, Ho = 301, Vo = 302, Hf = 303, Vf = 304, Xc = 306, Wo = 1e3, Hn = 1001, Lc = 1002, pn = 1003, Wf = 1004, kR = 1004, Mc = 1005, NR = 1005, tn = 1006, b0 = 1007, OR = 1007, ls = 1008, zR = 1008, js = 1009, m5 = 1010, g5 = 1011, Yx = 1012, y5 = 1013, Co = 1014, Is = 1015, Ic = 1016, v5 = 1017, x5 = 1018, Ja = 1020, A5 = 1021, Si = 1023, M5 = 1024, _5 = 1025, Oo = 1026, nl = 1027, w5 = 1028, S5 = 1029, C5 = 1030, E5 = 1031, b5 = 1033, sm = 33776, om = 33777, am = 33778, lm = 33779, Vv = 35840, Wv = 35841, jv = 35842, Jv = 35843, T5 = 36196, Xv = 37492, Qv = 37496, Kv = 37808, Yv = 37809, qv = 37810, Zv = 37811, $v = 37812, e2 = 37813, t2 = 37814, n2 = 37815, i2 = 37816, r2 = 37817, s2 = 37818, o2 = 37819, a2 = 37820, l2 = 37821, cm = 36492, B5 = 36283, c2 = 36284, u2 = 36285, f2 = 36286, P5 = 2200, R5 = 2201, L5 = 2202, Dc = 2300, il = 2301, um = 2302, Oa = 2400, za = 2401, jf = 2402, T0 = 2500, qx = 2501, UR = 0, I5 = 1, Zx = 2, Js = 3e3, St = 3001, D5 = 3200, F5 = 3201, Ks = 0, k5 = 1, GR = "", Br = "srgb", Fc = "srgb-linear", $x = "display-p3", HR = 0, fm = 7680, VR = 7681, WR = 7682, jR = 7683, JR = 34055, XR = 34056, QR = 5386, KR = 512, YR = 513, qR = 514, ZR = 515, $R = 516, eL = 517, tL = 518, N5 = 519, Jf = 35044, Xa = 35048, nL = 35040, iL = 35045, rL = 35049, sL = 35041, oL = 35046, aL = 35050, lL = 35042, cL = "100", h2 = "300 es", Vm = 1035; class us { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const i = this._listeners; i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const i = this._listeners; return i[e] !== void 0 && i[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const r = this._listeners[e]; if (r !== void 0) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const i = this._listeners[e.type]; if (i !== void 0) { e.target = this; const r = i.slice(0); for (let s = 0, o = r.length; s < o; s++)r[s].call(this, e); e.target = null } } } const ei = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let gw = 1234567; const Qa = Math.PI / 180, Xf = 180 / Math.PI; function Vi() { const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0; return (ei[n & 255] + ei[n >> 8 & 255] + ei[n >> 16 & 255] + ei[n >> 24 & 255] + "-" + ei[e & 255] + ei[e >> 8 & 255] + "-" + ei[e >> 16 & 15 | 64] + ei[e >> 24 & 255] + "-" + ei[t & 63 | 128] + ei[t >> 8 & 255] + "-" + ei[t >> 16 & 255] + ei[t >> 24 & 255] + ei[i & 255] + ei[i >> 8 & 255] + ei[i >> 16 & 255] + ei[i >> 24 & 255]).toLowerCase() } function xn(n, e, t) { return Math.max(e, Math.min(t, n)) } function eA(n, e) { return (n % e + e) % e } function uL(n, e, t, i, r) { return i + (n - e) * (r - i) / (t - e) } function fL(n, e, t) { return n !== e ? (t - n) / (e - n) : 0 } function pf(n, e, t) { return (1 - t) * n + t * e } function hL(n, e, t, i) { return pf(n, e, 1 - Math.exp(-t * i)) } function dL(n, e = 1) { return e - Math.abs(eA(n, e * 2) - e) } function pL(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n)) } function mL(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10)) } function gL(n, e) { return n + Math.floor(Math.random() * (e - n + 1)) } function yL(n, e) { return n + Math.random() * (e - n) } function vL(n) { return n * (.5 - Math.random()) } function xL(n) { n !== void 0 && (gw = n); let e = gw += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function AL(n) { return n * Qa } function ML(n) { return n * Xf } function d2(n) { return (n & n - 1) === 0 && n !== 0 } function O5(n) { return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2)) } function z5(n) { return Math.pow(2, Math.floor(Math.log(n) / Math.LN2)) } function _L(n, e, t, i, r) { const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), u = s((e + i) / 2), h = o((e + i) / 2), d = s((e - i) / 2), p = o((e - i) / 2), m = s((i - e) / 2), v = o((i - e) / 2); switch (r) { case "XYX": n.set(a * h, l * d, l * p, a * u); break; case "YZY": n.set(l * p, a * h, l * d, a * u); break; case "ZXZ": n.set(l * d, l * p, a * h, a * u); break; case "XZX": n.set(a * h, l * v, l * m, a * u); break; case "YXY": n.set(l * m, a * h, l * v, a * u); break; case "ZYZ": n.set(l * v, l * m, a * h, a * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } function Ds(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint16Array: return n / 65535; case Uint8Array: return n / 255; case Int16Array: return Math.max(n / 32767, -1); case Int8Array: return Math.max(n / 127, -1); default: throw new Error("Invalid component type.") } } function zt(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint16Array: return Math.round(n * 65535); case Uint8Array: return Math.round(n * 255); case Int16Array: return Math.round(n * 32767); case Int8Array: return Math.round(n * 127); default: throw new Error("Invalid component type.") } } const tA = { DEG2RAD: Qa, RAD2DEG: Xf, generateUUID: Vi, clamp: xn, euclideanModulo: eA, mapLinear: uL, inverseLerp: fL, lerp: pf, damp: hL, pingpong: dL, smoothstep: pL, smootherstep: mL, randInt: gL, randFloat: yL, randFloatSpread: vL, seededRandom: xL, degToRad: AL, radToDeg: ML, isPowerOfTwo: d2, ceilPowerOfTwo: O5, floorPowerOfTwo: z5, setQuaternionFromProperEuler: _L, normalize: zt, denormalize: Ds }; class me { constructor(e = 0, t = 0) { me.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, i = this.y, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y; return t * t + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y; return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class Vn { constructor() { Vn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set(e, t, i, r, s, o, a, l, u) { const h = this.elements; return h[0] = e, h[1] = r, h[2] = a, h[3] = t, h[4] = s, h[5] = l, h[6] = i, h[7] = o, h[8] = u, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], l = i[6], u = i[1], h = i[4], d = i[7], p = i[2], m = i[5], v = i[8], y = r[0], x = r[3], A = r[6], _ = r[1], M = r[4], S = r[7], b = r[2], B = r[5], R = r[8]; return s[0] = o * y + a * _ + l * b, s[3] = o * x + a * M + l * B, s[6] = o * A + a * S + l * R, s[1] = u * y + h * _ + d * b, s[4] = u * x + h * M + d * B, s[7] = u * A + h * S + d * R, s[2] = p * y + m * _ + v * b, s[5] = p * x + m * M + v * B, s[8] = p * A + m * S + v * R, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], h = e[8]; return t * o * h - t * a * u - i * s * h + i * a * l + r * s * u - r * o * l } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], h = e[8], d = h * o - a * u, p = a * l - h * s, m = u * s - o * l, v = t * d + i * p + r * m; if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const y = 1 / v; return e[0] = d * y, e[1] = (r * u - h * i) * y, e[2] = (a * i - r * o) * y, e[3] = p * y, e[4] = (h * t - r * l) * y, e[5] = (r * s - a * t) * y, e[6] = m * y, e[7] = (i * l - u * t) * y, e[8] = (o * t - i * s) * y, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, r, s, o, a) { const l = Math.cos(s), u = Math.sin(s); return this.set(i * l, i * u, -i * (l * o + u * a) + o + e, -r * u, r * l, -r * (-u * o + l * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(F1.makeScale(e, t)), this } rotate(e) { return this.premultiply(F1.makeRotation(-e)), this } translate(e, t) { return this.premultiply(F1.makeTranslation(e, t)), this } makeTranslation(e, t) { return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, i = e.elements; for (let r = 0; r < 9; r++)if (t[r] !== i[r]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const F1 = new Vn; function U5(n) { for (let e = n.length - 1; e >= 0; --e)if (n[e] >= 65535) return !0; return !1 } const wL = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function lc(n, e) { return new wL[n](e) } function Qf(n) { return document.createElementNS("http://www.w3.org/1999/xhtml", n) } class jn { constructor(e = 0, t = 0, i = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r } static slerpFlat(e, t, i, r, s, o, a) { let l = i[r + 0], u = i[r + 1], h = i[r + 2], d = i[r + 3]; const p = s[o + 0], m = s[o + 1], v = s[o + 2], y = s[o + 3]; if (a === 0) { e[t + 0] = l, e[t + 1] = u, e[t + 2] = h, e[t + 3] = d; return } if (a === 1) { e[t + 0] = p, e[t + 1] = m, e[t + 2] = v, e[t + 3] = y; return } if (d !== y || l !== p || u !== m || h !== v) { let x = 1 - a; const A = l * p + u * m + h * v + d * y, _ = A >= 0 ? 1 : -1, M = 1 - A * A; if (M > Number.EPSILON) { const b = Math.sqrt(M), B = Math.atan2(b, A * _); x = Math.sin(x * B) / b, a = Math.sin(a * B) / b } const S = a * _; if (l = l * x + p * S, u = u * x + m * S, h = h * x + v * S, d = d * x + y * S, x === 1 - a) { const b = 1 / Math.sqrt(l * l + u * u + h * h + d * d); l *= b, u *= b, h *= b, d *= b } } e[t] = l, e[t + 1] = u, e[t + 2] = h, e[t + 3] = d } static multiplyQuaternionsFlat(e, t, i, r, s, o) { const a = i[r], l = i[r + 1], u = i[r + 2], h = i[r + 3], d = s[o], p = s[o + 1], m = s[o + 2], v = s[o + 3]; return e[t] = a * v + h * d + l * m - u * p, e[t + 1] = l * v + h * p + u * d - a * m, e[t + 2] = u * v + h * m + a * p - l * d, e[t + 3] = h * v - a * d - l * p - u * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, u = a(i / 2), h = a(r / 2), d = a(s / 2), p = l(i / 2), m = l(r / 2), v = l(s / 2); switch (o) { case "XYZ": this._x = p * h * d + u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d - p * m * v; break; case "YXZ": this._x = p * h * d + u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d + p * m * v; break; case "ZXY": this._x = p * h * d - u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d - p * m * v; break; case "ZYX": this._x = p * h * d - u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d + p * m * v; break; case "YZX": this._x = p * h * d + u * m * v, this._y = u * m * d + p * h * v, this._z = u * h * v - p * m * d, this._w = u * h * d - p * m * v; break; case "XZY": this._x = p * h * d - u * m * v, this._y = u * m * d - p * h * v, this._z = u * h * v + p * m * d, this._w = u * h * d + p * m * v; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const i = t / 2, r = Math.sin(i); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], u = t[2], h = t[6], d = t[10], p = i + a + d; if (p > 0) { const m = .5 / Math.sqrt(p + 1); this._w = .25 / m, this._x = (h - l) * m, this._y = (s - u) * m, this._z = (o - r) * m } else if (i > a && i > d) { const m = 2 * Math.sqrt(1 + i - a - d); this._w = (h - l) / m, this._x = .25 * m, this._y = (r + o) / m, this._z = (s + u) / m } else if (a > d) { const m = 2 * Math.sqrt(1 + a - i - d); this._w = (s - u) / m, this._x = (r + o) / m, this._y = .25 * m, this._z = (l + h) / m } else { const m = 2 * Math.sqrt(1 + d - i - a); this._w = (o - r) / m, this._x = (s + u) / m, this._y = (l + h) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(xn(this.dot(e), -1, 1))) } rotateTowards(e, t) { const i = this.angleTo(e); if (i === 0) return this; const r = Math.min(1, t / i); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, u = t._z, h = t._w; return this._x = i * h + o * a + r * u - s * l, this._y = r * h + o * l + s * a - i * u, this._z = s * h + o * u + i * l - r * a, this._w = o * h - i * a - r * l - s * u, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const i = this._x, r = this._y, s = this._z, o = this._w; let a = o * e._w + i * e._x + r * e._y + s * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this; const l = 1 - a * a; if (l <= Number.EPSILON) { const m = 1 - t; return this._w = m * o + t * this._w, this._x = m * i + t * this._x, this._y = m * r + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this } const u = Math.sqrt(l), h = Math.atan2(u, a), d = Math.sin((1 - t) * h) / u, p = Math.sin(t * h) / u; return this._w = o * d + this._w * p, this._x = i * d + this._x * p, this._y = r * d + this._y * p, this._z = s * d + this._z * p, this._onChangeCallback(), this } slerpQuaternions(e, t, i) { return this.copy(e).slerp(t, i) } random() { const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class D { constructor(e = 0, t = 0, i = 0) { D.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i } set(e, t, i) { return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(yw.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(yw.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, i = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]); return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this } applyQuaternion(e) { const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, u = l * t + o * r - a * i, h = l * i + a * t - s * r, d = l * r + s * i - o * t, p = -s * t - o * i - a * r; return this.x = u * l + p * -s + h * -a - d * -o, this.y = h * l + p * -o + d * -s - u * -a, this.z = d * l + p * -a + u * -o - h * -s, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, i = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z; return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const i = e.dot(this) / t; return this.copy(e).multiplyScalar(i) } projectOnPlane(e) { return k1.copy(this).projectOnVector(e), this.sub(k1) } reflect(e) { return this.sub(k1.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const i = this.dot(e) / t; return Math.acos(xn(i, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z; return t * t + i * i + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { const r = Math.sin(t) * e; return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2); return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const k1 = new D, yw = new jn; function _c(n) { return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4) } function N1(n) { return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055 } const SL = new Vn().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]), CL = new Vn().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]), Eo = new D; function EL(n) { return n.convertSRGBToLinear(), Eo.set(n.r, n.g, n.b).applyMatrix3(CL), n.setRGB(Eo.x, Eo.y, Eo.z) } function bL(n) { return Eo.set(n.r, n.g, n.b).applyMatrix3(SL), n.setRGB(Eo.x, Eo.y, Eo.z).convertLinearToSRGB() } const TL = { [Fc]: n => n, [Br]: n => n.convertSRGBToLinear(), [$x]: EL }, BL = { [Fc]: n => n, [Br]: n => n.convertLinearToSRGB(), [$x]: bL }, ni = { enabled: !1, get legacyMode() { return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled }, set legacyMode(n) { console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n }, get workingColorSpace() { return Fc }, set workingColorSpace(n) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (n, e, t) { if (this.enabled === !1 || e === t || !e || !t) return n; const i = TL[e], r = BL[t]; if (i === void 0 || r === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`); return r(i(n)) }, fromWorkingColorSpace: function (n, e) { return this.convert(n, this.workingColorSpace, e) }, toWorkingColorSpace: function (n, e) { return this.convert(n, e, this.workingColorSpace) } }; let Bl; class nA { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { Bl === void 0 && (Bl = Qf("canvas")), Bl.width = e.width, Bl.height = e.height; const i = Bl.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Bl } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = Qf("canvas"); t.width = e.width, t.height = e.height; const i = t.getContext("2d"); i.drawImage(e, 0, 0, e.width, e.height); const r = i.getImageData(0, 0, e.width, e.height), s = r.data; for (let o = 0; o < s.length; o++)s[o] = _c(s[o] / 255) * 255; return i.putImageData(r, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let i = 0; i < t.length; i++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(_c(t[i] / 255) * 255) : t[i] = _c(t[i]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } class Ua { constructor(e = null) { this.isSource = !0, this.uuid = Vi(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const i = { uuid: this.uuid, url: "" }, r = this.data; if (r !== null) { let s; if (Array.isArray(r)) { s = []; for (let o = 0, a = r.length; o < a; o++)r[o].isDataTexture ? s.push(O1(r[o].image)) : s.push(O1(r[o])) } else s = O1(r); i.url = s } return t || (e.images[this.uuid] = i), i } } function O1(n) { return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? nA.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let PL = 0; class Zt extends us { constructor(e = Zt.DEFAULT_IMAGE, t = Zt.DEFAULT_MAPPING, i = Hn, r = Hn, s = tn, o = ls, a = Si, l = js, u = Zt.DEFAULT_ANISOTROPY, h = Js) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: PL++ }), this.uuid = Vi(), this.name = "", this.source = new Ua(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = l, this.offset = new me(0, 0), this.repeat = new me(1, 1), this.center = new me(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Vn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== E0) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Wo: e.x = e.x - Math.floor(e.x); break; case Hn: e.x = e.x < 0 ? 0 : 1; break; case Lc: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Wo: e.y = e.y - Math.floor(e.y); break; case Hn: e.y = e.y < 0 ? 0 : 1; break; case Lc: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } } Zt.DEFAULT_IMAGE = null; Zt.DEFAULT_MAPPING = E0; Zt.DEFAULT_ANISOTROPY = 1; class Ft { constructor(e = 0, t = 0, i = 0, r = 1) { Ft.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, r) { return this.x = e, this.y = t, this.z = i, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements; return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, r, s; const l = e.elements, u = l[0], h = l[4], d = l[8], p = l[1], m = l[5], v = l[9], y = l[2], x = l[6], A = l[10]; if (Math.abs(h - p) < .01 && Math.abs(d - y) < .01 && Math.abs(v - x) < .01) { if (Math.abs(h + p) < .1 && Math.abs(d + y) < .1 && Math.abs(v + x) < .1 && Math.abs(u + m + A - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const M = (u + 1) / 2, S = (m + 1) / 2, b = (A + 1) / 2, B = (h + p) / 4, R = (d + y) / 4, E = (v + x) / 4; return M > S && M > b ? M < .01 ? (i = 0, r = .707106781, s = .707106781) : (i = Math.sqrt(M), r = B / i, s = R / i) : S > b ? S < .01 ? (i = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(S), i = B / r, s = E / r) : b < .01 ? (i = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(b), i = R / s, r = E / s), this.set(i, r, s, t), this } let _ = Math.sqrt((x - v) * (x - v) + (d - y) * (d - y) + (p - h) * (p - h)); return Math.abs(_) < .001 && (_ = 1), this.x = (x - v) / _, this.y = (d - y) / _, this.z = (p - h) / _, this.w = Math.acos((u + m + A - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class Or extends us { constructor(e = 1, t = 1, i = {}) { super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Ft(0, 0, e, t), this.scissorTest = !1, this.viewport = new Ft(0, 0, e, t); const r = { width: e, height: t, depth: 1 }; this.texture = new Zt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : tn, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0 } setSize(e, t, i = 1) { (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Ua(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class B0 extends Zt { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = pn, this.minFilter = pn, this.wrapR = Hn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class RL extends Or { constructor(e = 1, t = 1, i = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new B0(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class iA extends Zt { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = pn, this.minFilter = pn, this.wrapR = Hn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class LL extends Or { constructor(e = 1, t = 1, i = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new iA(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class IL extends Or { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isWebGLMultipleRenderTargets = !0; const s = this.texture; this.texture = []; for (let o = 0; o < i; o++)this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0 } setSize(e, t, i = 1) { if (this.width !== e || this.height !== t || this.depth !== i) { this.width = e, this.height = t, this.depth = i; for (let r = 0, s = this.texture.length; r < s; r++)this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, i = e.texture.length; t < i; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class Zo { constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, u = e.length; l < u; l += 3) { const h = e[l], d = e[l + 1], p = e[l + 2]; h < t && (t = h), d < i && (i = d), p < r && (r = p), h > s && (s = h), d > o && (o = d), p > a && (a = p) } return this.min.set(t, i, r), this.max.set(s, o, a), this } setFromBufferAttribute(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, u = e.count; l < u; l++) { const h = e.getX(l), d = e.getY(l), p = e.getZ(l); h < t && (t = h), d < i && (i = d), p < r && (r = p), h > s && (s = h), d > o && (o = d), p > a && (a = p) } return this.min.set(t, i, r), this.max.set(s, o, a), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = da.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const i = e.geometry; if (i !== void 0) if (t && i.attributes != null && i.attributes.position !== void 0) { const s = i.attributes.position; for (let o = 0, a = s.count; o < a; o++)da.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(da) } else i.boundingBox === null && i.computeBoundingBox(), z1.copy(i.boundingBox), z1.applyMatrix4(e.matrixWorld), this.union(z1); const r = e.children; for (let s = 0, o = r.length; s < o; s++)this.expandByObject(r[s], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, da), da.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Pu), $d.subVectors(this.max, Pu), Pl.subVectors(e.a, Pu), Rl.subVectors(e.b, Pu), Ll.subVectors(e.c, Pu), ao.subVectors(Rl, Pl), lo.subVectors(Ll, Rl), pa.subVectors(Pl, Ll); let t = [0, -ao.z, ao.y, 0, -lo.z, lo.y, 0, -pa.z, pa.y, ao.z, 0, -ao.x, lo.z, 0, -lo.x, pa.z, 0, -pa.x, -ao.y, ao.x, 0, -lo.y, lo.x, 0, -pa.y, pa.x, 0]; return !U1(t, Pl, Rl, Ll, $d) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !U1(t, Pl, Rl, Ll, $d)) ? !1 : (ep.crossVectors(ao, lo), t = [ep.x, ep.y, ep.z], U1(t, Pl, Rl, Ll, $d)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, da).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(da).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(As), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const As = [new D, new D, new D, new D, new D, new D, new D, new D], da = new D, z1 = new Zo, Pl = new D, Rl = new D, Ll = new D, ao = new D, lo = new D, pa = new D, Pu = new D, $d = new D, ep = new D, ma = new D; function U1(n, e, t, i, r) { for (let s = 0, o = n.length - 3; s <= o; s += 3) { ma.fromArray(n, s); const a = r.x * Math.abs(ma.x) + r.y * Math.abs(ma.y) + r.z * Math.abs(ma.z), l = e.dot(ma), u = t.dot(ma), h = i.dot(ma); if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > a) return !1 } return !0 } const DL = new Zo, Ru = new D, G1 = new D; class $o { constructor(e = new D, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const i = this.center; t !== void 0 ? i.copy(t) : DL.setFromPoints(e).getCenter(i); let r = 0; for (let s = 0, o = e.length; s < o; s++)r = Math.max(r, i.distanceToSquared(e[s])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const i = this.center.distanceToSquared(e); return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Ru.subVectors(e, this.center); const t = Ru.lengthSq(); if (t > this.radius * this.radius) { const i = Math.sqrt(t), r = (i - this.radius) * .5; this.center.addScaledVector(Ru, r / i), this.radius += r } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (G1.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ru.copy(e.center).add(G1)), this.expandByPoint(Ru.copy(e.center).sub(G1))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const Ms = new D, H1 = new D, tp = new D, co = new D, V1 = new D, np = new D, W1 = new D; class mh { constructor(e = new D, t = new D(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Ms)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Ms.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Ms.copy(this.origin).addScaledVector(this.direction, t), Ms.distanceToSquared(e)) } distanceSqToSegment(e, t, i, r) { H1.copy(e).add(t).multiplyScalar(.5), tp.copy(t).sub(e).normalize(), co.copy(this.origin).sub(H1); const s = e.distanceTo(t) * .5, o = -this.direction.dot(tp), a = co.dot(this.direction), l = -co.dot(tp), u = co.lengthSq(), h = Math.abs(1 - o * o); let d, p, m, v; if (h > 0) if (d = o * l - a, p = o * a - l, v = s * h, d >= 0) if (p >= -v) if (p <= v) { const y = 1 / h; d *= y, p *= y, m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u } else p = s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u; else p = -s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u; else p <= -v ? (d = Math.max(0, -(-o * s + a)), p = d > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + u) : p <= v ? (d = 0, p = Math.min(Math.max(-s, -l), s), m = p * (p + 2 * l) + u) : (d = Math.max(0, -(o * s + a)), p = d > 0 ? s : Math.min(Math.max(-s, -l), s), m = -d * d + p * (p + 2 * l) + u); else p = o > 0 ? -s : s, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + u; return i && i.copy(this.origin).addScaledVector(this.direction, d), r && r.copy(H1).addScaledVector(tp, p), m } intersectSphere(e, t) { Ms.subVectors(e.center, this.origin); const i = Ms.dot(this.direction), r = Ms.dot(Ms) - i * i, s = e.radius * e.radius; if (r > s) return null; const o = Math.sqrt(s - r), a = i - o, l = i + o; return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null } intersectPlane(e, t) { const i = this.distanceToPlane(e); return i === null ? null : this.at(i, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let i, r, s, o, a, l; const u = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin; return u >= 0 ? (i = (e.min.x - p.x) * u, r = (e.max.x - p.x) * u) : (i = (e.max.x - p.x) * u, r = (e.min.x - p.x) * u), h >= 0 ? (s = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (s = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t) } intersectsBox(e) { return this.intersectBox(e, Ms) !== null } intersectTriangle(e, t, i, r, s) { V1.subVectors(t, e), np.subVectors(i, e), W1.crossVectors(V1, np); let o = this.direction.dot(W1), a; if (o > 0) { if (r) return null; a = 1 } else if (o < 0) a = -1, o = -o; else return null; co.subVectors(this.origin, e); const l = a * this.direction.dot(np.crossVectors(co, np)); if (l < 0) return null; const u = a * this.direction.dot(V1.cross(co)); if (u < 0 || l + u > o) return null; const h = -a * co.dot(W1); return h < 0 ? null : this.at(h / o, s) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class st { constructor() { st.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set(e, t, i, r, s, o, a, l, u, h, d, p, m, v, y, x) { const A = this.elements; return A[0] = e, A[4] = t, A[8] = i, A[12] = r, A[1] = s, A[5] = o, A[9] = a, A[13] = l, A[2] = u, A[6] = h, A[10] = d, A[14] = p, A[3] = m, A[7] = v, A[11] = y, A[15] = x, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new st().fromArray(this.elements) } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { const t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, i = e.elements, r = 1 / Il.setFromMatrixColumn(e, 0).length(), s = 1 / Il.setFromMatrixColumn(e, 1).length(), o = 1 / Il.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(r), u = Math.sin(r), h = Math.cos(s), d = Math.sin(s); if (e.order === "XYZ") { const p = o * h, m = o * d, v = a * h, y = a * d; t[0] = l * h, t[4] = -l * d, t[8] = u, t[1] = m + v * u, t[5] = p - y * u, t[9] = -a * l, t[2] = y - p * u, t[6] = v + m * u, t[10] = o * l } else if (e.order === "YXZ") { const p = l * h, m = l * d, v = u * h, y = u * d; t[0] = p + y * a, t[4] = v * a - m, t[8] = o * u, t[1] = o * d, t[5] = o * h, t[9] = -a, t[2] = m * a - v, t[6] = y + p * a, t[10] = o * l } else if (e.order === "ZXY") { const p = l * h, m = l * d, v = u * h, y = u * d; t[0] = p - y * a, t[4] = -o * d, t[8] = v + m * a, t[1] = m + v * a, t[5] = o * h, t[9] = y - p * a, t[2] = -o * u, t[6] = a, t[10] = o * l } else if (e.order === "ZYX") { const p = o * h, m = o * d, v = a * h, y = a * d; t[0] = l * h, t[4] = v * u - m, t[8] = p * u + y, t[1] = l * d, t[5] = y * u + p, t[9] = m * u - v, t[2] = -u, t[6] = a * l, t[10] = o * l } else if (e.order === "YZX") { const p = o * l, m = o * u, v = a * l, y = a * u; t[0] = l * h, t[4] = y - p * d, t[8] = v * d + m, t[1] = d, t[5] = o * h, t[9] = -a * h, t[2] = -u * h, t[6] = m * d + v, t[10] = p - y * d } else if (e.order === "XZY") { const p = o * l, m = o * u, v = a * l, y = a * u; t[0] = l * h, t[4] = -d, t[8] = u * h, t[1] = p * d + y, t[5] = o * h, t[9] = m * d - v, t[2] = v * d - m, t[6] = a * h, t[10] = y * d + p } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(FL, e, kL) } lookAt(e, t, i) { const r = this.elements; return ki.subVectors(e, t), ki.lengthSq() === 0 && (ki.z = 1), ki.normalize(), uo.crossVectors(i, ki), uo.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ki.x += 1e-4 : ki.z += 1e-4, ki.normalize(), uo.crossVectors(i, ki)), uo.normalize(), ip.crossVectors(ki, uo), r[0] = uo.x, r[4] = ip.x, r[8] = ki.x, r[1] = uo.y, r[5] = ip.y, r[9] = ki.y, r[2] = uo.z, r[6] = ip.z, r[10] = ki.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], l = i[8], u = i[12], h = i[1], d = i[5], p = i[9], m = i[13], v = i[2], y = i[6], x = i[10], A = i[14], _ = i[3], M = i[7], S = i[11], b = i[15], B = r[0], R = r[4], E = r[8], P = r[12], L = r[1], z = r[5], Z = r[9], J = r[13], V = r[2], K = r[6], ee = r[10], le = r[14], N = r[3], H = r[7], W = r[11], se = r[15]; return s[0] = o * B + a * L + l * V + u * N, s[4] = o * R + a * z + l * K + u * H, s[8] = o * E + a * Z + l * ee + u * W, s[12] = o * P + a * J + l * le + u * se, s[1] = h * B + d * L + p * V + m * N, s[5] = h * R + d * z + p * K + m * H, s[9] = h * E + d * Z + p * ee + m * W, s[13] = h * P + d * J + p * le + m * se, s[2] = v * B + y * L + x * V + A * N, s[6] = v * R + y * z + x * K + A * H, s[10] = v * E + y * Z + x * ee + A * W, s[14] = v * P + y * J + x * le + A * se, s[3] = _ * B + M * L + S * V + b * N, s[7] = _ * R + M * z + S * K + b * H, s[11] = _ * E + M * Z + S * ee + b * W, s[15] = _ * P + M * J + S * le + b * se, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], u = e[13], h = e[2], d = e[6], p = e[10], m = e[14], v = e[3], y = e[7], x = e[11], A = e[15]; return v * (+s * l * d - r * u * d - s * a * p + i * u * p + r * a * m - i * l * m) + y * (+t * l * m - t * u * p + s * o * p - r * o * m + r * u * h - s * l * h) + x * (+t * u * d - t * a * m - s * o * d + i * o * m + s * a * h - i * u * h) + A * (-r * a * h - t * l * d + t * a * p + r * o * d - i * o * p + i * l * h) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, i) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], h = e[8], d = e[9], p = e[10], m = e[11], v = e[12], y = e[13], x = e[14], A = e[15], _ = d * x * u - y * p * u + y * l * m - a * x * m - d * l * A + a * p * A, M = v * p * u - h * x * u - v * l * m + o * x * m + h * l * A - o * p * A, S = h * y * u - v * d * u + v * a * m - o * y * m - h * a * A + o * d * A, b = v * d * l - h * y * l - v * a * p + o * y * p + h * a * x - o * d * x, B = t * _ + i * M + r * S + s * b; if (B === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const R = 1 / B; return e[0] = _ * R, e[1] = (y * p * s - d * x * s - y * r * m + i * x * m + d * r * A - i * p * A) * R, e[2] = (a * x * s - y * l * s + y * r * u - i * x * u - a * r * A + i * l * A) * R, e[3] = (d * l * s - a * p * s - d * r * u + i * p * u + a * r * m - i * l * m) * R, e[4] = M * R, e[5] = (h * x * s - v * p * s + v * r * m - t * x * m - h * r * A + t * p * A) * R, e[6] = (v * l * s - o * x * s - v * r * u + t * x * u + o * r * A - t * l * A) * R, e[7] = (o * p * s - h * l * s + h * r * u - t * p * u - o * r * m + t * l * m) * R, e[8] = S * R, e[9] = (v * d * s - h * y * s - v * i * m + t * y * m + h * i * A - t * d * A) * R, e[10] = (o * y * s - v * a * s + v * i * u - t * y * u - o * i * A + t * a * A) * R, e[11] = (h * a * s - o * d * s - h * i * u + t * d * u + o * i * m - t * a * m) * R, e[12] = b * R, e[13] = (h * y * r - v * d * r + v * i * p - t * y * p - h * i * x + t * d * x) * R, e[14] = (v * a * r - o * y * r - v * i * l + t * y * l + o * i * x - t * a * x) * R, e[15] = (o * d * r - h * a * r + h * i * l - t * d * l - o * i * p + t * a * p) * R, this } scale(e) { const t = this.elements, i = e.x, r = e.y, s = e.z; return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, r)) } makeTranslation(e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, l = e.z, u = s * o, h = s * a; return this.set(u * o + i, u * a - r * l, u * l + r * a, 0, u * a + r * l, h * a + i, h * l - r * o, 0, u * l - r * a, h * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i, r, s, o) { return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, u = s + s, h = o + o, d = a + a, p = s * u, m = s * h, v = s * d, y = o * h, x = o * d, A = a * d, _ = l * u, M = l * h, S = l * d, b = i.x, B = i.y, R = i.z; return r[0] = (1 - (y + A)) * b, r[1] = (m + S) * b, r[2] = (v - M) * b, r[3] = 0, r[4] = (m - S) * B, r[5] = (1 - (p + A)) * B, r[6] = (x + _) * B, r[7] = 0, r[8] = (v + M) * R, r[9] = (x - _) * R, r[10] = (1 - (p + y)) * R, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, i) { const r = this.elements; let s = Il.set(r[0], r[1], r[2]).length(); const o = Il.set(r[4], r[5], r[6]).length(), a = Il.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Sr.copy(this); const u = 1 / s, h = 1 / o, d = 1 / a; return Sr.elements[0] *= u, Sr.elements[1] *= u, Sr.elements[2] *= u, Sr.elements[4] *= h, Sr.elements[5] *= h, Sr.elements[6] *= h, Sr.elements[8] *= d, Sr.elements[9] *= d, Sr.elements[10] *= d, t.setFromRotationMatrix(Sr), i.x = s, i.y = o, i.z = a, this } makePerspective(e, t, i, r, s, o) { const a = this.elements, l = 2 * s / (t - e), u = 2 * s / (i - r), h = (t + e) / (t - e), d = (i + r) / (i - r), p = -(o + s) / (o - s), m = -2 * o * s / (o - s); return a[0] = l, a[4] = 0, a[8] = h, a[12] = 0, a[1] = 0, a[5] = u, a[9] = d, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = p, a[14] = m, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic(e, t, i, r, s, o) { const a = this.elements, l = 1 / (t - e), u = 1 / (i - r), h = 1 / (o - s), d = (t + e) * l, p = (i + r) * u, m = (o + s) * h; return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -d, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -p, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -m, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals(e) { const t = this.elements, i = e.elements; for (let r = 0; r < 16; r++)if (t[r] !== i[r]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } const Il = new D, Sr = new st, FL = new D(0, 0, 0), kL = new D(1, 1, 1), uo = new D, ip = new D, ki = new D, vw = new st, xw = new jn; class ll { constructor(e = 0, t = 0, i = 0, r = ll.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, r = this._order) { return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, i = !0) { const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], u = r[5], h = r[9], d = r[2], p = r[6], m = r[10]; switch (t) { case "XYZ": this._y = Math.asin(xn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, u), this._z = 0); break; case "YXZ": this._x = Math.asin(-xn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-d, s), this._z = 0); break; case "ZXY": this._x = Math.asin(xn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, s)); break; case "ZYX": this._y = Math.asin(-xn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, u)); break; case "YZX": this._z = Math.asin(xn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, m)); break; case "XZY": this._z = Math.asin(-xn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, i === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return vw.makeRotationFromQuaternion(e), this.setFromRotationMatrix(vw, t, i) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return xw.setFromEuler(this), this.setFromQuaternion(xw, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } ll.DEFAULT_ORDER = "XYZ"; class Ka { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let NL = 0; const Aw = new D, Dl = new jn, _s = new st, rp = new D, Lu = new D, OL = new D, zL = new jn, Mw = new D(1, 0, 0), _w = new D(0, 1, 0), ww = new D(0, 0, 1), UL = { type: "added" }, Sw = { type: "removed" }; class bt extends us { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: NL++ }), this.uuid = Vi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = bt.DEFAULT_UP.clone(); const e = new D, t = new ll, i = new jn, r = new D(1, 1, 1); function s() { i.setFromEuler(t, !1) } function o() { t.setFromQuaternion(i, void 0, !1) } t._onChange(s), i._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new st }, normalMatrix: { value: new Vn } }), this.matrix = new st, this.matrixWorld = new st, this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Ka, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Dl.setFromAxisAngle(e, t), this.quaternion.multiply(Dl), this } rotateOnWorldAxis(e, t) { return Dl.setFromAxisAngle(e, t), this.quaternion.premultiply(Dl), this } rotateX(e) { return this.rotateOnAxis(Mw, e) } rotateY(e) { return this.rotateOnAxis(_w, e) } rotateZ(e) { return this.rotateOnAxis(ww, e) } translateOnAxis(e, t) { return Aw.copy(e).applyQuaternion(this.quaternion), this.position.add(Aw.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Mw, e) } translateY(e) { return this.translateOnAxis(_w, e) } translateZ(e) { return this.translateOnAxis(ww, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(_s.copy(this.matrixWorld).invert()) } lookAt(e, t, i) { e.isVector3 ? rp.copy(e) : rp.set(e, t, i); const r = this.parent; this.updateWorldMatrix(!0, !1), Lu.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _s.lookAt(Lu, rp, this.up) : _s.lookAt(rp, Lu, this.up), this.quaternion.setFromRotationMatrix(_s), r && (_s.extractRotation(r.matrixWorld), Dl.setFromRotationMatrix(_s), this.quaternion.premultiply(Dl.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(UL)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let i = 0; i < arguments.length; i++)this.remove(arguments[i]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Sw)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Sw) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), _s.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), _s.multiply(e.parent.matrixWorld)), e.applyMatrix4(_s), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let i = 0, r = this.children.length; i < r; i++) { const o = this.children[i].getObjectByProperty(e, t); if (o !== void 0) return o } } getObjectsByProperty(e, t) { let i = []; this[e] === t && i.push(this); for (let r = 0, s = this.children.length; r < s; r++) { const o = this.children[r].getObjectsByProperty(e, t); o.length > 0 && (i = i.concat(o)) } return i } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Lu, e, OL), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Lu, zL, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const i = this.parent; if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const r = this.children; for (let s = 0, o = r.length; s < o; s++) { const a = r[s]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())); function s(a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = s(e.geometries, this.geometry); const a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { const l = a.shapes; if (Array.isArray(l)) for (let u = 0, h = l.length; u < h; u++) { const d = l[u]; s(e.shapes, d) } else s(e.shapes, l) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const a = []; for (let l = 0, u = this.material.length; l < u; l++)a.push(s(e.materials, this.material[l])); r.material = a } else r.material = s(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let a = 0; a < this.animations.length; a++) { const l = this.animations[a]; r.animations.push(s(e.animations, l)) } } if (t) { const a = o(e.geometries), l = o(e.materials), u = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), m = o(e.animations), v = o(e.nodes); a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), u.length > 0 && (i.textures = u), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), p.length > 0 && (i.skeletons = p), m.length > 0 && (i.animations = m), v.length > 0 && (i.nodes = v) } return i.object = r, i; function o(a) { const l = []; for (const u in a) { const h = a[u]; delete h.metadata, l.push(h) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let i = 0; i < e.children.length; i++) { const r = e.children[i]; this.add(r.clone()) } return this } } bt.DEFAULT_UP = new D(0, 1, 0); bt.DEFAULT_MATRIX_AUTO_UPDATE = !0; bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const Cr = new D, ws = new D, j1 = new D, Ss = new D, Fl = new D, kl = new D, Cw = new D, J1 = new D, X1 = new D, Q1 = new D; class fr { constructor(e = new D, t = new D, i = new D) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, r) { r.subVectors(i, t), Cr.subVectors(e, t), r.cross(Cr); const s = r.lengthSq(); return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0) } static getBarycoord(e, t, i, r, s) { Cr.subVectors(r, t), ws.subVectors(i, t), j1.subVectors(e, t); const o = Cr.dot(Cr), a = Cr.dot(ws), l = Cr.dot(j1), u = ws.dot(ws), h = ws.dot(j1), d = o * u - a * a; if (d === 0) return s.set(-2, -1, -1); const p = 1 / d, m = (u * l - a * h) * p, v = (o * h - a * l) * p; return s.set(1 - m - v, v, m) } static containsPoint(e, t, i, r) { return this.getBarycoord(e, t, i, r, Ss), Ss.x >= 0 && Ss.y >= 0 && Ss.x + Ss.y <= 1 } static getUV(e, t, i, r, s, o, a, l) { return this.getBarycoord(e, t, i, r, Ss), l.set(0, 0), l.addScaledVector(s, Ss.x), l.addScaledVector(o, Ss.y), l.addScaledVector(a, Ss.z), l } static isFrontFacing(e, t, i, r) { return Cr.subVectors(i, t), ws.subVectors(e, t), Cr.cross(ws).dot(r) < 0 } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, r) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, i, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Cr.subVectors(this.c, this.b), ws.subVectors(this.a, this.b), Cr.cross(ws).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return fr.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return fr.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, i, r, s) { return fr.getUV(e, this.a, this.b, this.c, t, i, r, s) } containsPoint(e) { return fr.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return fr.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const i = this.a, r = this.b, s = this.c; let o, a; Fl.subVectors(r, i), kl.subVectors(s, i), J1.subVectors(e, i); const l = Fl.dot(J1), u = kl.dot(J1); if (l <= 0 && u <= 0) return t.copy(i); X1.subVectors(e, r); const h = Fl.dot(X1), d = kl.dot(X1); if (h >= 0 && d <= h) return t.copy(r); const p = l * d - h * u; if (p <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(i).addScaledVector(Fl, o); Q1.subVectors(e, s); const m = Fl.dot(Q1), v = kl.dot(Q1); if (v >= 0 && m <= v) return t.copy(s); const y = m * u - l * v; if (y <= 0 && u >= 0 && v <= 0) return a = u / (u - v), t.copy(i).addScaledVector(kl, a); const x = h * v - m * d; if (x <= 0 && d - h >= 0 && m - v >= 0) return Cw.subVectors(s, r), a = (d - h) / (d - h + (m - v)), t.copy(r).addScaledVector(Cw, a); const A = 1 / (x + y + p); return o = y * A, a = p * A, t.copy(i).addScaledVector(Fl, o).addScaledVector(kl, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let GL = 0; class En extends us { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: GL++ }), this.uuid = Vi(), this.name = "", this.type = "Material", this.blending = ja, this.side = as, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Xx, this.blendDst = Qx, this.blendEquation = Ra, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Hm, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = N5, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = fm, this.stencilZFail = fm, this.stencilZPass = fm, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const i = e[t]; if (i === void 0) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } const r = this[t]; if (r === void 0) { console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material."); continue } r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ja && (i.blending = this.blending), this.side !== as && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData); function r(s) { const o = []; for (const a in s) { const l = s[a]; delete l.metadata, o.push(l) } return o } if (t) { const s = r(e.textures), o = r(e.images); s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o) } return i } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let i = null; if (t !== null) { const r = t.length; i = new Array(r); for (let s = 0; s !== r; ++s)i[s] = t[s].clone() } return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } const G5 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Er = { h: 0, s: 0, l: 0 }, sp = { h: 0, s: 0, l: 0 }; function K1(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n } class Re { constructor(e, t, i) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i) } set(e) { return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = Br) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ni.toWorkingColorSpace(this, t), this } setRGB(e, t, i, r = ni.workingColorSpace) { return this.r = e, this.g = t, this.b = i, ni.toWorkingColorSpace(this, r), this } setHSL(e, t, i, r = ni.workingColorSpace) { if (e = eA(e, 1), t = xn(t, 0, 1), i = xn(i, 0, 1), t === 0) this.r = this.g = this.b = i; else { const s = i <= .5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s; this.r = K1(o, s, e + 1 / 3), this.g = K1(o, s, e), this.b = K1(o, s, e - 1 / 3) } return ni.toWorkingColorSpace(this, r), this } setStyle(e, t = Br) { function i(s) { s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let r; if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) { let s; const o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, ni.toWorkingColorSpace(this, t), i(s[4]), this; if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, ni.toWorkingColorSpace(this, t), i(s[4]), this; break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const l = parseFloat(s[1]) / 360, u = parseFloat(s[2]) / 100, h = parseFloat(s[3]) / 100; return i(s[4]), this.setHSL(l, u, h, t) } break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) { const s = r[1], o = s.length; if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, ni.toWorkingColorSpace(this, t), this; if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, ni.toWorkingColorSpace(this, t), this; console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = Br) { const i = G5[e.toLowerCase()]; return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = _c(e.r), this.g = _c(e.g), this.b = _c(e.b), this } copyLinearToSRGB(e) { return this.r = N1(e.r), this.g = N1(e.g), this.b = N1(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = Br) { return ni.fromWorkingColorSpace(ti.copy(this), e), xn(ti.r * 255, 0, 255) << 16 ^ xn(ti.g * 255, 0, 255) << 8 ^ xn(ti.b * 255, 0, 255) << 0 } getHexString(e = Br) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = ni.workingColorSpace) { ni.fromWorkingColorSpace(ti.copy(this), t); const i = ti.r, r = ti.g, s = ti.b, o = Math.max(i, r, s), a = Math.min(i, r, s); let l, u; const h = (a + o) / 2; if (a === o) l = 0, u = 0; else { const d = o - a; switch (u = h <= .5 ? d / (o + a) : d / (2 - o - a), o) { case i: l = (r - s) / d + (r < s ? 6 : 0); break; case r: l = (s - i) / d + 2; break; case s: l = (i - r) / d + 4; break }l /= 6 } return e.h = l, e.s = u, e.l = h, e } getRGB(e, t = ni.workingColorSpace) { return ni.fromWorkingColorSpace(ti.copy(this), t), e.r = ti.r, e.g = ti.g, e.b = ti.b, e } getStyle(e = Br) { ni.fromWorkingColorSpace(ti.copy(this), e); const t = ti.r, i = ti.g, r = ti.b; return e !== Br ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${t * 255 | 0},${i * 255 | 0},${r * 255 | 0})` } offsetHSL(e, t, i) { return this.getHSL(Er), Er.h += e, Er.s += t, Er.l += i, this.setHSL(Er.h, Er.s, Er.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(Er), e.getHSL(sp); const i = pf(Er.h, sp.h, t), r = pf(Er.s, sp.s, t), s = pf(Er.l, sp.l, t); return this.setHSL(i, r, s), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const ti = new Re; Re.NAMES = G5; class Gi extends En { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Re(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ph, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const wn = new D, op = new me; class It { constructor(e, t, i = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Jf, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.itemSize, i *= t.itemSize; for (let r = 0, s = this.itemSize; r < s; r++)this.array[e + r] = t.array[i + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++)op.fromBufferAttribute(this, t), op.applyMatrix3(e), this.setXY(t, op.x, op.y); else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++)wn.fromBufferAttribute(this, t), wn.applyMatrix3(e), this.setXYZ(t, wn.x, wn.y, wn.z); return this } applyMatrix4(e) { for (let t = 0, i = this.count; t < i; t++)wn.fromBufferAttribute(this, t), wn.applyMatrix4(e), this.setXYZ(t, wn.x, wn.y, wn.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)wn.fromBufferAttribute(this, t), wn.applyNormalMatrix(e), this.setXYZ(t, wn.x, wn.y, wn.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)wn.fromBufferAttribute(this, t), wn.transformDirection(e), this.setXYZ(t, wn.x, wn.y, wn.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Ds(t, this.array)), t } setX(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Ds(t, this.array)), t } setY(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Ds(t, this.array)), t } setZ(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Ds(t, this.array)), t } setW(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, i) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this } setXYZW(e, t, i, r, s) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== Jf && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } copyColorsArray() { console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.") } copyVector2sArray() { console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.") } copyVector3sArray() { console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.") } copyVector4sArray() { console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.") } } class HL extends It { constructor(e, t, i) { super(new Int8Array(e), t, i) } } class VL extends It { constructor(e, t, i) { super(new Uint8Array(e), t, i) } } class WL extends It { constructor(e, t, i) { super(new Uint8ClampedArray(e), t, i) } } class jL extends It { constructor(e, t, i) { super(new Int16Array(e), t, i) } } class rA extends It { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } class JL extends It { constructor(e, t, i) { super(new Int32Array(e), t, i) } } class sA extends It { constructor(e, t, i) { super(new Uint32Array(e), t, i) } } class XL extends It { constructor(e, t, i) { super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0 } } class je extends It { constructor(e, t, i) { super(new Float32Array(e), t, i) } } class QL extends It { constructor(e, t, i) { super(new Float64Array(e), t, i) } } let KL = 0; const sr = new st, Y1 = new bt, Nl = new D, Ni = new Zo, Iu = new Zo, kn = new D; class ut extends us { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: KL++ }), this.uuid = Vi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (U5(e) ? sA : rA)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const i = this.attributes.normal; if (i !== void 0) { const s = new Vn().getNormalMatrix(e); i.applyNormalMatrix(s), i.needsUpdate = !0 } const r = this.attributes.tangent; return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return sr.makeRotationFromQuaternion(e), this.applyMatrix4(sr), this } rotateX(e) { return sr.makeRotationX(e), this.applyMatrix4(sr), this } rotateY(e) { return sr.makeRotationY(e), this.applyMatrix4(sr), this } rotateZ(e) { return sr.makeRotationZ(e), this.applyMatrix4(sr), this } translate(e, t, i) { return sr.makeTranslation(e, t, i), this.applyMatrix4(sr), this } scale(e, t, i) { return sr.makeScale(e, t, i), this.applyMatrix4(sr), this } lookAt(e) { return Y1.lookAt(e), Y1.updateMatrix(), this.applyMatrix4(Y1.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Nl).negate(), this.translate(Nl.x, Nl.y, Nl.z), this } setFromPoints(e) { const t = []; for (let i = 0, r = e.length; i < r; i++) { const s = e[i]; t.push(s.x, s.y, s.z || 0) } return this.setAttribute("position", new je(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Zo); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; Ni.setFromBufferAttribute(s), this.morphTargetsRelative ? (kn.addVectors(this.boundingBox.min, Ni.min), this.boundingBox.expandByPoint(kn), kn.addVectors(this.boundingBox.max, Ni.max), this.boundingBox.expandByPoint(kn)) : (this.boundingBox.expandByPoint(Ni.min), this.boundingBox.expandByPoint(Ni.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new $o); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new D, 1 / 0); return } if (e) { const i = this.boundingSphere.center; if (Ni.setFromBufferAttribute(e), t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s]; Iu.setFromBufferAttribute(a), this.morphTargetsRelative ? (kn.addVectors(Ni.min, Iu.min), Ni.expandByPoint(kn), kn.addVectors(Ni.max, Iu.max), Ni.expandByPoint(kn)) : (Ni.expandByPoint(Iu.min), Ni.expandByPoint(Iu.max)) } Ni.getCenter(i); let r = 0; for (let s = 0, o = e.count; s < o; s++)kn.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(kn)); if (t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s], l = this.morphTargetsRelative; for (let u = 0, h = a.count; u < h; u++)kn.fromBufferAttribute(a, u), l && (Nl.fromBufferAttribute(e, u), kn.add(Nl)), r = Math.max(r, i.distanceToSquared(kn)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new It(new Float32Array(4 * a), 4)); const l = this.getAttribute("tangent").array, u = [], h = []; for (let L = 0; L < a; L++)u[L] = new D, h[L] = new D; const d = new D, p = new D, m = new D, v = new me, y = new me, x = new me, A = new D, _ = new D; function M(L, z, Z) { d.fromArray(r, L * 3), p.fromArray(r, z * 3), m.fromArray(r, Z * 3), v.fromArray(o, L * 2), y.fromArray(o, z * 2), x.fromArray(o, Z * 2), p.sub(d), m.sub(d), y.sub(v), x.sub(v); const J = 1 / (y.x * x.y - x.x * y.y); isFinite(J) && (A.copy(p).multiplyScalar(x.y).addScaledVector(m, -y.y).multiplyScalar(J), _.copy(m).multiplyScalar(y.x).addScaledVector(p, -x.x).multiplyScalar(J), u[L].add(A), u[z].add(A), u[Z].add(A), h[L].add(_), h[z].add(_), h[Z].add(_)) } let S = this.groups; S.length === 0 && (S = [{ start: 0, count: i.length }]); for (let L = 0, z = S.length; L < z; ++L) { const Z = S[L], J = Z.start, V = Z.count; for (let K = J, ee = J + V; K < ee; K += 3)M(i[K + 0], i[K + 1], i[K + 2]) } const b = new D, B = new D, R = new D, E = new D; function P(L) { R.fromArray(s, L * 3), E.copy(R); const z = u[L]; b.copy(z), b.sub(R.multiplyScalar(R.dot(z))).normalize(), B.crossVectors(E, z); const J = B.dot(h[L]) < 0 ? -1 : 1; l[L * 4] = b.x, l[L * 4 + 1] = b.y, l[L * 4 + 2] = b.z, l[L * 4 + 3] = J } for (let L = 0, z = S.length; L < z; ++L) { const Z = S[L], J = Z.start, V = Z.count; for (let K = J, ee = J + V; K < ee; K += 3)P(i[K + 0]), P(i[K + 1]), P(i[K + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let i = this.getAttribute("normal"); if (i === void 0) i = new It(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i); else for (let p = 0, m = i.count; p < m; p++)i.setXYZ(p, 0, 0, 0); const r = new D, s = new D, o = new D, a = new D, l = new D, u = new D, h = new D, d = new D; if (e) for (let p = 0, m = e.count; p < m; p += 3) { const v = e.getX(p + 0), y = e.getX(p + 1), x = e.getX(p + 2); r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, y), o.fromBufferAttribute(t, x), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), a.fromBufferAttribute(i, v), l.fromBufferAttribute(i, y), u.fromBufferAttribute(i, x), a.add(h), l.add(h), u.add(h), i.setXYZ(v, a.x, a.y, a.z), i.setXYZ(y, l.x, l.y, l.z), i.setXYZ(x, u.x, u.y, u.z) } else for (let p = 0, m = t.count; p < m; p += 3)r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), i.setXYZ(p + 0, h.x, h.y, h.z), i.setXYZ(p + 1, h.x, h.y, h.z), i.setXYZ(p + 2, h.x, h.y, h.z); this.normalizeNormals(), i.needsUpdate = !0 } } merge() { return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, i = e.count; t < i; t++)kn.fromBufferAttribute(e, t), kn.normalize(), e.setXYZ(t, kn.x, kn.y, kn.z) } toNonIndexed() { function e(a, l) { const u = a.array, h = a.itemSize, d = a.normalized, p = new u.constructor(l.length * h); let m = 0, v = 0; for (let y = 0, x = l.length; y < x; y++) { a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * h; for (let A = 0; A < h; A++)p[v++] = u[m++] } return new It(p, h, d) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new ut, i = this.index.array, r = this.attributes; for (const a in r) { const l = r[a], u = e(l, i); t.setAttribute(a, u) } const s = this.morphAttributes; for (const a in s) { const l = [], u = s[a]; for (let h = 0, d = u.length; h < d; h++) { const p = u[h], m = e(p, i); l.push(m) } t.morphAttributes[a] = l } t.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let a = 0, l = o.length; a < l; a++) { const u = o[a]; t.addGroup(u.start, u.count, u.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const u in l) l[u] !== void 0 && (e[u] = l[u]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const i = this.attributes; for (const l in i) { const u = i[l]; e.data.attributes[l] = u.toJSON(e.data) } const r = {}; let s = !1; for (const l in this.morphAttributes) { const u = this.morphAttributes[l], h = []; for (let d = 0, p = u.length; d < p; d++) { const m = u[d]; h.push(m.toJSON(e.data)) } h.length > 0 && (r[l] = h, s = !0) } s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o))); const a = this.boundingSphere; return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const i = e.index; i !== null && this.setIndex(i.clone(t)); const r = e.attributes; for (const u in r) { const h = r[u]; this.setAttribute(u, h.clone(t)) } const s = e.morphAttributes; for (const u in s) { const h = [], d = s[u]; for (let p = 0, m = d.length; p < m; p++)h.push(d[p].clone(t)); this.morphAttributes[u] = h } this.morphTargetsRelative = e.morphTargetsRelative; const o = e.groups; for (let u = 0, h = o.length; u < h; u++) { const d = o[u]; this.addGroup(d.start, d.count, d.materialIndex) } const a = e.boundingBox; a !== null && (this.boundingBox = a.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const Ew = new st, Zr = new mh, ap = new $o, bw = new D, Du = new D, Fu = new D, ku = new D, q1 = new D, lp = new D, cp = new me, up = new me, fp = new me, Z1 = new D, hp = new D; class Pn extends bt { constructor(e = new ut, t = new Gi) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } getVertexPosition(e, t) { const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, o = i.morphTargetsRelative; t.fromBufferAttribute(r, e); const a = this.morphTargetInfluences; if (s && a) { lp.set(0, 0, 0); for (let l = 0, u = s.length; l < u; l++) { const h = a[l], d = s[l]; h !== 0 && (q1.fromBufferAttribute(d, e), o ? lp.addScaledVector(q1, h) : lp.addScaledVector(q1.sub(t), h)) } t.add(lp) } return this.isSkinnedMesh && this.boneTransform(e, t), t } raycast(e, t) { const i = this.geometry, r = this.material, s = this.matrixWorld; if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), ap.copy(i.boundingSphere), ap.applyMatrix4(s), Zr.copy(e.ray).recast(e.near), ap.containsPoint(Zr.origin) === !1 && (Zr.intersectSphere(ap, bw) === null || Zr.origin.distanceToSquared(bw) > (e.far - e.near) ** 2)) || (Ew.copy(s).invert(), Zr.copy(e.ray).applyMatrix4(Ew), i.boundingBox !== null && Zr.intersectsBox(i.boundingBox) === !1)) return; let o; const a = i.index, l = i.attributes.position, u = i.attributes.uv, h = i.attributes.uv2, d = i.groups, p = i.drawRange; if (a !== null) if (Array.isArray(r)) for (let m = 0, v = d.length; m < v; m++) { const y = d[m], x = r[y.materialIndex], A = Math.max(y.start, p.start), _ = Math.min(a.count, Math.min(y.start + y.count, p.start + p.count)); for (let M = A, S = _; M < S; M += 3) { const b = a.getX(M), B = a.getX(M + 1), R = a.getX(M + 2); o = dp(this, x, e, Zr, u, h, b, B, R), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = y.materialIndex, t.push(o)) } } else { const m = Math.max(0, p.start), v = Math.min(a.count, p.start + p.count); for (let y = m, x = v; y < x; y += 3) { const A = a.getX(y), _ = a.getX(y + 1), M = a.getX(y + 2); o = dp(this, r, e, Zr, u, h, A, _, M), o && (o.faceIndex = Math.floor(y / 3), t.push(o)) } } else if (l !== void 0) if (Array.isArray(r)) for (let m = 0, v = d.length; m < v; m++) { const y = d[m], x = r[y.materialIndex], A = Math.max(y.start, p.start), _ = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count)); for (let M = A, S = _; M < S; M += 3) { const b = M, B = M + 1, R = M + 2; o = dp(this, x, e, Zr, u, h, b, B, R), o && (o.faceIndex = Math.floor(M / 3), o.face.materialIndex = y.materialIndex, t.push(o)) } } else { const m = Math.max(0, p.start), v = Math.min(l.count, p.start + p.count); for (let y = m, x = v; y < x; y += 3) { const A = y, _ = y + 1, M = y + 2; o = dp(this, r, e, Zr, u, h, A, _, M), o && (o.faceIndex = Math.floor(y / 3), t.push(o)) } } } } function YL(n, e, t, i, r, s, o, a) { let l; if (e.side === Bi ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === as, a), l === null) return null; hp.copy(a), hp.applyMatrix4(n.matrixWorld); const u = t.ray.origin.distanceTo(hp); return u < t.near || u > t.far ? null : { distance: u, point: hp.clone(), object: n } } function dp(n, e, t, i, r, s, o, a, l) { n.getVertexPosition(o, Du), n.getVertexPosition(a, Fu), n.getVertexPosition(l, ku); const u = YL(n, e, t, i, Du, Fu, ku, Z1); if (u) { r && (cp.fromBufferAttribute(r, o), up.fromBufferAttribute(r, a), fp.fromBufferAttribute(r, l), u.uv = fr.getUV(Z1, Du, Fu, ku, cp, up, fp, new me)), s && (cp.fromBufferAttribute(s, o), up.fromBufferAttribute(s, a), fp.fromBufferAttribute(s, l), u.uv2 = fr.getUV(Z1, Du, Fu, ku, cp, up, fp, new me)); const h = { a: o, b: a, c: l, normal: new D, materialIndex: 0 }; fr.getNormal(Du, Fu, ku, h.normal), u.face = h } return u } class ea extends ut { constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: o }; const a = this; r = Math.floor(r), s = Math.floor(s), o = Math.floor(o); const l = [], u = [], h = [], d = []; let p = 0, m = 0; v("z", "y", "x", -1, -1, i, t, e, o, s, 0), v("z", "y", "x", 1, -1, i, t, -e, o, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, o, 2), v("x", "z", "y", 1, -1, e, i, -t, r, o, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new je(u, 3)), this.setAttribute("normal", new je(h, 3)), this.setAttribute("uv", new je(d, 2)); function v(y, x, A, _, M, S, b, B, R, E, P) { const L = S / R, z = b / E, Z = S / 2, J = b / 2, V = B / 2, K = R + 1, ee = E + 1; let le = 0, N = 0; const H = new D; for (let W = 0; W < ee; W++) { const se = W * z - J; for (let j = 0; j < K; j++) { const oe = j * L - Z; H[y] = oe * _, H[x] = se * M, H[A] = V, u.push(H.x, H.y, H.z), H[y] = 0, H[x] = 0, H[A] = B > 0 ? 1 : -1, h.push(H.x, H.y, H.z), d.push(j / R), d.push(1 - W / E), le += 1 } } for (let W = 0; W < E; W++)for (let se = 0; se < R; se++) { const j = p + se + K * W, oe = p + se + K * (W + 1), ve = p + (se + 1) + K * (W + 1), q = p + (se + 1) + K * W; l.push(j, oe, q), l.push(oe, ve, q), N += 6 } a.addGroup(m, N, P), m += N, p += le } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new ea(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function kc(n) { const e = {}; for (const t in n) { e[t] = {}; for (const i in n[t]) { const r = n[t][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r } } return e } function hi(n) { const e = {}; for (let t = 0; t < n.length; t++) { const i = kc(n[t]); for (const r in i) e[r] = i[r] } return e } function qL(n) { const e = []; for (let t = 0; t < n.length; t++)e.push(n[t].clone()); return e } function H5(n) { return n.getRenderTarget() === null && n.outputEncoding === St ? Br : Fc } const V5 = { clone: kc, merge: hi }; var ZL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, $L = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class cs extends En { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = ZL, this.fragmentShader = $L, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = kc(e.uniforms), this.uniformsGroups = qL(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const r in this.uniforms) { const o = this.uniforms[r].value; o && o.isTexture ? t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[r] = { type: "m4", value: o.toArray() } : t.uniforms[r] = { value: o } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const i = {}; for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t } } class gh extends bt { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new st, this.projectionMatrix = new st, this.projectionMatrixInverse = new st } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } class Ut extends gh { constructor(e = 50, t = 1, i = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = Xf * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(Qa * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return Xf * 2 * Math.atan(Math.tan(Qa * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, i, r, s, o) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(Qa * .5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -.5 * r; const o = this.view; if (this.view !== null && this.view.enabled) { const l = o.fullWidth, u = o.fullHeight; s += o.offsetX * r / l, t -= o.offsetY * i / u, r *= o.width / l, i *= o.height / u } const a = this.filmOffset; a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const Ol = -90, zl = 1; class oA extends bt { constructor(e, t, i) { super(), this.type = "CubeCamera", this.renderTarget = i; const r = new Ut(Ol, zl, e, t); r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r); const s = new Ut(Ol, zl, e, t); s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s); const o = new Ut(Ol, zl, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o); const a = new Ut(Ol, zl, e, t); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a); const l = new Ut(Ol, zl, e, t); l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l); const u = new Ut(Ol, zl, e, t); u.layers = this.layers, u.up.set(0, 1, 0), u.lookAt(0, 0, -1), this.add(u) } update(e, t) { this.parent === null && this.updateMatrixWorld(); const i = this.renderTarget, [r, s, o, a, l, u] = this.children, h = e.getRenderTarget(), d = e.toneMapping, p = e.xr.enabled; e.toneMapping = Fr, e.xr.enabled = !1; const m = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, o), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = m, e.setRenderTarget(i, 5), e.render(t, u), e.setRenderTarget(h), e.toneMapping = d, e.xr.enabled = p, i.texture.needsPMREMUpdate = !0 } } class yh extends Zt { constructor(e, t, i, r, s, o, a, l, u, h) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : Ho, super(e, t, i, r, s, o, a, l, u, h), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class aA extends Or {
  constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i]; this.texture = new yh(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : tn } fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const i = {
      uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new ea(5, 5, 5), s = new cs({ name: "CubemapFromEquirect", uniforms: kc(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Bi, blending: Os }); s.uniforms.tEquirect.value = t; const o = new Pn(r, s), a = t.minFilter; return t.minFilter === ls && (t.minFilter = tn), new oA(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
  } clear(e, t, i, r) { const s = e.getRenderTarget(); for (let o = 0; o < 6; o++)e.setRenderTarget(this, o), e.clear(t, i, r); e.setRenderTarget(s) }
} const $1 = new D, eI = new D, tI = new Vn; class xo { constructor(e = new D(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, r) { return this.normal.set(e, t, i), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { const r = $1.subVectors(i, t).cross(eI.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const i = e.delta($1), r = this.normal.dot(i); if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const s = -(e.start.dot(this.normal) + this.constant) / r; return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s) } intersectsLine(e) { const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const i = t || tI.getNormalMatrix(e), r = this.coplanarPoint($1).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize(); return this.constant = -r.dot(s), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const Ul = new $o, pp = new D; class P0 { constructor(e = new xo, t = new xo, i = new xo, r = new xo, s = new xo, o = new xo) { this.planes = [e, t, i, r, s, o] } set(e, t, i, r, s, o) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this } copy(e) { const t = this.planes; for (let i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this } setFromProjectionMatrix(e) { const t = this.planes, i = e.elements, r = i[0], s = i[1], o = i[2], a = i[3], l = i[4], u = i[5], h = i[6], d = i[7], p = i[8], m = i[9], v = i[10], y = i[11], x = i[12], A = i[13], _ = i[14], M = i[15]; return t[0].setComponents(a - r, d - l, y - p, M - x).normalize(), t[1].setComponents(a + r, d + l, y + p, M + x).normalize(), t[2].setComponents(a + s, d + u, y + m, M + A).normalize(), t[3].setComponents(a - s, d - u, y - m, M - A).normalize(), t[4].setComponents(a - o, d - h, y - v, M - _).normalize(), t[5].setComponents(a + o, d + h, y + v, M + _).normalize(), this } intersectsObject(e) { const t = e.geometry; return t.boundingSphere === null && t.computeBoundingSphere(), Ul.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Ul) } intersectsSprite(e) { return Ul.center.set(0, 0, 0), Ul.radius = .7071067811865476, Ul.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ul) } intersectsSphere(e) { const t = this.planes, i = e.center, r = -e.radius; for (let s = 0; s < 6; s++)if (t[s].distanceToPoint(i) < r) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let i = 0; i < 6; i++) { const r = t[i]; if (pp.x = r.normal.x > 0 ? e.max.x : e.min.x, pp.y = r.normal.y > 0 ? e.max.y : e.min.y, pp.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(pp) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let i = 0; i < 6; i++)if (t[i].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function W5() { let n = null, e = !1, t = null, i = null; function r(s, o) { t(s, o), i = n.requestAnimationFrame(r) } return { start: function () { e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0) }, stop: function () { n.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (s) { t = s }, setContext: function (s) { n = s } } } function nI(n, e) { const t = e.isWebGL2, i = new WeakMap; function r(u, h) { const d = u.array, p = u.usage, m = n.createBuffer(); n.bindBuffer(h, m), n.bufferData(h, d, p), u.onUploadCallback(); let v; if (d instanceof Float32Array) v = 5126; else if (d instanceof Uint16Array) if (u.isFloat16BufferAttribute) if (t) v = 5131; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else v = 5123; else if (d instanceof Int16Array) v = 5122; else if (d instanceof Uint32Array) v = 5125; else if (d instanceof Int32Array) v = 5124; else if (d instanceof Int8Array) v = 5120; else if (d instanceof Uint8Array) v = 5121; else if (d instanceof Uint8ClampedArray) v = 5121; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d); return { buffer: m, type: v, bytesPerElement: d.BYTES_PER_ELEMENT, version: u.version } } function s(u, h, d) { const p = h.array, m = h.updateRange; n.bindBuffer(d, u), m.count === -1 ? n.bufferSubData(d, 0, p) : (t ? n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(d, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), h.onUploadCallback() } function o(u) { return u.isInterleavedBufferAttribute && (u = u.data), i.get(u) } function a(u) { u.isInterleavedBufferAttribute && (u = u.data); const h = i.get(u); h && (n.deleteBuffer(h.buffer), i.delete(u)) } function l(u, h) { if (u.isGLBufferAttribute) { const p = i.get(u); (!p || p.version < u.version) && i.set(u, { buffer: u.buffer, type: u.type, bytesPerElement: u.elementSize, version: u.version }); return } u.isInterleavedBufferAttribute && (u = u.data); const d = i.get(u); d === void 0 ? i.set(u, r(u, h)) : d.version < u.version && (s(d.buffer, u, h), d.version = u.version) } return { get: o, remove: a, update: l } } class Qc extends ut { constructor(e = 1, t = 1, i = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r }; const s = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(r), u = a + 1, h = l + 1, d = e / a, p = t / l, m = [], v = [], y = [], x = []; for (let A = 0; A < h; A++) { const _ = A * p - o; for (let M = 0; M < u; M++) { const S = M * d - s; v.push(S, -_, 0), y.push(0, 0, 1), x.push(M / a), x.push(1 - A / l) } } for (let A = 0; A < l; A++)for (let _ = 0; _ < a; _++) { const M = _ + u * A, S = _ + u * (A + 1), b = _ + 1 + u * (A + 1), B = _ + 1 + u * A; m.push(M, S, B), m.push(S, b, B) } this.setIndex(m), this.setAttribute("position", new je(v, 3)), this.setAttribute("normal", new je(y, 3)), this.setAttribute("uv", new je(x, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Qc(e.width, e.height, e.widthSegments, e.heightSegments) } } var iI = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, rI = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, sI = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, oI = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, aI = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, lI = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, cI = "vec3 transformed = vec3( position );", uI = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, fI = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, hI = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, dI = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, pI = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, mI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, gI = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, yI = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, vI = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, xI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, AI = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, MI = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, _I = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, wI = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, SI = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, CI = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, EI = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, bI = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, TI = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, BI = "gl_FragColor = linearToOutputTexel( gl_FragColor );", PI = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, RI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, LI = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, II = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, DI = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, FI = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, kI = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, NI = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, OI = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, zI = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, UI = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, GI = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, HI = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, VI = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, WI = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, jI = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, JI = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, XI = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, QI = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, KI = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, YI = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, qI = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, ZI = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, $I = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, eD = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, tD = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, nD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, iD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, rD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, sD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, oD = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, aD = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, lD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, cD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, uD = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, fD = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, hD = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, dD = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, pD = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, mD = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, gD = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, yD = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, vD = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, xD = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, AD = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, MD = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, _D = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, wD = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, SD = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, CD = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, ED = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, bD = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, TD = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, BD = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, PD = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, RD = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, LD = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, ID = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, DD = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, FD = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, kD = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, ND = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, OD = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, zD = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, UD = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, GD = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, HD = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, VD = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, WD = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, jD = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, JD = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, XD = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, QD = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, KD = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, YD = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, qD = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, ZD = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, $D = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, e7 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const t7 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, n7 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, i7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, r7 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, s7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, o7 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, a7 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, l7 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, c7 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, u7 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, f7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, h7 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, d7 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, p7 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, m7 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, g7 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, y7 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, v7 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, x7 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, A7 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, M7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, _7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, w7 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, S7 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, C7 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, E7 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, b7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, T7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, B7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, P7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, R7 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, L7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, I7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, D7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, dt = { alphamap_fragment: iI, alphamap_pars_fragment: rI, alphatest_fragment: sI, alphatest_pars_fragment: oI, aomap_fragment: aI, aomap_pars_fragment: lI, begin_vertex: cI, beginnormal_vertex: uI, bsdfs: fI, iridescence_fragment: hI, bumpmap_pars_fragment: dI, clipping_planes_fragment: pI, clipping_planes_pars_fragment: mI, clipping_planes_pars_vertex: gI, clipping_planes_vertex: yI, color_fragment: vI, color_pars_fragment: xI, color_pars_vertex: AI, color_vertex: MI, common: _I, cube_uv_reflection_fragment: wI, defaultnormal_vertex: SI, displacementmap_pars_vertex: CI, displacementmap_vertex: EI, emissivemap_fragment: bI, emissivemap_pars_fragment: TI, encodings_fragment: BI, encodings_pars_fragment: PI, envmap_fragment: RI, envmap_common_pars_fragment: LI, envmap_pars_fragment: II, envmap_pars_vertex: DI, envmap_physical_pars_fragment: JI, envmap_vertex: FI, fog_vertex: kI, fog_pars_vertex: NI, fog_fragment: OI, fog_pars_fragment: zI, gradientmap_pars_fragment: UI, lightmap_fragment: GI, lightmap_pars_fragment: HI, lights_lambert_fragment: VI, lights_lambert_pars_fragment: WI, lights_pars_begin: jI, lights_toon_fragment: XI, lights_toon_pars_fragment: QI, lights_phong_fragment: KI, lights_phong_pars_fragment: YI, lights_physical_fragment: qI, lights_physical_pars_fragment: ZI, lights_fragment_begin: $I, lights_fragment_maps: eD, lights_fragment_end: tD, logdepthbuf_fragment: nD, logdepthbuf_pars_fragment: iD, logdepthbuf_pars_vertex: rD, logdepthbuf_vertex: sD, map_fragment: oD, map_pars_fragment: aD, map_particle_fragment: lD, map_particle_pars_fragment: cD, metalnessmap_fragment: uD, metalnessmap_pars_fragment: fD, morphcolor_vertex: hD, morphnormal_vertex: dD, morphtarget_pars_vertex: pD, morphtarget_vertex: mD, normal_fragment_begin: gD, normal_fragment_maps: yD, normal_pars_fragment: vD, normal_pars_vertex: xD, normal_vertex: AD, normalmap_pars_fragment: MD, clearcoat_normal_fragment_begin: _D, clearcoat_normal_fragment_maps: wD, clearcoat_pars_fragment: SD, iridescence_pars_fragment: CD, output_fragment: ED, packing: bD, premultiplied_alpha_fragment: TD, project_vertex: BD, dithering_fragment: PD, dithering_pars_fragment: RD, roughnessmap_fragment: LD, roughnessmap_pars_fragment: ID, shadowmap_pars_fragment: DD, shadowmap_pars_vertex: FD, shadowmap_vertex: kD, shadowmask_pars_fragment: ND, skinbase_vertex: OD, skinning_pars_vertex: zD, skinning_vertex: UD, skinnormal_vertex: GD, specularmap_fragment: HD, specularmap_pars_fragment: VD, tonemapping_fragment: WD, tonemapping_pars_fragment: jD, transmission_fragment: JD, transmission_pars_fragment: XD, uv_pars_fragment: QD, uv_pars_vertex: KD, uv_vertex: YD, uv2_pars_fragment: qD, uv2_pars_vertex: ZD, uv2_vertex: $D, worldpos_vertex: e7, background_vert: t7, background_frag: n7, backgroundCube_vert: i7, backgroundCube_frag: r7, cube_vert: s7, cube_frag: o7, depth_vert: a7, depth_frag: l7, distanceRGBA_vert: c7, distanceRGBA_frag: u7, equirect_vert: f7, equirect_frag: h7, linedashed_vert: d7, linedashed_frag: p7, meshbasic_vert: m7, meshbasic_frag: g7, meshlambert_vert: y7, meshlambert_frag: v7, meshmatcap_vert: x7, meshmatcap_frag: A7, meshnormal_vert: M7, meshnormal_frag: _7, meshphong_vert: w7, meshphong_frag: S7, meshphysical_vert: C7, meshphysical_frag: E7, meshtoon_vert: b7, meshtoon_frag: T7, points_vert: B7, points_frag: P7, shadow_vert: R7, shadow_frag: L7, sprite_vert: I7, sprite_frag: D7 }, De = { common: { diffuse: { value: new Re(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Vn }, uv2Transform: { value: new Vn }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new me(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Re(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Re(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Vn } }, sprite: { diffuse: { value: new Re(16777215) }, opacity: { value: 1 }, center: { value: new me(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Vn } } }, Rr = { basic: { uniforms: hi([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.fog]), vertexShader: dt.meshbasic_vert, fragmentShader: dt.meshbasic_frag }, lambert: { uniforms: hi([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.fog, De.lights, { emissive: { value: new Re(0) } }]), vertexShader: dt.meshlambert_vert, fragmentShader: dt.meshlambert_frag }, phong: { uniforms: hi([De.common, De.specularmap, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.fog, De.lights, { emissive: { value: new Re(0) }, specular: { value: new Re(1118481) }, shininess: { value: 30 } }]), vertexShader: dt.meshphong_vert, fragmentShader: dt.meshphong_frag }, standard: { uniforms: hi([De.common, De.envmap, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.roughnessmap, De.metalnessmap, De.fog, De.lights, { emissive: { value: new Re(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: dt.meshphysical_vert, fragmentShader: dt.meshphysical_frag }, toon: { uniforms: hi([De.common, De.aomap, De.lightmap, De.emissivemap, De.bumpmap, De.normalmap, De.displacementmap, De.gradientmap, De.fog, De.lights, { emissive: { value: new Re(0) } }]), vertexShader: dt.meshtoon_vert, fragmentShader: dt.meshtoon_frag }, matcap: { uniforms: hi([De.common, De.bumpmap, De.normalmap, De.displacementmap, De.fog, { matcap: { value: null } }]), vertexShader: dt.meshmatcap_vert, fragmentShader: dt.meshmatcap_frag }, points: { uniforms: hi([De.points, De.fog]), vertexShader: dt.points_vert, fragmentShader: dt.points_frag }, dashed: { uniforms: hi([De.common, De.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: dt.linedashed_vert, fragmentShader: dt.linedashed_frag }, depth: { uniforms: hi([De.common, De.displacementmap]), vertexShader: dt.depth_vert, fragmentShader: dt.depth_frag }, normal: { uniforms: hi([De.common, De.bumpmap, De.normalmap, De.displacementmap, { opacity: { value: 1 } }]), vertexShader: dt.meshnormal_vert, fragmentShader: dt.meshnormal_frag }, sprite: { uniforms: hi([De.sprite, De.fog]), vertexShader: dt.sprite_vert, fragmentShader: dt.sprite_frag }, background: { uniforms: { uvTransform: { value: new Vn }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: dt.background_vert, fragmentShader: dt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: dt.backgroundCube_vert, fragmentShader: dt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: dt.cube_vert, fragmentShader: dt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: dt.equirect_vert, fragmentShader: dt.equirect_frag }, distanceRGBA: { uniforms: hi([De.common, De.displacementmap, { referencePosition: { value: new D }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: dt.distanceRGBA_vert, fragmentShader: dt.distanceRGBA_frag }, shadow: { uniforms: hi([De.lights, De.fog, { color: { value: new Re(0) }, opacity: { value: 1 } }]), vertexShader: dt.shadow_vert, fragmentShader: dt.shadow_frag } }; Rr.physical = { uniforms: hi([Rr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new me(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Re(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new me }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Re(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Re(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: dt.meshphysical_vert, fragmentShader: dt.meshphysical_frag }; const mp = { r: 0, b: 0, g: 0 }; function F7(n, e, t, i, r, s, o) { const a = new Re(0); let l = s === !0 ? 0 : 1, u, h, d = null, p = 0, m = null; function v(x, A) { let _ = !1, M = A.isScene === !0 ? A.background : null; M && M.isTexture && (M = (A.backgroundBlurriness > 0 ? t : e).get(M)); const S = n.xr, b = S.getSession && S.getSession(); b && b.environmentBlendMode === "additive" && (M = null), M === null ? y(a, l) : M && M.isColor && (y(M, 1), _ = !0), (n.autoClear || _) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), M && (M.isCubeTexture || M.mapping === Xc) ? (h === void 0 && (h = new Pn(new ea(1, 1, 1), new cs({ name: "BackgroundCubeMaterial", uniforms: kc(Rr.backgroundCube.uniforms), vertexShader: Rr.backgroundCube.vertexShader, fragmentShader: Rr.backgroundCube.fragmentShader, side: Bi, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function (B, R, E) { this.matrixWorld.copyPosition(E.matrixWorld) }, Object.defineProperty(h.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(h)), h.material.uniforms.envMap.value = M, h.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, h.material.toneMapped = M.encoding !== St, (d !== M || p !== M.version || m !== n.toneMapping) && (h.material.needsUpdate = !0, d = M, p = M.version, m = n.toneMapping), h.layers.enableAll(), x.unshift(h, h.geometry, h.material, 0, 0, null)) : M && M.isTexture && (u === void 0 && (u = new Pn(new Qc(2, 2), new cs({ name: "BackgroundMaterial", uniforms: kc(Rr.background.uniforms), vertexShader: Rr.background.vertexShader, fragmentShader: Rr.background.fragmentShader, side: as, depthTest: !1, depthWrite: !1, fog: !1 })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(u)), u.material.uniforms.t2D.value = M, u.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, u.material.toneMapped = M.encoding !== St, M.matrixAutoUpdate === !0 && M.updateMatrix(), u.material.uniforms.uvTransform.value.copy(M.matrix), (d !== M || p !== M.version || m !== n.toneMapping) && (u.material.needsUpdate = !0, d = M, p = M.version, m = n.toneMapping), u.layers.enableAll(), x.unshift(u, u.geometry, u.material, 0, 0, null)) } function y(x, A) { x.getRGB(mp, H5(n)), i.buffers.color.setClear(mp.r, mp.g, mp.b, A, o) } return { getClearColor: function () { return a }, setClearColor: function (x, A = 1) { a.set(x), l = A, y(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (x) { l = x, y(a, l) }, render: v } } function k7(n, e, t, i) { const r = n.getParameter(34921), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, a = {}, l = x(null); let u = l, h = !1; function d(V, K, ee, le, N) { let H = !1; if (o) { const W = y(le, ee, K); u !== W && (u = W, m(u.object)), H = A(V, le, ee, N), H && _(V, le, ee, N) } else { const W = K.wireframe === !0; (u.geometry !== le.id || u.program !== ee.id || u.wireframe !== W) && (u.geometry = le.id, u.program = ee.id, u.wireframe = W, H = !0) } N !== null && t.update(N, 34963), (H || h) && (h = !1, E(V, K, ee, le), N !== null && n.bindBuffer(34963, t.get(N).buffer)) } function p() { return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES() } function m(V) { return i.isWebGL2 ? n.bindVertexArray(V) : s.bindVertexArrayOES(V) } function v(V) { return i.isWebGL2 ? n.deleteVertexArray(V) : s.deleteVertexArrayOES(V) } function y(V, K, ee) { const le = ee.wireframe === !0; let N = a[V.id]; N === void 0 && (N = {}, a[V.id] = N); let H = N[K.id]; H === void 0 && (H = {}, N[K.id] = H); let W = H[le]; return W === void 0 && (W = x(p()), H[le] = W), W } function x(V) { const K = [], ee = [], le = []; for (let N = 0; N < r; N++)K[N] = 0, ee[N] = 0, le[N] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: K, enabledAttributes: ee, attributeDivisors: le, object: V, attributes: {}, index: null } } function A(V, K, ee, le) { const N = u.attributes, H = K.attributes; let W = 0; const se = ee.getAttributes(); for (const j in se) if (se[j].location >= 0) { const ve = N[j]; let q = H[j]; if (q === void 0 && (j === "instanceMatrix" && V.instanceMatrix && (q = V.instanceMatrix), j === "instanceColor" && V.instanceColor && (q = V.instanceColor)), ve === void 0 || ve.attribute !== q || q && ve.data !== q.data) return !0; W++ } return u.attributesNum !== W || u.index !== le } function _(V, K, ee, le) { const N = {}, H = K.attributes; let W = 0; const se = ee.getAttributes(); for (const j in se) if (se[j].location >= 0) { let ve = H[j]; ve === void 0 && (j === "instanceMatrix" && V.instanceMatrix && (ve = V.instanceMatrix), j === "instanceColor" && V.instanceColor && (ve = V.instanceColor)); const q = {}; q.attribute = ve, ve && ve.data && (q.data = ve.data), N[j] = q, W++ } u.attributes = N, u.attributesNum = W, u.index = le } function M() { const V = u.newAttributes; for (let K = 0, ee = V.length; K < ee; K++)V[K] = 0 } function S(V) { b(V, 0) } function b(V, K) { const ee = u.newAttributes, le = u.enabledAttributes, N = u.attributeDivisors; ee[V] = 1, le[V] === 0 && (n.enableVertexAttribArray(V), le[V] = 1), N[V] !== K && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](V, K), N[V] = K) } function B() { const V = u.newAttributes, K = u.enabledAttributes; for (let ee = 0, le = K.length; ee < le; ee++)K[ee] !== V[ee] && (n.disableVertexAttribArray(ee), K[ee] = 0) } function R(V, K, ee, le, N, H) { i.isWebGL2 === !0 && (ee === 5124 || ee === 5125) ? n.vertexAttribIPointer(V, K, ee, N, H) : n.vertexAttribPointer(V, K, ee, le, N, H) } function E(V, K, ee, le) { if (i.isWebGL2 === !1 && (V.isInstancedMesh || le.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; M(); const N = le.attributes, H = ee.getAttributes(), W = K.defaultAttributeValues; for (const se in H) { const j = H[se]; if (j.location >= 0) { let oe = N[se]; if (oe === void 0 && (se === "instanceMatrix" && V.instanceMatrix && (oe = V.instanceMatrix), se === "instanceColor" && V.instanceColor && (oe = V.instanceColor)), oe !== void 0) { const ve = oe.normalized, q = oe.itemSize, Te = t.get(oe); if (Te === void 0) continue; const Se = Te.buffer, Fe = Te.type, ze = Te.bytesPerElement; if (oe.isInterleavedBufferAttribute) { const Le = oe.data, be = Le.stride, de = oe.offset; if (Le.isInstancedInterleavedBuffer) { for (let pe = 0; pe < j.locationSize; pe++)b(j.location + pe, Le.meshPerAttribute); V.isInstancedMesh !== !0 && le._maxInstanceCount === void 0 && (le._maxInstanceCount = Le.meshPerAttribute * Le.count) } else for (let pe = 0; pe < j.locationSize; pe++)S(j.location + pe); n.bindBuffer(34962, Se); for (let pe = 0; pe < j.locationSize; pe++)R(j.location + pe, q / j.locationSize, Fe, ve, be * ze, (de + q / j.locationSize * pe) * ze) } else { if (oe.isInstancedBufferAttribute) { for (let Le = 0; Le < j.locationSize; Le++)b(j.location + Le, oe.meshPerAttribute); V.isInstancedMesh !== !0 && le._maxInstanceCount === void 0 && (le._maxInstanceCount = oe.meshPerAttribute * oe.count) } else for (let Le = 0; Le < j.locationSize; Le++)S(j.location + Le); n.bindBuffer(34962, Se); for (let Le = 0; Le < j.locationSize; Le++)R(j.location + Le, q / j.locationSize, Fe, ve, q * ze, q / j.locationSize * Le * ze) } } else if (W !== void 0) { const ve = W[se]; if (ve !== void 0) switch (ve.length) { case 2: n.vertexAttrib2fv(j.location, ve); break; case 3: n.vertexAttrib3fv(j.location, ve); break; case 4: n.vertexAttrib4fv(j.location, ve); break; default: n.vertexAttrib1fv(j.location, ve) } } } } B() } function P() { Z(); for (const V in a) { const K = a[V]; for (const ee in K) { const le = K[ee]; for (const N in le) v(le[N].object), delete le[N]; delete K[ee] } delete a[V] } } function L(V) { if (a[V.id] === void 0) return; const K = a[V.id]; for (const ee in K) { const le = K[ee]; for (const N in le) v(le[N].object), delete le[N]; delete K[ee] } delete a[V.id] } function z(V) { for (const K in a) { const ee = a[K]; if (ee[V.id] === void 0) continue; const le = ee[V.id]; for (const N in le) v(le[N].object), delete le[N]; delete ee[V.id] } } function Z() { J(), h = !0, u !== l && (u = l, m(u.object)) } function J() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: d, reset: Z, resetDefaultState: J, dispose: P, releaseStatesOfGeometry: L, releaseStatesOfProgram: z, initAttributes: M, enableAttribute: S, disableUnusedAttributes: B } } function N7(n, e, t, i) { const r = i.isWebGL2; let s; function o(u) { s = u } function a(u, h) { n.drawArrays(s, u, h), t.update(h, s, 1) } function l(u, h, d) { if (d === 0) return; let p, m; if (r) p = n, m = "drawArraysInstanced"; else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } p[m](s, u, h, d), t.update(h, s, d) } this.setMode = o, this.render = a, this.renderInstances = l } function O7(n, e, t) { let i; function r() { if (i !== void 0) return i; if (e.has("EXT_texture_filter_anisotropic") === !0) { const R = e.get("EXT_texture_filter_anisotropic"); i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i } function s(R) { if (R === "highp") { if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; R = "mediump" } return R === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext; let a = t.precision !== void 0 ? t.precision : "highp"; const l = s(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); const u = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, d = n.getParameter(34930), p = n.getParameter(35660), m = n.getParameter(3379), v = n.getParameter(34076), y = n.getParameter(34921), x = n.getParameter(36347), A = n.getParameter(36348), _ = n.getParameter(36349), M = p > 0, S = o || e.has("OES_texture_float"), b = M && S, B = o ? n.getParameter(36183) : 0; return { isWebGL2: o, drawBuffers: u, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: h, maxTextures: d, maxVertexTextures: p, maxTextureSize: m, maxCubemapSize: v, maxAttributes: y, maxVertexUniforms: x, maxVaryings: A, maxFragmentUniforms: _, vertexTextures: M, floatFragmentTextures: S, floatVertexTextures: b, maxSamples: B } } function z7(n) { const e = this; let t = null, i = 0, r = !1, s = !1; const o = new xo, a = new Vn, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (d, p) { const m = d.length !== 0 || p || i !== 0 || r; return r = p, i = d.length, m }, this.beginShadows = function () { s = !0, h(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (d, p) { t = h(d, p, 0) }, this.setState = function (d, p, m) { const v = d.clippingPlanes, y = d.clipIntersection, x = d.clipShadows, A = n.get(d); if (!r || v === null || v.length === 0 || s && !x) s ? h(null) : u(); else { const _ = s ? 0 : i, M = _ * 4; let S = A.clippingState || null; l.value = S, S = h(v, p, M, m); for (let b = 0; b !== M; ++b)S[b] = t[b]; A.clippingState = S, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _ } }; function u() { l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 } function h(d, p, m, v) { const y = d !== null ? d.length : 0; let x = null; if (y !== 0) { if (x = l.value, v !== !0 || x === null) { const A = m + y * 4, _ = p.matrixWorldInverse; a.getNormalMatrix(_), (x === null || x.length < A) && (x = new Float32Array(A)); for (let M = 0, S = m; M !== y; ++M, S += 4)o.copy(d[M]).applyMatrix4(_, a), o.normal.toArray(x, S), x[S + 3] = o.constant } l.value = x, l.needsUpdate = !0 } return e.numPlanes = y, e.numIntersection = 0, x } } function U7(n) { let e = new WeakMap; function t(o, a) { return a === Hf ? o.mapping = Ho : a === Vf && (o.mapping = Vo), o } function i(o) { if (o && o.isTexture && o.isRenderTargetTexture === !1) { const a = o.mapping; if (a === Hf || a === Vf) if (e.has(o)) { const l = e.get(o).texture; return t(l, o.mapping) } else { const l = o.image; if (l && l.height > 0) { const u = new aA(l.height / 2); return u.fromEquirectangularTexture(n, o), e.set(o, u), o.addEventListener("dispose", r), t(u.texture, o.mapping) } else return null } } return o } function r(o) { const a = o.target; a.removeEventListener("dispose", r); const l = e.get(a); l !== void 0 && (e.delete(a), l.dispose()) } function s() { e = new WeakMap } return { get: i, dispose: s } } class kr extends gh { constructor(e = -1, t = 1, i = 1, r = -1, s = .1, o = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, r, s, o) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let s = i - e, o = i + e, a = r + t, l = r - t; if (this.view !== null && this.view.enabled) { const u = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s += u * this.view.offsetX, o = s + u * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height } this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const cc = 4, Tw = [.125, .215, .35, .446, .526, .582], La = 20, ey = new kr, Bw = new Re; let ty = null; const ba = (1 + Math.sqrt(5)) / 2, Gl = 1 / ba, Pw = [new D(1, 1, 1), new D(-1, 1, 1), new D(1, 1, -1), new D(-1, 1, -1), new D(0, ba, Gl), new D(0, ba, -Gl), new D(Gl, 0, ba), new D(-Gl, 0, ba), new D(ba, Gl, 0), new D(-ba, Gl, 0)]; class p2 { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, i = .1, r = 100) { ty = this._renderer.getRenderTarget(), this._setSize(256); const s = this._allocateTargets(); return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = Iw(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = Lw(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(ty), e.scissorTest = !1, gp(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === Ho || e.mapping === Vo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ty = this._renderer.getRenderTarget(); const i = t || this._allocateTargets(); return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: tn, minFilter: tn, generateMipmaps: !1, type: Ic, format: Si, encoding: Js, depthBuffer: !1 }, r = Rw(e, t, i); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Rw(e, t, i); const { _lodMax: s } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = G7(s)), this._blurMaterial = H7(s, e, t) } return r } _compileMaterial(e) { const t = new Pn(this._lodPlanes[0], e); this._renderer.compile(t, ey) } _sceneToCubeUV(e, t, i, r) { const a = new Ut(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, p = h.toneMapping; h.getClearColor(Bw), h.toneMapping = Fr, h.autoClear = !1; const m = new Gi({ name: "PMREM.Background", side: Bi, depthWrite: !1, depthTest: !1 }), v = new Pn(new ea, m); let y = !1; const x = e.background; x ? x.isColor && (m.color.copy(x), e.background = null, y = !0) : (m.color.copy(Bw), y = !0); for (let A = 0; A < 6; A++) { const _ = A % 3; _ === 0 ? (a.up.set(0, l[A], 0), a.lookAt(u[A], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[A]), a.lookAt(0, u[A], 0)) : (a.up.set(0, l[A], 0), a.lookAt(0, 0, u[A])); const M = this._cubeSize; gp(r, _ * M, A > 2 ? M : 0, M, M), h.setRenderTarget(r), y && h.render(v, a), h.render(e, a) } v.geometry.dispose(), v.material.dispose(), h.toneMapping = p, h.autoClear = d, e.background = x } _textureToCubeUV(e, t) { const i = this._renderer, r = e.mapping === Ho || e.mapping === Vo; r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Iw()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Lw()); const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Pn(this._lodPlanes[0], s), a = s.uniforms; a.envMap.value = e; const l = this._cubeSize; gp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, ey) } _applyPMREM(e) { const t = this._renderer, i = t.autoClear; t.autoClear = !1; for (let r = 1; r < this._lodPlanes.length; r++) { const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = Pw[(r - 1) % Pw.length]; this._blur(e, r - 1, r, s, o) } t.autoClear = i } _blur(e, t, i, r, s) { const o = this._pingPongRenderTarget; this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s) } _halfBlur(e, t, i, r, s, o, a) { const l = this._renderer, u = this._blurMaterial; o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const h = 3, d = new Pn(this._lodPlanes[r], u), p = u.uniforms, m = this._sizeLods[i] - 1, v = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * La - 1), y = s / v, x = isFinite(s) ? 1 + Math.floor(h * y) : La; x > La && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${La}`); const A = []; let _ = 0; for (let R = 0; R < La; ++R) { const E = R / y, P = Math.exp(-E * E / 2); A.push(P), R === 0 ? _ += P : R < x && (_ += 2 * P) } for (let R = 0; R < A.length; R++)A[R] = A[R] / _; p.envMap.value = e.texture, p.samples.value = x, p.weights.value = A, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a); const { _lodMax: M } = this; p.dTheta.value = v, p.mipInt.value = M - i; const S = this._sizeLods[r], b = 3 * S * (r > M - cc ? r - M + cc : 0), B = 4 * (this._cubeSize - S); gp(t, b, B, 3 * S, 2 * S), l.setRenderTarget(t), l.render(d, ey) } } function G7(n) { const e = [], t = [], i = []; let r = n; const s = n - cc + 1 + Tw.length; for (let o = 0; o < s; o++) { const a = Math.pow(2, r); t.push(a); let l = 1 / a; o > n - cc ? l = Tw[o - n + cc - 1] : o === 0 && (l = 0), i.push(l); const u = 1 / (a - 2), h = -u, d = 1 + u, p = [h, h, d, h, d, d, h, h, d, d, h, d], m = 6, v = 6, y = 3, x = 2, A = 1, _ = new Float32Array(y * v * m), M = new Float32Array(x * v * m), S = new Float32Array(A * v * m); for (let B = 0; B < m; B++) { const R = B % 3 * 2 / 3 - 1, E = B > 2 ? 0 : -1, P = [R, E, 0, R + 2 / 3, E, 0, R + 2 / 3, E + 1, 0, R, E, 0, R + 2 / 3, E + 1, 0, R, E + 1, 0]; _.set(P, y * v * B), M.set(p, x * v * B); const L = [B, B, B, B, B, B]; S.set(L, A * v * B) } const b = new ut; b.setAttribute("position", new It(_, y)), b.setAttribute("uv", new It(M, x)), b.setAttribute("faceIndex", new It(S, A)), e.push(b), r > cc && r-- } return { lodPlanes: e, sizeLods: t, sigmas: i } } function Rw(n, e, t) { const i = new Or(n, e, t); return i.texture.mapping = Xc, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i } function gp(n, e, t, i, r) { n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r) } function H7(n, e, t) {
  const i = new Float32Array(La), r = new D(0, 1, 0); return new cs({
    name: "SphericalGaussianBlur", defines: { n: La, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: lA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Os, depthTest: !1, depthWrite: !1
  })
} function Lw() {
  return new cs({
    name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: lA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Os, depthTest: !1, depthWrite: !1
  })
} function Iw() {
  return new cs({
    name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: lA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Os, depthTest: !1, depthWrite: !1
  })
} function lA() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function V7(n) { let e = new WeakMap, t = null; function i(a) { if (a && a.isTexture) { const l = a.mapping, u = l === Hf || l === Vf, h = l === Ho || l === Vo; if (u || h) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let d = e.get(a); return t === null && (t = new p2(n)), d = u ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture } else { if (e.has(a)) return e.get(a).texture; { const d = a.image; if (u && d && d.height > 0 || h && d && r(d)) { t === null && (t = new p2(n)); const p = u ? t.fromEquirectangular(a) : t.fromCubemap(a); return e.set(a, p), a.addEventListener("dispose", s), p.texture } else return null } } } return a } function r(a) { let l = 0; const u = 6; for (let h = 0; h < u; h++)a[h] !== void 0 && l++; return l === u } function s(a) { const l = a.target; l.removeEventListener("dispose", s); const u = e.get(l); u !== void 0 && (e.delete(l), u.dispose()) } function o() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: i, dispose: o } } function W7(n) { const e = {}; function t(i) { if (e[i] !== void 0) return e[i]; let r; switch (i) { case "WEBGL_depth_texture": r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = n.getExtension(i) }return e[i] = r, r } return { has: function (i) { return t(i) !== null }, init: function (i) { i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (i) { const r = t(i); return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r } } } function j7(n, e, t, i) { const r = {}, s = new WeakMap; function o(d) { const p = d.target; p.index !== null && e.remove(p.index); for (const v in p.attributes) e.remove(p.attributes[v]); p.removeEventListener("dispose", o), delete r[p.id]; const m = s.get(p); m && (e.remove(m), s.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries-- } function a(d, p) { return r[p.id] === !0 || (p.addEventListener("dispose", o), r[p.id] = !0, t.memory.geometries++), p } function l(d) { const p = d.attributes; for (const v in p) e.update(p[v], 34962); const m = d.morphAttributes; for (const v in m) { const y = m[v]; for (let x = 0, A = y.length; x < A; x++)e.update(y[x], 34962) } } function u(d) { const p = [], m = d.index, v = d.attributes.position; let y = 0; if (m !== null) { const _ = m.array; y = m.version; for (let M = 0, S = _.length; M < S; M += 3) { const b = _[M + 0], B = _[M + 1], R = _[M + 2]; p.push(b, B, B, R, R, b) } } else { const _ = v.array; y = v.version; for (let M = 0, S = _.length / 3 - 1; M < S; M += 3) { const b = M + 0, B = M + 1, R = M + 2; p.push(b, B, B, R, R, b) } } const x = new (U5(p) ? sA : rA)(p, 1); x.version = y; const A = s.get(d); A && e.remove(A), s.set(d, x) } function h(d) { const p = s.get(d); if (p) { const m = d.index; m !== null && p.version < m.version && u(d) } else u(d); return s.get(d) } return { get: a, update: l, getWireframeAttribute: h } } function J7(n, e, t, i) { const r = i.isWebGL2; let s; function o(p) { s = p } let a, l; function u(p) { a = p.type, l = p.bytesPerElement } function h(p, m) { n.drawElements(s, m, a, p * l), t.update(m, s, 1) } function d(p, m, v) { if (v === 0) return; let y, x; if (r) y = n, x = "drawElementsInstanced"; else if (y = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", y === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } y[x](s, m, a, p * l, v), t.update(m, s, v) } this.setMode = o, this.setIndex = u, this.render = h, this.renderInstances = d } function X7(n) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function i(s, o, a) { switch (t.calls++, o) { case 4: t.triangles += a * (s / 3); break; case 1: t.lines += a * (s / 2); break; case 3: t.lines += a * (s - 1); break; case 2: t.lines += a * s; break; case 0: t.points += a * s; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", o); break } } function r() { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: i } } function Q7(n, e) { return n[0] - e[0] } function K7(n, e) { return Math.abs(e[1]) - Math.abs(n[1]) } function Y7(n, e, t) { const i = {}, r = new Float32Array(8), s = new WeakMap, o = new Ft, a = []; for (let u = 0; u < 8; u++)a[u] = [u, 0]; function l(u, h, d) { const p = u.morphTargetInfluences; if (e.isWebGL2 === !0) { const m = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, v = m !== void 0 ? m.length : 0; let y = s.get(h); if (y === void 0 || y.count !== v) { let V = function () { Z.dispose(), s.delete(h), h.removeEventListener("dispose", V) }; y !== void 0 && y.texture.dispose(); const _ = h.morphAttributes.position !== void 0, M = h.morphAttributes.normal !== void 0, S = h.morphAttributes.color !== void 0, b = h.morphAttributes.position || [], B = h.morphAttributes.normal || [], R = h.morphAttributes.color || []; let E = 0; _ === !0 && (E = 1), M === !0 && (E = 2), S === !0 && (E = 3); let P = h.attributes.position.count * E, L = 1; P > e.maxTextureSize && (L = Math.ceil(P / e.maxTextureSize), P = e.maxTextureSize); const z = new Float32Array(P * L * 4 * v), Z = new B0(z, P, L, v); Z.type = Is, Z.needsUpdate = !0; const J = E * 4; for (let K = 0; K < v; K++) { const ee = b[K], le = B[K], N = R[K], H = P * L * 4 * K; for (let W = 0; W < ee.count; W++) { const se = W * J; _ === !0 && (o.fromBufferAttribute(ee, W), z[H + se + 0] = o.x, z[H + se + 1] = o.y, z[H + se + 2] = o.z, z[H + se + 3] = 0), M === !0 && (o.fromBufferAttribute(le, W), z[H + se + 4] = o.x, z[H + se + 5] = o.y, z[H + se + 6] = o.z, z[H + se + 7] = 0), S === !0 && (o.fromBufferAttribute(N, W), z[H + se + 8] = o.x, z[H + se + 9] = o.y, z[H + se + 10] = o.z, z[H + se + 11] = N.itemSize === 4 ? o.w : 1) } } y = { count: v, texture: Z, size: new me(P, L) }, s.set(h, y), h.addEventListener("dispose", V) } let x = 0; for (let _ = 0; _ < p.length; _++)x += p[_]; const A = h.morphTargetsRelative ? 1 : 1 - x; d.getUniforms().setValue(n, "morphTargetBaseInfluence", A), d.getUniforms().setValue(n, "morphTargetInfluences", p), d.getUniforms().setValue(n, "morphTargetsTexture", y.texture, t), d.getUniforms().setValue(n, "morphTargetsTextureSize", y.size) } else { const m = p === void 0 ? 0 : p.length; let v = i[h.id]; if (v === void 0 || v.length !== m) { v = []; for (let M = 0; M < m; M++)v[M] = [M, 0]; i[h.id] = v } for (let M = 0; M < m; M++) { const S = v[M]; S[0] = M, S[1] = p[M] } v.sort(K7); for (let M = 0; M < 8; M++)M < m && v[M][1] ? (a[M][0] = v[M][0], a[M][1] = v[M][1]) : (a[M][0] = Number.MAX_SAFE_INTEGER, a[M][1] = 0); a.sort(Q7); const y = h.morphAttributes.position, x = h.morphAttributes.normal; let A = 0; for (let M = 0; M < 8; M++) { const S = a[M], b = S[0], B = S[1]; b !== Number.MAX_SAFE_INTEGER && B ? (y && h.getAttribute("morphTarget" + M) !== y[b] && h.setAttribute("morphTarget" + M, y[b]), x && h.getAttribute("morphNormal" + M) !== x[b] && h.setAttribute("morphNormal" + M, x[b]), r[M] = B, A += B) : (y && h.hasAttribute("morphTarget" + M) === !0 && h.deleteAttribute("morphTarget" + M), x && h.hasAttribute("morphNormal" + M) === !0 && h.deleteAttribute("morphNormal" + M), r[M] = 0) } const _ = h.morphTargetsRelative ? 1 : 1 - A; d.getUniforms().setValue(n, "morphTargetBaseInfluence", _), d.getUniforms().setValue(n, "morphTargetInfluences", r) } } return { update: l } } function q7(n, e, t, i) { let r = new WeakMap; function s(l) { const u = i.render.frame, h = l.geometry, d = e.get(l, h); return r.get(d) !== u && (e.update(d), r.set(d, u)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), d } function o() { r = new WeakMap } function a(l) { const u = l.target; u.removeEventListener("dispose", a), t.remove(u.instanceMatrix), u.instanceColor !== null && t.remove(u.instanceColor) } return { update: s, dispose: o } } const j5 = new Zt, J5 = new B0, X5 = new iA, Q5 = new yh, Dw = [], Fw = [], kw = new Float32Array(16), Nw = new Float32Array(9), Ow = new Float32Array(4); function Kc(n, e, t) { const i = n[0]; if (i <= 0 || i > 0) return n; const r = e * t; let s = Dw[r]; if (s === void 0 && (s = new Float32Array(r), Dw[r] = s), e !== 0) { i.toArray(s, 0); for (let o = 1, a = 0; o !== e; ++o)a += t, n[o].toArray(s, a) } return s } function Rn(n, e) { if (n.length !== e.length) return !1; for (let t = 0, i = n.length; t < i; t++)if (n[t] !== e[t]) return !1; return !0 } function Ln(n, e) { for (let t = 0, i = e.length; t < i; t++)n[t] = e[t] } function R0(n, e) { let t = Fw[e]; t === void 0 && (t = new Int32Array(e), Fw[e] = t); for (let i = 0; i !== e; ++i)t[i] = n.allocateTextureUnit(); return t } function Z7(n, e) { const t = this.cache; t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e) } function $7(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Rn(t, e)) return; n.uniform2fv(this.addr, e), Ln(t, e) } } function eF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (Rn(t, e)) return; n.uniform3fv(this.addr, e), Ln(t, e) } } function tF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Rn(t, e)) return; n.uniform4fv(this.addr, e), Ln(t, e) } } function nF(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (Rn(t, e)) return; n.uniformMatrix2fv(this.addr, !1, e), Ln(t, e) } else { if (Rn(t, i)) return; Ow.set(i), n.uniformMatrix2fv(this.addr, !1, Ow), Ln(t, i) } } function iF(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (Rn(t, e)) return; n.uniformMatrix3fv(this.addr, !1, e), Ln(t, e) } else { if (Rn(t, i)) return; Nw.set(i), n.uniformMatrix3fv(this.addr, !1, Nw), Ln(t, i) } } function rF(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (Rn(t, e)) return; n.uniformMatrix4fv(this.addr, !1, e), Ln(t, e) } else { if (Rn(t, i)) return; kw.set(i), n.uniformMatrix4fv(this.addr, !1, kw), Ln(t, i) } } function sF(n, e) { const t = this.cache; t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e) } function oF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Rn(t, e)) return; n.uniform2iv(this.addr, e), Ln(t, e) } } function aF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (Rn(t, e)) return; n.uniform3iv(this.addr, e), Ln(t, e) } } function lF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Rn(t, e)) return; n.uniform4iv(this.addr, e), Ln(t, e) } } function cF(n, e) { const t = this.cache; t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e) } function uF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Rn(t, e)) return; n.uniform2uiv(this.addr, e), Ln(t, e) } } function fF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (Rn(t, e)) return; n.uniform3uiv(this.addr, e), Ln(t, e) } } function hF(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Rn(t, e)) return; n.uniform4uiv(this.addr, e), Ln(t, e) } } function dF(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2D(e || j5, r) } function pF(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || X5, r) } function mF(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || Q5, r) } function gF(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || J5, r) } function yF(n) { switch (n) { case 5126: return Z7; case 35664: return $7; case 35665: return eF; case 35666: return tF; case 35674: return nF; case 35675: return iF; case 35676: return rF; case 5124: case 35670: return sF; case 35667: case 35671: return oF; case 35668: case 35672: return aF; case 35669: case 35673: return lF; case 5125: return cF; case 36294: return uF; case 36295: return fF; case 36296: return hF; case 35678: case 36198: case 36298: case 36306: case 35682: return dF; case 35679: case 36299: case 36307: return pF; case 35680: case 36300: case 36308: case 36293: return mF; case 36289: case 36303: case 36311: case 36292: return gF } } function vF(n, e) { n.uniform1fv(this.addr, e) } function xF(n, e) { const t = Kc(e, this.size, 2); n.uniform2fv(this.addr, t) } function AF(n, e) { const t = Kc(e, this.size, 3); n.uniform3fv(this.addr, t) } function MF(n, e) { const t = Kc(e, this.size, 4); n.uniform4fv(this.addr, t) } function _F(n, e) { const t = Kc(e, this.size, 4); n.uniformMatrix2fv(this.addr, !1, t) } function wF(n, e) { const t = Kc(e, this.size, 9); n.uniformMatrix3fv(this.addr, !1, t) } function SF(n, e) { const t = Kc(e, this.size, 16); n.uniformMatrix4fv(this.addr, !1, t) } function CF(n, e) { n.uniform1iv(this.addr, e) } function EF(n, e) { n.uniform2iv(this.addr, e) } function bF(n, e) { n.uniform3iv(this.addr, e) } function TF(n, e) { n.uniform4iv(this.addr, e) } function BF(n, e) { n.uniform1uiv(this.addr, e) } function PF(n, e) { n.uniform2uiv(this.addr, e) } function RF(n, e) { n.uniform3uiv(this.addr, e) } function LF(n, e) { n.uniform4uiv(this.addr, e) } function IF(n, e, t) { const i = this.cache, r = e.length, s = R0(t, r); Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s)); for (let o = 0; o !== r; ++o)t.setTexture2D(e[o] || j5, s[o]) } function DF(n, e, t) { const i = this.cache, r = e.length, s = R0(t, r); Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s)); for (let o = 0; o !== r; ++o)t.setTexture3D(e[o] || X5, s[o]) } function FF(n, e, t) { const i = this.cache, r = e.length, s = R0(t, r); Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s)); for (let o = 0; o !== r; ++o)t.setTextureCube(e[o] || Q5, s[o]) } function kF(n, e, t) { const i = this.cache, r = e.length, s = R0(t, r); Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s)); for (let o = 0; o !== r; ++o)t.setTexture2DArray(e[o] || J5, s[o]) } function NF(n) { switch (n) { case 5126: return vF; case 35664: return xF; case 35665: return AF; case 35666: return MF; case 35674: return _F; case 35675: return wF; case 35676: return SF; case 5124: case 35670: return CF; case 35667: case 35671: return EF; case 35668: case 35672: return bF; case 35669: case 35673: return TF; case 5125: return BF; case 36294: return PF; case 36295: return RF; case 36296: return LF; case 35678: case 36198: case 36298: case 36306: case 35682: return IF; case 35679: case 36299: case 36307: return DF; case 35680: case 36300: case 36308: case 36293: return FF; case 36289: case 36303: case 36311: case 36292: return kF } } class OF { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = yF(t.type) } } class zF { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = NF(t.type) } } class UF { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, i) { const r = this.seq; for (let s = 0, o = r.length; s !== o; ++s) { const a = r[s]; a.setValue(e, t[a.id], i) } } } const ny = /(\w+)(\])?(\[|\.)?/g; function zw(n, e) { n.seq.push(e), n.map[e.id] = e } function GF(n, e, t) { const i = n.name, r = i.length; for (ny.lastIndex = 0; ;) { const s = ny.exec(i), o = ny.lastIndex; let a = s[1]; const l = s[2] === "]", u = s[3]; if (l && (a = a | 0), u === void 0 || u === "[" && o + 2 === r) { zw(t, u === void 0 ? new OF(a, n, e) : new zF(a, n, e)); break } else { let d = t.map[a]; d === void 0 && (d = new UF(a), zw(t, d)), t = d } } } class hm { constructor(e, t) { this.seq = [], this.map = {}; const i = e.getProgramParameter(t, 35718); for (let r = 0; r < i; ++r) { const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name); GF(s, o, this) } } setValue(e, t, i, r) { const s = this.map[t]; s !== void 0 && s.setValue(e, i, r) } setOptional(e, t, i) { const r = t[i]; r !== void 0 && this.setValue(e, i, r) } static upload(e, t, i, r) { for (let s = 0, o = t.length; s !== o; ++s) { const a = t[s], l = i[a.id]; l.needsUpdate !== !1 && a.setValue(e, l.value, r) } } static seqWithValue(e, t) { const i = []; for (let r = 0, s = e.length; r !== s; ++r) { const o = e[r]; o.id in t && i.push(o) } return i } } function Uw(n, e, t) { const i = n.createShader(e); return n.shaderSource(i, t), n.compileShader(i), i } let HF = 0; function VF(n, e) {
  const t = n.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length); for (let o = r; o < s; o++) { const a = o + 1; i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`) } return i.join(`
`)
} function WF(n) { switch (n) { case Js: return ["Linear", "( value )"]; case St: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", n), ["Linear", "( value )"] } } function Gw(n, e, t) {
  const i = n.getShaderParameter(e, 35713), r = n.getShaderInfoLog(e).trim(); if (i && r === "") return ""; const s = /ERROR: 0:(\d+)/.exec(r); if (s) {
    const o = parseInt(s[1]); return t.toUpperCase() + `

`+ r + `

`+ VF(n.getShaderSource(e), o)
  } else return r
} function jF(n, e) { const t = WF(e); return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }" } function JF(n, e) { let t; switch (e) { case f5: t = "Linear"; break; case h5: t = "Reinhard"; break; case d5: t = "OptimizedCineon"; break; case Kx: t = "ACESFilmic"; break; case p5: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function XF(n) {
  return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(tf).join(`
`)
} function QF(n) {
  const e = []; for (const t in n) { const i = n[t]; i !== !1 && e.push("#define " + t + " " + i) } return e.join(`
`)
} function KF(n, e) { const t = {}, i = n.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const s = n.getActiveAttrib(e, r), o = s.name; let a = 1; s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = { type: s.type, location: n.getAttribLocation(e, o), locationSize: a } } return t } function tf(n) { return n !== "" } function Hw(n, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Vw(n, e) { return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const YF = /^[ \t]*#include +<([\w\d./]+)>/gm; function m2(n) { return n.replace(YF, qF) } function qF(n, e) { const t = dt[e]; if (t === void 0) throw new Error("Can not resolve #include <" + e + ">"); return m2(t) } const ZF = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ww(n) { return n.replace(ZF, $F) } function $F(n, e, t, i) { let r = ""; for (let s = parseInt(e); s < parseInt(t); s++)r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return r } function jw(n) {
  let e = "precision " + n.precision + ` float;
precision `+ n.precision + " int;"; return n.precision === "highp" ? e += `
#define HIGH_PRECISION`: n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function ek(n) { let e = "SHADOWMAP_TYPE_BASIC"; return n.shadowMapType === C0 ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === df ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Na && (e = "SHADOWMAP_TYPE_VSM"), e } function tk(n) { let e = "ENVMAP_TYPE_CUBE"; if (n.envMap) switch (n.envMapMode) { case Ho: case Vo: e = "ENVMAP_TYPE_CUBE"; break; case Xc: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function nk(n) { let e = "ENVMAP_MODE_REFLECTION"; if (n.envMap) switch (n.envMapMode) { case Vo: e = "ENVMAP_MODE_REFRACTION"; break }return e } function ik(n) { let e = "ENVMAP_BLENDING_NONE"; if (n.envMap) switch (n.combine) { case ph: e = "ENVMAP_BLENDING_MULTIPLY"; break; case c5: e = "ENVMAP_BLENDING_MIX"; break; case u5: e = "ENVMAP_BLENDING_ADD"; break }return e } function rk(n) { const e = n.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, i = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t } } function sk(n, e, t, i) {
  const r = n.getContext(), s = t.defines; let o = t.vertexShader, a = t.fragmentShader; const l = ek(t), u = tk(t), h = nk(t), d = ik(t), p = rk(t), m = t.isWebGL2 ? "" : XF(t), v = QF(s), y = r.createProgram(); let x, A, _ = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (x = [v].filter(tf).join(`
`), x.length > 0 && (x += `
`), A = [m, v].filter(tf).join(`
`), A.length > 0 && (A += `
`)) : (x = [jw(t), "#define SHADER_NAME " + t.shaderName, v, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(tf).join(`
`), A = [m, jw(t), "#define SHADER_NAME " + t.shaderName, v, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Fr ? "#define TONE_MAPPING" : "", t.toneMapping !== Fr ? dt.tonemapping_pars_fragment : "", t.toneMapping !== Fr ? JF("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", dt.encodings_pars_fragment, jF("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(tf).join(`
`)), o = m2(o), o = Hw(o, t), o = Vw(o, t), a = m2(a), a = Hw(a, t), a = Vw(a, t), o = Ww(o), a = Ww(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ x, A = ["#define varying in", t.glslVersion === h2 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === h2 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ A); const M = _ + x + o, S = _ + A + a, b = Uw(r, 35633, M), B = Uw(r, 35632, S); if (r.attachShader(y, b), r.attachShader(y, B), t.index0AttributeName !== void 0 ? r.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), n.debug.checkShaderErrors) {
    const P = r.getProgramInfoLog(y).trim(), L = r.getShaderInfoLog(b).trim(), z = r.getShaderInfoLog(B).trim(); let Z = !0, J = !0; if (r.getProgramParameter(y, 35714) === !1) {
      Z = !1; const V = Gw(r, b, "vertex"), K = Gw(r, B, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + `

Program Info Log: `+ P + `
`+ V + `
`+ K)
    } else P !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", P) : (L === "" || z === "") && (J = !1); J && (this.diagnostics = { runnable: Z, programLog: P, vertexShader: { log: L, prefix: x }, fragmentShader: { log: z, prefix: A } })
  } r.deleteShader(b), r.deleteShader(B); let R; this.getUniforms = function () { return R === void 0 && (R = new hm(r, y)), R }; let E; return this.getAttributes = function () { return E === void 0 && (E = KF(r, y)), E }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = t.shaderName, this.id = HF++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = b, this.fragmentShader = B, this
} let ok = 0; class ak { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e); return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let i = t.get(e); return i === void 0 && (i = new Set, t.set(e, i)), i } _getShaderStage(e) { const t = this.shaderCache; let i = t.get(e); return i === void 0 && (i = new lk(e), t.set(e, i)), i } } class lk { constructor(e) { this.id = ok++, this.code = e, this.usedTimes = 0 } } function ck(n, e, t, i, r, s, o) { const a = new Ka, l = new ak, u = [], h = r.isWebGL2, d = r.logarithmicDepthBuffer, p = r.vertexTextures; let m = r.precision; const v = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function y(E, P, L, z, Z) { const J = z.fog, V = Z.geometry, K = E.isMeshStandardMaterial ? z.environment : null, ee = (E.isMeshStandardMaterial ? t : e).get(E.envMap || K), le = ee && ee.mapping === Xc ? ee.image.height : null, N = v[E.type]; E.precision !== null && (m = r.getMaxPrecision(E.precision), m !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", m, "instead.")); const H = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color, W = H !== void 0 ? H.length : 0; let se = 0; V.morphAttributes.position !== void 0 && (se = 1), V.morphAttributes.normal !== void 0 && (se = 2), V.morphAttributes.color !== void 0 && (se = 3); let j, oe, ve, q; if (N) { const be = Rr[N]; j = be.vertexShader, oe = be.fragmentShader } else j = E.vertexShader, oe = E.fragmentShader, l.update(E), ve = l.getVertexShaderID(E), q = l.getFragmentShaderID(E); const Te = n.getRenderTarget(), Se = E.alphaTest > 0, Fe = E.clearcoat > 0, ze = E.iridescence > 0; return { isWebGL2: h, shaderID: N, shaderName: E.type, vertexShader: j, fragmentShader: oe, defines: E.defines, customVertexShaderID: ve, customFragmentShaderID: q, isRawShaderMaterial: E.isRawShaderMaterial === !0, glslVersion: E.glslVersion, precision: m, instancing: Z.isInstancedMesh === !0, instancingColor: Z.isInstancedMesh === !0 && Z.instanceColor !== null, supportsVertexTextures: p, outputEncoding: Te === null ? n.outputEncoding : Te.isXRRenderTarget === !0 ? Te.texture.encoding : Js, map: !!E.map, matcap: !!E.matcap, envMap: !!ee, envMapMode: ee && ee.mapping, envMapCubeUVHeight: le, lightMap: !!E.lightMap, aoMap: !!E.aoMap, emissiveMap: !!E.emissiveMap, bumpMap: !!E.bumpMap, normalMap: !!E.normalMap, objectSpaceNormalMap: E.normalMapType === k5, tangentSpaceNormalMap: E.normalMapType === Ks, decodeVideoTexture: !!E.map && E.map.isVideoTexture === !0 && E.map.encoding === St, clearcoat: Fe, clearcoatMap: Fe && !!E.clearcoatMap, clearcoatRoughnessMap: Fe && !!E.clearcoatRoughnessMap, clearcoatNormalMap: Fe && !!E.clearcoatNormalMap, iridescence: ze, iridescenceMap: ze && !!E.iridescenceMap, iridescenceThicknessMap: ze && !!E.iridescenceThicknessMap, displacementMap: !!E.displacementMap, roughnessMap: !!E.roughnessMap, metalnessMap: !!E.metalnessMap, specularMap: !!E.specularMap, specularIntensityMap: !!E.specularIntensityMap, specularColorMap: !!E.specularColorMap, opaque: E.transparent === !1 && E.blending === ja, alphaMap: !!E.alphaMap, alphaTest: Se, gradientMap: !!E.gradientMap, sheen: E.sheen > 0, sheenColorMap: !!E.sheenColorMap, sheenRoughnessMap: !!E.sheenRoughnessMap, transmission: E.transmission > 0, transmissionMap: !!E.transmissionMap, thicknessMap: !!E.thicknessMap, combine: E.combine, vertexTangents: !!E.normalMap && !!V.attributes.tangent, vertexColors: E.vertexColors, vertexAlphas: E.vertexColors === !0 && !!V.attributes.color && V.attributes.color.itemSize === 4, vertexUvs: !!E.map || !!E.bumpMap || !!E.normalMap || !!E.specularMap || !!E.alphaMap || !!E.emissiveMap || !!E.roughnessMap || !!E.metalnessMap || !!E.clearcoatMap || !!E.clearcoatRoughnessMap || !!E.clearcoatNormalMap || !!E.iridescenceMap || !!E.iridescenceThicknessMap || !!E.displacementMap || !!E.transmissionMap || !!E.thicknessMap || !!E.specularIntensityMap || !!E.specularColorMap || !!E.sheenColorMap || !!E.sheenRoughnessMap, uvsVertexOnly: !(E.map || E.bumpMap || E.normalMap || E.specularMap || E.alphaMap || E.emissiveMap || E.roughnessMap || E.metalnessMap || E.clearcoatNormalMap || E.iridescenceMap || E.iridescenceThicknessMap || E.transmission > 0 || E.transmissionMap || E.thicknessMap || E.specularIntensityMap || E.specularColorMap || E.sheen > 0 || E.sheenColorMap || E.sheenRoughnessMap) && !!E.displacementMap, fog: !!J, useFog: E.fog === !0, fogExp2: J && J.isFogExp2, flatShading: !!E.flatShading, sizeAttenuation: E.sizeAttenuation, logarithmicDepthBuffer: d, skinning: Z.isSkinnedMesh === !0, morphTargets: V.morphAttributes.position !== void 0, morphNormals: V.morphAttributes.normal !== void 0, morphColors: V.morphAttributes.color !== void 0, morphTargetsCount: W, morphTextureStride: se, numDirLights: P.directional.length, numPointLights: P.point.length, numSpotLights: P.spot.length, numSpotLightMaps: P.spotLightMap.length, numRectAreaLights: P.rectArea.length, numHemiLights: P.hemi.length, numDirLightShadows: P.directionalShadowMap.length, numPointLightShadows: P.pointShadowMap.length, numSpotLightShadows: P.spotShadowMap.length, numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: E.dithering, shadowMapEnabled: n.shadowMap.enabled && L.length > 0, shadowMapType: n.shadowMap.type, toneMapping: E.toneMapped ? n.toneMapping : Fr, useLegacyLights: n.useLegacyLights, premultipliedAlpha: E.premultipliedAlpha, doubleSided: E.side === Lr, flipSided: E.side === Bi, useDepthPacking: !!E.depthPacking, depthPacking: E.depthPacking || 0, index0AttributeName: E.index0AttributeName, extensionDerivatives: E.extensions && E.extensions.derivatives, extensionFragDepth: E.extensions && E.extensions.fragDepth, extensionDrawBuffers: E.extensions && E.extensions.drawBuffers, extensionShaderTextureLOD: E.extensions && E.extensions.shaderTextureLOD, rendererExtensionFragDepth: h || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"), customProgramCacheKey: E.customProgramCacheKey() } } function x(E) { const P = []; if (E.shaderID ? P.push(E.shaderID) : (P.push(E.customVertexShaderID), P.push(E.customFragmentShaderID)), E.defines !== void 0) for (const L in E.defines) P.push(L), P.push(E.defines[L]); return E.isRawShaderMaterial === !1 && (A(P, E), _(P, E), P.push(n.outputEncoding)), P.push(E.customProgramCacheKey), P.join() } function A(E, P) { E.push(P.precision), E.push(P.outputEncoding), E.push(P.envMapMode), E.push(P.envMapCubeUVHeight), E.push(P.combine), E.push(P.vertexUvs), E.push(P.fogExp2), E.push(P.sizeAttenuation), E.push(P.morphTargetsCount), E.push(P.morphAttributeCount), E.push(P.numDirLights), E.push(P.numPointLights), E.push(P.numSpotLights), E.push(P.numSpotLightMaps), E.push(P.numHemiLights), E.push(P.numRectAreaLights), E.push(P.numDirLightShadows), E.push(P.numPointLightShadows), E.push(P.numSpotLightShadows), E.push(P.numSpotLightShadowsWithMaps), E.push(P.shadowMapType), E.push(P.toneMapping), E.push(P.numClippingPlanes), E.push(P.numClipIntersection), E.push(P.depthPacking) } function _(E, P) { a.disableAll(), P.isWebGL2 && a.enable(0), P.supportsVertexTextures && a.enable(1), P.instancing && a.enable(2), P.instancingColor && a.enable(3), P.map && a.enable(4), P.matcap && a.enable(5), P.envMap && a.enable(6), P.lightMap && a.enable(7), P.aoMap && a.enable(8), P.emissiveMap && a.enable(9), P.bumpMap && a.enable(10), P.normalMap && a.enable(11), P.objectSpaceNormalMap && a.enable(12), P.tangentSpaceNormalMap && a.enable(13), P.clearcoat && a.enable(14), P.clearcoatMap && a.enable(15), P.clearcoatRoughnessMap && a.enable(16), P.clearcoatNormalMap && a.enable(17), P.iridescence && a.enable(18), P.iridescenceMap && a.enable(19), P.iridescenceThicknessMap && a.enable(20), P.displacementMap && a.enable(21), P.specularMap && a.enable(22), P.roughnessMap && a.enable(23), P.metalnessMap && a.enable(24), P.gradientMap && a.enable(25), P.alphaMap && a.enable(26), P.alphaTest && a.enable(27), P.vertexColors && a.enable(28), P.vertexAlphas && a.enable(29), P.vertexUvs && a.enable(30), P.vertexTangents && a.enable(31), P.uvsVertexOnly && a.enable(32), E.push(a.mask), a.disableAll(), P.fog && a.enable(0), P.useFog && a.enable(1), P.flatShading && a.enable(2), P.logarithmicDepthBuffer && a.enable(3), P.skinning && a.enable(4), P.morphTargets && a.enable(5), P.morphNormals && a.enable(6), P.morphColors && a.enable(7), P.premultipliedAlpha && a.enable(8), P.shadowMapEnabled && a.enable(9), P.useLegacyLights && a.enable(10), P.doubleSided && a.enable(11), P.flipSided && a.enable(12), P.useDepthPacking && a.enable(13), P.dithering && a.enable(14), P.specularIntensityMap && a.enable(15), P.specularColorMap && a.enable(16), P.transmission && a.enable(17), P.transmissionMap && a.enable(18), P.thicknessMap && a.enable(19), P.sheen && a.enable(20), P.sheenColorMap && a.enable(21), P.sheenRoughnessMap && a.enable(22), P.decodeVideoTexture && a.enable(23), P.opaque && a.enable(24), E.push(a.mask) } function M(E) { const P = v[E.type]; let L; if (P) { const z = Rr[P]; L = V5.clone(z.uniforms) } else L = E.uniforms; return L } function S(E, P) { let L; for (let z = 0, Z = u.length; z < Z; z++) { const J = u[z]; if (J.cacheKey === P) { L = J, ++L.usedTimes; break } } return L === void 0 && (L = new sk(n, P, E, s), u.push(L)), L } function b(E) { if (--E.usedTimes === 0) { const P = u.indexOf(E); u[P] = u[u.length - 1], u.pop(), E.destroy() } } function B(E) { l.remove(E) } function R() { l.dispose() } return { getParameters: y, getProgramCacheKey: x, getUniforms: M, acquireProgram: S, releaseProgram: b, releaseShaderCache: B, programs: u, dispose: R } } function uk() { let n = new WeakMap; function e(s) { let o = n.get(s); return o === void 0 && (o = {}, n.set(s, o)), o } function t(s) { n.delete(s) } function i(s, o, a) { n.get(s)[o] = a } function r() { n = new WeakMap } return { get: e, remove: t, update: i, dispose: r } } function fk(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id } function Jw(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id } function Xw() { const n = []; let e = 0; const t = [], i = [], r = []; function s() { e = 0, t.length = 0, i.length = 0, r.length = 0 } function o(d, p, m, v, y, x) { let A = n[e]; return A === void 0 ? (A = { id: d.id, object: d, geometry: p, material: m, groupOrder: v, renderOrder: d.renderOrder, z: y, group: x }, n[e] = A) : (A.id = d.id, A.object = d, A.geometry = p, A.material = m, A.groupOrder = v, A.renderOrder = d.renderOrder, A.z = y, A.group = x), e++, A } function a(d, p, m, v, y, x) { const A = o(d, p, m, v, y, x); m.transmission > 0 ? i.push(A) : m.transparent === !0 ? r.push(A) : t.push(A) } function l(d, p, m, v, y, x) { const A = o(d, p, m, v, y, x); m.transmission > 0 ? i.unshift(A) : m.transparent === !0 ? r.unshift(A) : t.unshift(A) } function u(d, p) { t.length > 1 && t.sort(d || fk), i.length > 1 && i.sort(p || Jw), r.length > 1 && r.sort(p || Jw) } function h() { for (let d = e, p = n.length; d < p; d++) { const m = n[d]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: t, transmissive: i, transparent: r, init: s, push: a, unshift: l, finish: h, sort: u } } function hk() { let n = new WeakMap; function e(i, r) { const s = n.get(i); let o; return s === void 0 ? (o = new Xw, n.set(i, [o])) : r >= s.length ? (o = new Xw, s.push(o)) : o = s[r], o } function t() { n = new WeakMap } return { get: e, dispose: t } } function dk() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new D, color: new Re }; break; case "SpotLight": t = { position: new D, direction: new D, color: new Re, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new D, color: new Re, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new D, skyColor: new Re, groundColor: new Re }; break; case "RectAreaLight": t = { color: new Re, position: new D, halfWidth: new D, halfHeight: new D }; break }return n[e.id] = t, t } } } function pk() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return n[e.id] = t, t } } } let mk = 0; function gk(n, e) { return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0) } function yk(n, e) { const t = new dk, i = pk(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let h = 0; h < 9; h++)r.probe.push(new D); const s = new D, o = new st, a = new st; function l(h, d) { let p = 0, m = 0, v = 0; for (let z = 0; z < 9; z++)r.probe[z].set(0, 0, 0); let y = 0, x = 0, A = 0, _ = 0, M = 0, S = 0, b = 0, B = 0, R = 0, E = 0; h.sort(gk); const P = d === !0 ? Math.PI : 1; for (let z = 0, Z = h.length; z < Z; z++) { const J = h[z], V = J.color, K = J.intensity, ee = J.distance, le = J.shadow && J.shadow.map ? J.shadow.map.texture : null; if (J.isAmbientLight) p += V.r * K * P, m += V.g * K * P, v += V.b * K * P; else if (J.isLightProbe) for (let N = 0; N < 9; N++)r.probe[N].addScaledVector(J.sh.coefficients[N], K); else if (J.isDirectionalLight) { const N = t.get(J); if (N.color.copy(J.color).multiplyScalar(J.intensity * P), J.castShadow) { const H = J.shadow, W = i.get(J); W.shadowBias = H.bias, W.shadowNormalBias = H.normalBias, W.shadowRadius = H.radius, W.shadowMapSize = H.mapSize, r.directionalShadow[y] = W, r.directionalShadowMap[y] = le, r.directionalShadowMatrix[y] = J.shadow.matrix, S++ } r.directional[y] = N, y++ } else if (J.isSpotLight) { const N = t.get(J); N.position.setFromMatrixPosition(J.matrixWorld), N.color.copy(V).multiplyScalar(K * P), N.distance = ee, N.coneCos = Math.cos(J.angle), N.penumbraCos = Math.cos(J.angle * (1 - J.penumbra)), N.decay = J.decay, r.spot[A] = N; const H = J.shadow; if (J.map && (r.spotLightMap[R] = J.map, R++, H.updateMatrices(J), J.castShadow && E++), r.spotLightMatrix[A] = H.matrix, J.castShadow) { const W = i.get(J); W.shadowBias = H.bias, W.shadowNormalBias = H.normalBias, W.shadowRadius = H.radius, W.shadowMapSize = H.mapSize, r.spotShadow[A] = W, r.spotShadowMap[A] = le, B++ } A++ } else if (J.isRectAreaLight) { const N = t.get(J); N.color.copy(V).multiplyScalar(K), N.halfWidth.set(J.width * .5, 0, 0), N.halfHeight.set(0, J.height * .5, 0), r.rectArea[_] = N, _++ } else if (J.isPointLight) { const N = t.get(J); if (N.color.copy(J.color).multiplyScalar(J.intensity * P), N.distance = J.distance, N.decay = J.decay, J.castShadow) { const H = J.shadow, W = i.get(J); W.shadowBias = H.bias, W.shadowNormalBias = H.normalBias, W.shadowRadius = H.radius, W.shadowMapSize = H.mapSize, W.shadowCameraNear = H.camera.near, W.shadowCameraFar = H.camera.far, r.pointShadow[x] = W, r.pointShadowMap[x] = le, r.pointShadowMatrix[x] = J.shadow.matrix, b++ } r.point[x] = N, x++ } else if (J.isHemisphereLight) { const N = t.get(J); N.skyColor.copy(J.color).multiplyScalar(K * P), N.groundColor.copy(J.groundColor).multiplyScalar(K * P), r.hemi[M] = N, M++ } } _ > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = De.LTC_FLOAT_1, r.rectAreaLTC2 = De.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = De.LTC_HALF_1, r.rectAreaLTC2 = De.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = m, r.ambient[2] = v; const L = r.hash; (L.directionalLength !== y || L.pointLength !== x || L.spotLength !== A || L.rectAreaLength !== _ || L.hemiLength !== M || L.numDirectionalShadows !== S || L.numPointShadows !== b || L.numSpotShadows !== B || L.numSpotMaps !== R) && (r.directional.length = y, r.spot.length = A, r.rectArea.length = _, r.point.length = x, r.hemi.length = M, r.directionalShadow.length = S, r.directionalShadowMap.length = S, r.pointShadow.length = b, r.pointShadowMap.length = b, r.spotShadow.length = B, r.spotShadowMap.length = B, r.directionalShadowMatrix.length = S, r.pointShadowMatrix.length = b, r.spotLightMatrix.length = B + R - E, r.spotLightMap.length = R, r.numSpotLightShadowsWithMaps = E, L.directionalLength = y, L.pointLength = x, L.spotLength = A, L.rectAreaLength = _, L.hemiLength = M, L.numDirectionalShadows = S, L.numPointShadows = b, L.numSpotShadows = B, L.numSpotMaps = R, r.version = mk++) } function u(h, d) { let p = 0, m = 0, v = 0, y = 0, x = 0; const A = d.matrixWorldInverse; for (let _ = 0, M = h.length; _ < M; _++) { const S = h[_]; if (S.isDirectionalLight) { const b = r.directional[p]; b.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(A), p++ } else if (S.isSpotLight) { const b = r.spot[v]; b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(A), b.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(s), b.direction.transformDirection(A), v++ } else if (S.isRectAreaLight) { const b = r.rectArea[y]; b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(A), a.identity(), o.copy(S.matrixWorld), o.premultiply(A), a.extractRotation(o), b.halfWidth.set(S.width * .5, 0, 0), b.halfHeight.set(0, S.height * .5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), y++ } else if (S.isPointLight) { const b = r.point[m]; b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(A), m++ } else if (S.isHemisphereLight) { const b = r.hemi[x]; b.direction.setFromMatrixPosition(S.matrixWorld), b.direction.transformDirection(A), x++ } } } return { setup: l, setupView: u, state: r } } function Qw(n, e) { const t = new yk(n, e), i = [], r = []; function s() { i.length = 0, r.length = 0 } function o(d) { i.push(d) } function a(d) { r.push(d) } function l(d) { t.setup(i, d) } function u(d) { t.setupView(i, d) } return { init: s, state: { lightsArray: i, shadowsArray: r, lights: t }, setupLights: l, setupLightsView: u, pushLight: o, pushShadow: a } } function vk(n, e) { let t = new WeakMap; function i(s, o = 0) { const a = t.get(s); let l; return a === void 0 ? (l = new Qw(n, e), t.set(s, [l])) : o >= a.length ? (l = new Qw(n, e), a.push(l)) : l = a[o], l } function r() { t = new WeakMap } return { get: i, dispose: r } } class cA extends En { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = D5, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class uA extends En { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new D, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const xk = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Ak = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function Mk(n, e, t) { let i = new P0; const r = new me, s = new me, o = new Ft, a = new cA({ depthPacking: F5 }), l = new uA, u = {}, h = t.maxTextureSize, d = { [as]: Bi, [Bi]: as, [Lr]: Lr }, p = new cs({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new me }, radius: { value: 4 } }, vertexShader: xk, fragmentShader: Ak }), m = p.clone(); m.defines.HORIZONTAL_PASS = 1; const v = new ut; v.setAttribute("position", new It(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const y = new Pn(v, p), x = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = C0, this.render = function (S, b, B) { if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || S.length === 0) return; const R = n.getRenderTarget(), E = n.getActiveCubeFace(), P = n.getActiveMipmapLevel(), L = n.state; L.setBlending(Os), L.buffers.color.setClear(1, 1, 1, 1), L.buffers.depth.setTest(!0), L.setScissorTest(!1); for (let z = 0, Z = S.length; z < Z; z++) { const J = S[z], V = J.shadow; if (V === void 0) { console.warn("THREE.WebGLShadowMap:", J, "has no shadow."); continue } if (V.autoUpdate === !1 && V.needsUpdate === !1) continue; r.copy(V.mapSize); const K = V.getFrameExtents(); if (r.multiply(K), s.copy(V.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / K.x), r.x = s.x * K.x, V.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / K.y), r.y = s.y * K.y, V.mapSize.y = s.y)), V.map === null) { const le = this.type !== Na ? { minFilter: pn, magFilter: pn } : {}; V.map = new Or(r.x, r.y, le), V.map.texture.name = J.name + ".shadowMap", V.camera.updateProjectionMatrix() } n.setRenderTarget(V.map), n.clear(); const ee = V.getViewportCount(); for (let le = 0; le < ee; le++) { const N = V.getViewport(le); o.set(s.x * N.x, s.y * N.y, s.x * N.z, s.y * N.w), L.viewport(o), V.updateMatrices(J, le), i = V.getFrustum(), M(b, B, V.camera, J, this.type) } V.isPointLightShadow !== !0 && this.type === Na && A(V, B), V.needsUpdate = !1 } x.needsUpdate = !1, n.setRenderTarget(R, E, P) }; function A(S, b) { const B = e.update(y); p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples, m.defines.VSM_SAMPLES = S.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), S.mapPass === null && (S.mapPass = new Or(r.x, r.y)), p.uniforms.shadow_pass.value = S.map.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, n.setRenderTarget(S.mapPass), n.clear(), n.renderBufferDirect(b, null, B, p, y, null), m.uniforms.shadow_pass.value = S.mapPass.texture, m.uniforms.resolution.value = S.mapSize, m.uniforms.radius.value = S.radius, n.setRenderTarget(S.map), n.clear(), n.renderBufferDirect(b, null, B, m, y, null) } function _(S, b, B, R, E, P) { let L = null; const z = B.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial; if (z !== void 0) L = z; else if (L = B.isPointLight === !0 ? l : a, n.localClippingEnabled && b.clipShadows === !0 && Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 || b.displacementMap && b.displacementScale !== 0 || b.alphaMap && b.alphaTest > 0 || b.map && b.alphaTest > 0) { const Z = L.uuid, J = b.uuid; let V = u[Z]; V === void 0 && (V = {}, u[Z] = V); let K = V[J]; K === void 0 && (K = L.clone(), V[J] = K), L = K } return L.visible = b.visible, L.wireframe = b.wireframe, P === Na ? L.side = b.shadowSide !== null ? b.shadowSide : b.side : L.side = b.shadowSide !== null ? b.shadowSide : d[b.side], L.alphaMap = b.alphaMap, L.alphaTest = b.alphaTest, L.map = b.map, L.clipShadows = b.clipShadows, L.clippingPlanes = b.clippingPlanes, L.clipIntersection = b.clipIntersection, L.displacementMap = b.displacementMap, L.displacementScale = b.displacementScale, L.displacementBias = b.displacementBias, L.wireframeLinewidth = b.wireframeLinewidth, L.linewidth = b.linewidth, B.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (L.referencePosition.setFromMatrixPosition(B.matrixWorld), L.nearDistance = R, L.farDistance = E), L } function M(S, b, B, R, E) { if (S.visible === !1) return; if (S.layers.test(b.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && E === Na) && (!S.frustumCulled || i.intersectsObject(S))) { S.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, S.matrixWorld); const z = e.update(S), Z = S.material; if (Array.isArray(Z)) { const J = z.groups; for (let V = 0, K = J.length; V < K; V++) { const ee = J[V], le = Z[ee.materialIndex]; if (le && le.visible) { const N = _(S, le, R, B.near, B.far, E); n.renderBufferDirect(B, null, z, N, S, ee) } } } else if (Z.visible) { const J = _(S, Z, R, B.near, B.far, E); n.renderBufferDirect(B, null, z, J, S, null) } } const L = S.children; for (let z = 0, Z = L.length; z < Z; z++)M(L[z], b, B, R, E) } } function _k(n, e, t) { const i = t.isWebGL2; function r() { let X = !1; const ae = new Ft; let xe = null; const Ue = new Ft(0, 0, 0, 0); return { setMask: function (Je) { xe !== Je && !X && (n.colorMask(Je, Je, Je, Je), xe = Je) }, setLocked: function (Je) { X = Je }, setClear: function (Je, Nt, mn, zn, Ri) { Ri === !0 && (Je *= zn, Nt *= zn, mn *= zn), ae.set(Je, Nt, mn, zn), Ue.equals(ae) === !1 && (n.clearColor(Je, Nt, mn, zn), Ue.copy(ae)) }, reset: function () { X = !1, xe = null, Ue.set(-1, 0, 0, 0) } } } function s() { let X = !1, ae = null, xe = null, Ue = null; return { setTest: function (Je) { Je ? Se(2929) : Fe(2929) }, setMask: function (Je) { ae !== Je && !X && (n.depthMask(Je), ae = Je) }, setFunc: function (Je) { if (xe !== Je) { switch (Je) { case n5: n.depthFunc(512); break; case i5: n.depthFunc(519); break; case r5: n.depthFunc(513); break; case Hm: n.depthFunc(515); break; case s5: n.depthFunc(514); break; case o5: n.depthFunc(518); break; case a5: n.depthFunc(516); break; case l5: n.depthFunc(517); break; default: n.depthFunc(515) }xe = Je } }, setLocked: function (Je) { X = Je }, setClear: function (Je) { Ue !== Je && (n.clearDepth(Je), Ue = Je) }, reset: function () { X = !1, ae = null, xe = null, Ue = null } } } function o() { let X = !1, ae = null, xe = null, Ue = null, Je = null, Nt = null, mn = null, zn = null, Ri = null; return { setTest: function (Jt) { X || (Jt ? Se(2960) : Fe(2960)) }, setMask: function (Jt) { ae !== Jt && !X && (n.stencilMask(Jt), ae = Jt) }, setFunc: function (Jt, ai, Yi) { (xe !== Jt || Ue !== ai || Je !== Yi) && (n.stencilFunc(Jt, ai, Yi), xe = Jt, Ue = ai, Je = Yi) }, setOp: function (Jt, ai, Yi) { (Nt !== Jt || mn !== ai || zn !== Yi) && (n.stencilOp(Jt, ai, Yi), Nt = Jt, mn = ai, zn = Yi) }, setLocked: function (Jt) { X = Jt }, setClear: function (Jt) { Ri !== Jt && (n.clearStencil(Jt), Ri = Jt) }, reset: function () { X = !1, ae = null, xe = null, Ue = null, Je = null, Nt = null, mn = null, zn = null, Ri = null } } } const a = new r, l = new s, u = new o, h = new WeakMap, d = new WeakMap; let p = {}, m = {}, v = new WeakMap, y = [], x = null, A = !1, _ = null, M = null, S = null, b = null, B = null, R = null, E = null, P = !1, L = null, z = null, Z = null, J = null, V = null; const K = n.getParameter(35661); let ee = !1, le = 0; const N = n.getParameter(7938); N.indexOf("WebGL") !== -1 ? (le = parseFloat(/^WebGL (\d)/.exec(N)[1]), ee = le >= 1) : N.indexOf("OpenGL ES") !== -1 && (le = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]), ee = le >= 2); let H = null, W = {}; const se = n.getParameter(3088), j = n.getParameter(2978), oe = new Ft().fromArray(se), ve = new Ft().fromArray(j); function q(X, ae, xe) { const Ue = new Uint8Array(4), Je = n.createTexture(); n.bindTexture(X, Je), n.texParameteri(X, 10241, 9728), n.texParameteri(X, 10240, 9728); for (let Nt = 0; Nt < xe; Nt++)n.texImage2D(ae + Nt, 0, 6408, 1, 1, 0, 6408, 5121, Ue); return Je } const Te = {}; Te[3553] = q(3553, 3553, 1), Te[34067] = q(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), Se(2929), l.setFunc(Hm), Ie(!1), Qe(Nv), Se(2884), _e(Os); function Se(X) { p[X] !== !0 && (n.enable(X), p[X] = !0) } function Fe(X) { p[X] !== !1 && (n.disable(X), p[X] = !1) } function ze(X, ae) { return m[X] !== ae ? (n.bindFramebuffer(X, ae), m[X] = ae, i && (X === 36009 && (m[36160] = ae), X === 36160 && (m[36009] = ae)), !0) : !1 } function Le(X, ae) { let xe = y, Ue = !1; if (X) if (xe = v.get(ae), xe === void 0 && (xe = [], v.set(ae, xe)), X.isWebGLMultipleRenderTargets) { const Je = X.texture; if (xe.length !== Je.length || xe[0] !== 36064) { for (let Nt = 0, mn = Je.length; Nt < mn; Nt++)xe[Nt] = 36064 + Nt; xe.length = Je.length, Ue = !0 } } else xe[0] !== 36064 && (xe[0] = 36064, Ue = !0); else xe[0] !== 1029 && (xe[0] = 1029, Ue = !0); Ue && (t.isWebGL2 ? n.drawBuffers(xe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe)) } function be(X) { return x !== X ? (n.useProgram(X), x = X, !0) : !1 } const de = { [Ra]: 32774, [jb]: 32778, [Jb]: 32779 }; if (i) de[Gv] = 32775, de[Hv] = 32776; else { const X = e.get("EXT_blend_minmax"); X !== null && (de[Gv] = X.MIN_EXT, de[Hv] = X.MAX_EXT) } const pe = { [Xb]: 0, [Qb]: 1, [Kb]: 768, [Xx]: 770, [t5]: 776, [$b]: 774, [qb]: 772, [Yb]: 769, [Qx]: 771, [e5]: 775, [Zb]: 773 }; function _e(X, ae, xe, Ue, Je, Nt, mn, zn) { if (X === Os) { A === !0 && (Fe(3042), A = !1); return } if (A === !1 && (Se(3042), A = !0), X !== Wb) { if (X !== _ || zn !== P) { if ((M !== Ra || B !== Ra) && (n.blendEquation(32774), M = Ra, B = Ra), zn) switch (X) { case ja: n.blendFuncSeparate(1, 771, 1, 771); break; case Ov: n.blendFunc(1, 1); break; case zv: n.blendFuncSeparate(0, 769, 0, 1); break; case Uv: n.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", X); break } else switch (X) { case ja: n.blendFuncSeparate(770, 771, 1, 771); break; case Ov: n.blendFunc(770, 1); break; case zv: n.blendFuncSeparate(0, 769, 0, 1); break; case Uv: n.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", X); break }S = null, b = null, R = null, E = null, _ = X, P = zn } return } Je = Je || ae, Nt = Nt || xe, mn = mn || Ue, (ae !== M || Je !== B) && (n.blendEquationSeparate(de[ae], de[Je]), M = ae, B = Je), (xe !== S || Ue !== b || Nt !== R || mn !== E) && (n.blendFuncSeparate(pe[xe], pe[Ue], pe[Nt], pe[mn]), S = xe, b = Ue, R = Nt, E = mn), _ = X, P = !1 } function Ve(X, ae) { X.side === Lr ? Fe(2884) : Se(2884); let xe = X.side === Bi; ae && (xe = !xe), Ie(xe), X.blending === ja && X.transparent === !1 ? _e(Os) : _e(X.blending, X.blendEquation, X.blendSrc, X.blendDst, X.blendEquationAlpha, X.blendSrcAlpha, X.blendDstAlpha, X.premultipliedAlpha), l.setFunc(X.depthFunc), l.setTest(X.depthTest), l.setMask(X.depthWrite), a.setMask(X.colorWrite); const Ue = X.stencilWrite; u.setTest(Ue), Ue && (u.setMask(X.stencilWriteMask), u.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask), u.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)), Ze(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits), X.alphaToCoverage === !0 ? Se(32926) : Fe(32926) } function Ie(X) { L !== X && (X ? n.frontFace(2304) : n.frontFace(2305), L = X) } function Qe(X) { X !== Gb ? (Se(2884), X !== z && (X === Nv ? n.cullFace(1029) : X === Hb ? n.cullFace(1028) : n.cullFace(1032))) : Fe(2884), z = X } function Xe(X) { X !== Z && (ee && n.lineWidth(X), Z = X) } function Ze(X, ae, xe) { X ? (Se(32823), (J !== ae || V !== xe) && (n.polygonOffset(ae, xe), J = ae, V = xe)) : Fe(32823) } function gt(X) { X ? Se(3089) : Fe(3089) } function wt(X) { X === void 0 && (X = 33984 + K - 1), H !== X && (n.activeTexture(X), H = X) } function O(X, ae, xe) { xe === void 0 && (H === null ? xe = 33984 + K - 1 : xe = H); let Ue = W[xe]; Ue === void 0 && (Ue = { type: void 0, texture: void 0 }, W[xe] = Ue), (Ue.type !== X || Ue.texture !== ae) && (H !== xe && (n.activeTexture(xe), H = xe), n.bindTexture(X, ae || Te[X]), Ue.type = X, Ue.texture = ae) } function I() { const X = W[H]; X !== void 0 && X.type !== void 0 && (n.bindTexture(X.type, null), X.type = void 0, X.texture = void 0) } function ie() { try { n.compressedTexImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function we() { try { n.compressedTexImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Ce() { try { n.texSubImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Pe() { try { n.texSubImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Ye() { try { n.compressedTexSubImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Oe() { try { n.compressedTexSubImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function ye() { try { n.texStorage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function $e() { try { n.texStorage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function G() { try { n.texImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function he() { try { n.texImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Ae(X) { oe.equals(X) === !1 && (n.scissor(X.x, X.y, X.z, X.w), oe.copy(X)) } function Be(X) { ve.equals(X) === !1 && (n.viewport(X.x, X.y, X.z, X.w), ve.copy(X)) } function tt(X, ae) { let xe = d.get(ae); xe === void 0 && (xe = new WeakMap, d.set(ae, xe)); let Ue = xe.get(X); Ue === void 0 && (Ue = n.getUniformBlockIndex(ae, X.name), xe.set(X, Ue)) } function vt(X, ae) { const Ue = d.get(ae).get(X); h.get(ae) !== Ue && (n.uniformBlockBinding(ae, Ue, X.__bindingPointIndex), h.set(ae, Ue)) } function Ht() { n.disable(3042), n.disable(2884), n.disable(2929), n.disable(32823), n.disable(3089), n.disable(2960), n.disable(32926), n.blendEquation(32774), n.blendFunc(1, 0), n.blendFuncSeparate(1, 0, 1, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(513), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(519, 0, 4294967295), n.stencilOp(7680, 7680, 7680), n.clearStencil(0), n.cullFace(1029), n.frontFace(2305), n.polygonOffset(0, 0), n.activeTexture(33984), n.bindFramebuffer(36160, null), i === !0 && (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), p = {}, H = null, W = {}, m = {}, v = new WeakMap, y = [], x = null, A = !1, _ = null, M = null, S = null, b = null, B = null, R = null, E = null, P = !1, L = null, z = null, Z = null, J = null, V = null, oe.set(0, 0, n.canvas.width, n.canvas.height), ve.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), u.reset() } return { buffers: { color: a, depth: l, stencil: u }, enable: Se, disable: Fe, bindFramebuffer: ze, drawBuffers: Le, useProgram: be, setBlending: _e, setMaterial: Ve, setFlipSided: Ie, setCullFace: Qe, setLineWidth: Xe, setPolygonOffset: Ze, setScissorTest: gt, activeTexture: wt, bindTexture: O, unbindTexture: I, compressedTexImage2D: ie, compressedTexImage3D: we, texImage2D: G, texImage3D: he, updateUBOMapping: tt, uniformBlockBinding: vt, texStorage2D: ye, texStorage3D: $e, texSubImage2D: Ce, texSubImage3D: Pe, compressedTexSubImage2D: Ye, compressedTexSubImage3D: Oe, scissor: Ae, viewport: Be, reset: Ht } } function wk(n, e, t, i, r, s, o) { const a = r.isWebGL2, l = r.maxTextures, u = r.maxCubemapSize, h = r.maxTextureSize, d = r.maxSamples, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), v = new WeakMap; let y; const x = new WeakMap; let A = !1; try { A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function _(O, I) { return A ? new OffscreenCanvas(O, I) : Qf("canvas") } function M(O, I, ie, we) { let Ce = 1; if ((O.width > we || O.height > we) && (Ce = we / Math.max(O.width, O.height)), Ce < 1 || I === !0) if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap) { const Pe = I ? z5 : Math.floor, Ye = Pe(Ce * O.width), Oe = Pe(Ce * O.height); y === void 0 && (y = _(Ye, Oe)); const ye = ie ? _(Ye, Oe) : y; return ye.width = Ye, ye.height = Oe, ye.getContext("2d").drawImage(O, 0, 0, Ye, Oe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + Ye + "x" + Oe + ")."), ye } else return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."), O; return O } function S(O) { return d2(O.width) && d2(O.height) } function b(O) { return a ? !1 : O.wrapS !== Hn || O.wrapT !== Hn || O.minFilter !== pn && O.minFilter !== tn } function B(O, I) { return O.generateMipmaps && I && O.minFilter !== pn && O.minFilter !== tn } function R(O) { n.generateMipmap(O) } function E(O, I, ie, we, Ce = !1) { if (a === !1) return I; if (O !== null) { if (n[O] !== void 0) return n[O]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'") } let Pe = I; return I === 6403 && (ie === 5126 && (Pe = 33326), ie === 5131 && (Pe = 33325), ie === 5121 && (Pe = 33321)), I === 33319 && (ie === 5126 && (Pe = 33328), ie === 5131 && (Pe = 33327), ie === 5121 && (Pe = 33323)), I === 6408 && (ie === 5126 && (Pe = 34836), ie === 5131 && (Pe = 34842), ie === 5121 && (Pe = we === St && Ce === !1 ? 35907 : 32856), ie === 32819 && (Pe = 32854), ie === 32820 && (Pe = 32855)), (Pe === 33325 || Pe === 33326 || Pe === 33327 || Pe === 33328 || Pe === 34842 || Pe === 34836) && e.get("EXT_color_buffer_float"), Pe } function P(O, I, ie) { return B(O, ie) === !0 || O.isFramebufferTexture && O.minFilter !== pn && O.minFilter !== tn ? Math.log2(Math.max(I.width, I.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? I.mipmaps.length : 1 } function L(O) { return O === pn || O === Wf || O === Mc ? 9728 : 9729 } function z(O) { const I = O.target; I.removeEventListener("dispose", z), J(I), I.isVideoTexture && v.delete(I) } function Z(O) { const I = O.target; I.removeEventListener("dispose", Z), K(I) } function J(O) { const I = i.get(O); if (I.__webglInit === void 0) return; const ie = O.source, we = x.get(ie); if (we) { const Ce = we[I.__cacheKey]; Ce.usedTimes--, Ce.usedTimes === 0 && V(O), Object.keys(we).length === 0 && x.delete(ie) } i.remove(O) } function V(O) { const I = i.get(O); n.deleteTexture(I.__webglTexture); const ie = O.source, we = x.get(ie); delete we[I.__cacheKey], o.memory.textures-- } function K(O) { const I = O.texture, ie = i.get(O), we = i.get(I); if (we.__webglTexture !== void 0 && (n.deleteTexture(we.__webglTexture), o.memory.textures--), O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget) for (let Ce = 0; Ce < 6; Ce++)n.deleteFramebuffer(ie.__webglFramebuffer[Ce]), ie.__webglDepthbuffer && n.deleteRenderbuffer(ie.__webglDepthbuffer[Ce]); else { if (n.deleteFramebuffer(ie.__webglFramebuffer), ie.__webglDepthbuffer && n.deleteRenderbuffer(ie.__webglDepthbuffer), ie.__webglMultisampledFramebuffer && n.deleteFramebuffer(ie.__webglMultisampledFramebuffer), ie.__webglColorRenderbuffer) for (let Ce = 0; Ce < ie.__webglColorRenderbuffer.length; Ce++)ie.__webglColorRenderbuffer[Ce] && n.deleteRenderbuffer(ie.__webglColorRenderbuffer[Ce]); ie.__webglDepthRenderbuffer && n.deleteRenderbuffer(ie.__webglDepthRenderbuffer) } if (O.isWebGLMultipleRenderTargets) for (let Ce = 0, Pe = I.length; Ce < Pe; Ce++) { const Ye = i.get(I[Ce]); Ye.__webglTexture && (n.deleteTexture(Ye.__webglTexture), o.memory.textures--), i.remove(I[Ce]) } i.remove(I), i.remove(O) } let ee = 0; function le() { ee = 0 } function N() { const O = ee; return O >= l && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + l), ee += 1, O } function H(O) { const I = []; return I.push(O.wrapS), I.push(O.wrapT), I.push(O.wrapR || 0), I.push(O.magFilter), I.push(O.minFilter), I.push(O.anisotropy), I.push(O.internalFormat), I.push(O.format), I.push(O.type), I.push(O.generateMipmaps), I.push(O.premultiplyAlpha), I.push(O.flipY), I.push(O.unpackAlignment), I.push(O.encoding), I.join() } function W(O, I) { const ie = i.get(O); if (O.isVideoTexture && gt(O), O.isRenderTargetTexture === !1 && O.version > 0 && ie.__version !== O.version) { const we = O.image; if (we === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (we.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { Fe(ie, O, I); return } } t.bindTexture(3553, ie.__webglTexture, 33984 + I) } function se(O, I) { const ie = i.get(O); if (O.version > 0 && ie.__version !== O.version) { Fe(ie, O, I); return } t.bindTexture(35866, ie.__webglTexture, 33984 + I) } function j(O, I) { const ie = i.get(O); if (O.version > 0 && ie.__version !== O.version) { Fe(ie, O, I); return } t.bindTexture(32879, ie.__webglTexture, 33984 + I) } function oe(O, I) { const ie = i.get(O); if (O.version > 0 && ie.__version !== O.version) { ze(ie, O, I); return } t.bindTexture(34067, ie.__webglTexture, 33984 + I) } const ve = { [Wo]: 10497, [Hn]: 33071, [Lc]: 33648 }, q = { [pn]: 9728, [Wf]: 9984, [Mc]: 9986, [tn]: 9729, [b0]: 9985, [ls]: 9987 }; function Te(O, I, ie) { if (ie ? (n.texParameteri(O, 10242, ve[I.wrapS]), n.texParameteri(O, 10243, ve[I.wrapT]), (O === 32879 || O === 35866) && n.texParameteri(O, 32882, ve[I.wrapR]), n.texParameteri(O, 10240, q[I.magFilter]), n.texParameteri(O, 10241, q[I.minFilter])) : (n.texParameteri(O, 10242, 33071), n.texParameteri(O, 10243, 33071), (O === 32879 || O === 35866) && n.texParameteri(O, 32882, 33071), (I.wrapS !== Hn || I.wrapT !== Hn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(O, 10240, L(I.magFilter)), n.texParameteri(O, 10241, L(I.minFilter)), I.minFilter !== pn && I.minFilter !== tn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) { const we = e.get("EXT_texture_filter_anisotropic"); if (I.magFilter === pn || I.minFilter !== Mc && I.minFilter !== ls || I.type === Is && e.has("OES_texture_float_linear") === !1 || a === !1 && I.type === Ic && e.has("OES_texture_half_float_linear") === !1) return; (I.anisotropy > 1 || i.get(I).__currentAnisotropy) && (n.texParameterf(O, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, r.getMaxAnisotropy())), i.get(I).__currentAnisotropy = I.anisotropy) } } function Se(O, I) { let ie = !1; O.__webglInit === void 0 && (O.__webglInit = !0, I.addEventListener("dispose", z)); const we = I.source; let Ce = x.get(we); Ce === void 0 && (Ce = {}, x.set(we, Ce)); const Pe = H(I); if (Pe !== O.__cacheKey) { Ce[Pe] === void 0 && (Ce[Pe] = { texture: n.createTexture(), usedTimes: 0 }, o.memory.textures++, ie = !0), Ce[Pe].usedTimes++; const Ye = Ce[O.__cacheKey]; Ye !== void 0 && (Ce[O.__cacheKey].usedTimes--, Ye.usedTimes === 0 && V(I)), O.__cacheKey = Pe, O.__webglTexture = Ce[Pe].texture } return ie } function Fe(O, I, ie) { let we = 3553; (I.isDataArrayTexture || I.isCompressedArrayTexture) && (we = 35866), I.isData3DTexture && (we = 32879); const Ce = Se(O, I), Pe = I.source; t.bindTexture(we, O.__webglTexture, 33984 + ie); const Ye = i.get(Pe); if (Pe.version !== Ye.__version || Ce === !0) { t.activeTexture(33984 + ie), n.pixelStorei(37440, I.flipY), n.pixelStorei(37441, I.premultiplyAlpha), n.pixelStorei(3317, I.unpackAlignment), n.pixelStorei(37443, 0); const Oe = b(I) && S(I.image) === !1; let ye = M(I.image, Oe, !1, h); ye = wt(I, ye); const $e = S(ye) || a, G = s.convert(I.format, I.encoding); let he = s.convert(I.type), Ae = E(I.internalFormat, G, he, I.encoding, I.isVideoTexture); Te(we, I, $e); let Be; const tt = I.mipmaps, vt = a && I.isVideoTexture !== !0, Ht = Ye.__version === void 0 || Ce === !0, X = P(I, ye, $e); if (I.isDepthTexture) Ae = 6402, a ? I.type === Is ? Ae = 36012 : I.type === Co ? Ae = 33190 : I.type === Ja ? Ae = 35056 : Ae = 33189 : I.type === Is && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), I.format === Oo && Ae === 6402 && I.type !== Yx && I.type !== Co && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), I.type = Co, he = s.convert(I.type)), I.format === nl && Ae === 6402 && (Ae = 34041, I.type !== Ja && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), I.type = Ja, he = s.convert(I.type))), Ht && (vt ? t.texStorage2D(3553, 1, Ae, ye.width, ye.height) : t.texImage2D(3553, 0, Ae, ye.width, ye.height, 0, G, he, null)); else if (I.isDataTexture) if (tt.length > 0 && $e) { vt && Ht && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height); for (let ae = 0, xe = tt.length; ae < xe; ae++)Be = tt[ae], vt ? t.texSubImage2D(3553, ae, 0, 0, Be.width, Be.height, G, he, Be.data) : t.texImage2D(3553, ae, Ae, Be.width, Be.height, 0, G, he, Be.data); I.generateMipmaps = !1 } else vt ? (Ht && t.texStorage2D(3553, X, Ae, ye.width, ye.height), t.texSubImage2D(3553, 0, 0, 0, ye.width, ye.height, G, he, ye.data)) : t.texImage2D(3553, 0, Ae, ye.width, ye.height, 0, G, he, ye.data); else if (I.isCompressedTexture) if (I.isCompressedArrayTexture) { vt && Ht && t.texStorage3D(35866, X, Ae, tt[0].width, tt[0].height, ye.depth); for (let ae = 0, xe = tt.length; ae < xe; ae++)Be = tt[ae], I.format !== Si ? G !== null ? vt ? t.compressedTexSubImage3D(35866, ae, 0, 0, 0, Be.width, Be.height, ye.depth, G, Be.data, 0, 0) : t.compressedTexImage3D(35866, ae, Ae, Be.width, Be.height, ye.depth, 0, Be.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage3D(35866, ae, 0, 0, 0, Be.width, Be.height, ye.depth, G, he, Be.data) : t.texImage3D(35866, ae, Ae, Be.width, Be.height, ye.depth, 0, G, he, Be.data) } else { vt && Ht && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height); for (let ae = 0, xe = tt.length; ae < xe; ae++)Be = tt[ae], I.format !== Si ? G !== null ? vt ? t.compressedTexSubImage2D(3553, ae, 0, 0, Be.width, Be.height, G, Be.data) : t.compressedTexImage2D(3553, ae, Ae, Be.width, Be.height, 0, Be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : vt ? t.texSubImage2D(3553, ae, 0, 0, Be.width, Be.height, G, he, Be.data) : t.texImage2D(3553, ae, Ae, Be.width, Be.height, 0, G, he, Be.data) } else if (I.isDataArrayTexture) vt ? (Ht && t.texStorage3D(35866, X, Ae, ye.width, ye.height, ye.depth), t.texSubImage3D(35866, 0, 0, 0, 0, ye.width, ye.height, ye.depth, G, he, ye.data)) : t.texImage3D(35866, 0, Ae, ye.width, ye.height, ye.depth, 0, G, he, ye.data); else if (I.isData3DTexture) vt ? (Ht && t.texStorage3D(32879, X, Ae, ye.width, ye.height, ye.depth), t.texSubImage3D(32879, 0, 0, 0, 0, ye.width, ye.height, ye.depth, G, he, ye.data)) : t.texImage3D(32879, 0, Ae, ye.width, ye.height, ye.depth, 0, G, he, ye.data); else if (I.isFramebufferTexture) { if (Ht) if (vt) t.texStorage2D(3553, X, Ae, ye.width, ye.height); else { let ae = ye.width, xe = ye.height; for (let Ue = 0; Ue < X; Ue++)t.texImage2D(3553, Ue, Ae, ae, xe, 0, G, he, null), ae >>= 1, xe >>= 1 } } else if (tt.length > 0 && $e) { vt && Ht && t.texStorage2D(3553, X, Ae, tt[0].width, tt[0].height); for (let ae = 0, xe = tt.length; ae < xe; ae++)Be = tt[ae], vt ? t.texSubImage2D(3553, ae, 0, 0, G, he, Be) : t.texImage2D(3553, ae, Ae, G, he, Be); I.generateMipmaps = !1 } else vt ? (Ht && t.texStorage2D(3553, X, Ae, ye.width, ye.height), t.texSubImage2D(3553, 0, 0, 0, G, he, ye)) : t.texImage2D(3553, 0, Ae, G, he, ye); B(I, $e) && R(we), Ye.__version = Pe.version, I.onUpdate && I.onUpdate(I) } O.__version = I.version } function ze(O, I, ie) { if (I.image.length !== 6) return; const we = Se(O, I), Ce = I.source; t.bindTexture(34067, O.__webglTexture, 33984 + ie); const Pe = i.get(Ce); if (Ce.version !== Pe.__version || we === !0) { t.activeTexture(33984 + ie), n.pixelStorei(37440, I.flipY), n.pixelStorei(37441, I.premultiplyAlpha), n.pixelStorei(3317, I.unpackAlignment), n.pixelStorei(37443, 0); const Ye = I.isCompressedTexture || I.image[0].isCompressedTexture, Oe = I.image[0] && I.image[0].isDataTexture, ye = []; for (let ae = 0; ae < 6; ae++)!Ye && !Oe ? ye[ae] = M(I.image[ae], !1, !0, u) : ye[ae] = Oe ? I.image[ae].image : I.image[ae], ye[ae] = wt(I, ye[ae]); const $e = ye[0], G = S($e) || a, he = s.convert(I.format, I.encoding), Ae = s.convert(I.type), Be = E(I.internalFormat, he, Ae, I.encoding), tt = a && I.isVideoTexture !== !0, vt = Pe.__version === void 0 || we === !0; let Ht = P(I, $e, G); Te(34067, I, G); let X; if (Ye) { tt && vt && t.texStorage2D(34067, Ht, Be, $e.width, $e.height); for (let ae = 0; ae < 6; ae++) { X = ye[ae].mipmaps; for (let xe = 0; xe < X.length; xe++) { const Ue = X[xe]; I.format !== Si ? he !== null ? tt ? t.compressedTexSubImage2D(34069 + ae, xe, 0, 0, Ue.width, Ue.height, he, Ue.data) : t.compressedTexImage2D(34069 + ae, xe, Be, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : tt ? t.texSubImage2D(34069 + ae, xe, 0, 0, Ue.width, Ue.height, he, Ae, Ue.data) : t.texImage2D(34069 + ae, xe, Be, Ue.width, Ue.height, 0, he, Ae, Ue.data) } } } else { X = I.mipmaps, tt && vt && (X.length > 0 && Ht++, t.texStorage2D(34067, Ht, Be, ye[0].width, ye[0].height)); for (let ae = 0; ae < 6; ae++)if (Oe) { tt ? t.texSubImage2D(34069 + ae, 0, 0, 0, ye[ae].width, ye[ae].height, he, Ae, ye[ae].data) : t.texImage2D(34069 + ae, 0, Be, ye[ae].width, ye[ae].height, 0, he, Ae, ye[ae].data); for (let xe = 0; xe < X.length; xe++) { const Je = X[xe].image[ae].image; tt ? t.texSubImage2D(34069 + ae, xe + 1, 0, 0, Je.width, Je.height, he, Ae, Je.data) : t.texImage2D(34069 + ae, xe + 1, Be, Je.width, Je.height, 0, he, Ae, Je.data) } } else { tt ? t.texSubImage2D(34069 + ae, 0, 0, 0, he, Ae, ye[ae]) : t.texImage2D(34069 + ae, 0, Be, he, Ae, ye[ae]); for (let xe = 0; xe < X.length; xe++) { const Ue = X[xe]; tt ? t.texSubImage2D(34069 + ae, xe + 1, 0, 0, he, Ae, Ue.image[ae]) : t.texImage2D(34069 + ae, xe + 1, Be, he, Ae, Ue.image[ae]) } } } B(I, G) && R(34067), Pe.__version = Ce.version, I.onUpdate && I.onUpdate(I) } O.__version = I.version } function Le(O, I, ie, we, Ce) { const Pe = s.convert(ie.format, ie.encoding), Ye = s.convert(ie.type), Oe = E(ie.internalFormat, Pe, Ye, ie.encoding); i.get(I).__hasExternalTextures || (Ce === 32879 || Ce === 35866 ? t.texImage3D(Ce, 0, Oe, I.width, I.height, I.depth, 0, Pe, Ye, null) : t.texImage2D(Ce, 0, Oe, I.width, I.height, 0, Pe, Ye, null)), t.bindFramebuffer(36160, O), Ze(I) ? p.framebufferTexture2DMultisampleEXT(36160, we, Ce, i.get(ie).__webglTexture, 0, Xe(I)) : (Ce === 3553 || Ce >= 34069 && Ce <= 34074) && n.framebufferTexture2D(36160, we, Ce, i.get(ie).__webglTexture, 0), t.bindFramebuffer(36160, null) } function be(O, I, ie) { if (n.bindRenderbuffer(36161, O), I.depthBuffer && !I.stencilBuffer) { let we = 33189; if (ie || Ze(I)) { const Ce = I.depthTexture; Ce && Ce.isDepthTexture && (Ce.type === Is ? we = 36012 : Ce.type === Co && (we = 33190)); const Pe = Xe(I); Ze(I) ? p.renderbufferStorageMultisampleEXT(36161, Pe, we, I.width, I.height) : n.renderbufferStorageMultisample(36161, Pe, we, I.width, I.height) } else n.renderbufferStorage(36161, we, I.width, I.height); n.framebufferRenderbuffer(36160, 36096, 36161, O) } else if (I.depthBuffer && I.stencilBuffer) { const we = Xe(I); ie && Ze(I) === !1 ? n.renderbufferStorageMultisample(36161, we, 35056, I.width, I.height) : Ze(I) ? p.renderbufferStorageMultisampleEXT(36161, we, 35056, I.width, I.height) : n.renderbufferStorage(36161, 34041, I.width, I.height), n.framebufferRenderbuffer(36160, 33306, 36161, O) } else { const we = I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture]; for (let Ce = 0; Ce < we.length; Ce++) { const Pe = we[Ce], Ye = s.convert(Pe.format, Pe.encoding), Oe = s.convert(Pe.type), ye = E(Pe.internalFormat, Ye, Oe, Pe.encoding), $e = Xe(I); ie && Ze(I) === !1 ? n.renderbufferStorageMultisample(36161, $e, ye, I.width, I.height) : Ze(I) ? p.renderbufferStorageMultisampleEXT(36161, $e, ye, I.width, I.height) : n.renderbufferStorage(36161, ye, I.width, I.height) } } n.bindRenderbuffer(36161, null) } function de(O, I) { if (I && I.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, O), !(I.depthTexture && I.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!i.get(I.depthTexture).__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width, I.depthTexture.image.height = I.height, I.depthTexture.needsUpdate = !0), W(I.depthTexture, 0); const we = i.get(I.depthTexture).__webglTexture, Ce = Xe(I); if (I.depthTexture.format === Oo) Ze(I) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, we, 0, Ce) : n.framebufferTexture2D(36160, 36096, 3553, we, 0); else if (I.depthTexture.format === nl) Ze(I) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, we, 0, Ce) : n.framebufferTexture2D(36160, 33306, 3553, we, 0); else throw new Error("Unknown depthTexture format") } function pe(O) { const I = i.get(O), ie = O.isWebGLCubeRenderTarget === !0; if (O.depthTexture && !I.__autoAllocateDepthBuffer) { if (ie) throw new Error("target.depthTexture not supported in Cube render targets"); de(I.__webglFramebuffer, O) } else if (ie) { I.__webglDepthbuffer = []; for (let we = 0; we < 6; we++)t.bindFramebuffer(36160, I.__webglFramebuffer[we]), I.__webglDepthbuffer[we] = n.createRenderbuffer(), be(I.__webglDepthbuffer[we], O, !1) } else t.bindFramebuffer(36160, I.__webglFramebuffer), I.__webglDepthbuffer = n.createRenderbuffer(), be(I.__webglDepthbuffer, O, !1); t.bindFramebuffer(36160, null) } function _e(O, I, ie) { const we = i.get(O); I !== void 0 && Le(we.__webglFramebuffer, O, O.texture, 36064, 3553), ie !== void 0 && pe(O) } function Ve(O) { const I = O.texture, ie = i.get(O), we = i.get(I); O.addEventListener("dispose", Z), O.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = n.createTexture()), we.__version = I.version, o.memory.textures++); const Ce = O.isWebGLCubeRenderTarget === !0, Pe = O.isWebGLMultipleRenderTargets === !0, Ye = S(O) || a; if (Ce) { ie.__webglFramebuffer = []; for (let Oe = 0; Oe < 6; Oe++)ie.__webglFramebuffer[Oe] = n.createFramebuffer() } else { if (ie.__webglFramebuffer = n.createFramebuffer(), Pe) if (r.drawBuffers) { const Oe = O.texture; for (let ye = 0, $e = Oe.length; ye < $e; ye++) { const G = i.get(Oe[ye]); G.__webglTexture === void 0 && (G.__webglTexture = n.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && O.samples > 0 && Ze(O) === !1) { const Oe = Pe ? I : [I]; ie.__webglMultisampledFramebuffer = n.createFramebuffer(), ie.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, ie.__webglMultisampledFramebuffer); for (let ye = 0; ye < Oe.length; ye++) { const $e = Oe[ye]; ie.__webglColorRenderbuffer[ye] = n.createRenderbuffer(), n.bindRenderbuffer(36161, ie.__webglColorRenderbuffer[ye]); const G = s.convert($e.format, $e.encoding), he = s.convert($e.type), Ae = E($e.internalFormat, G, he, $e.encoding, O.isXRRenderTarget === !0), Be = Xe(O); n.renderbufferStorageMultisample(36161, Be, Ae, O.width, O.height), n.framebufferRenderbuffer(36160, 36064 + ye, 36161, ie.__webglColorRenderbuffer[ye]) } n.bindRenderbuffer(36161, null), O.depthBuffer && (ie.__webglDepthRenderbuffer = n.createRenderbuffer(), be(ie.__webglDepthRenderbuffer, O, !0)), t.bindFramebuffer(36160, null) } } if (Ce) { t.bindTexture(34067, we.__webglTexture), Te(34067, I, Ye); for (let Oe = 0; Oe < 6; Oe++)Le(ie.__webglFramebuffer[Oe], O, I, 36064, 34069 + Oe); B(I, Ye) && R(34067), t.unbindTexture() } else if (Pe) { const Oe = O.texture; for (let ye = 0, $e = Oe.length; ye < $e; ye++) { const G = Oe[ye], he = i.get(G); t.bindTexture(3553, he.__webglTexture), Te(3553, G, Ye), Le(ie.__webglFramebuffer, O, G, 36064 + ye, 3553), B(G, Ye) && R(3553) } t.unbindTexture() } else { let Oe = 3553; (O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? Oe = O.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Oe, we.__webglTexture), Te(Oe, I, Ye), Le(ie.__webglFramebuffer, O, I, 36064, Oe), B(I, Ye) && R(Oe), t.unbindTexture() } O.depthBuffer && pe(O) } function Ie(O) { const I = S(O) || a, ie = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture]; for (let we = 0, Ce = ie.length; we < Ce; we++) { const Pe = ie[we]; if (B(Pe, I)) { const Ye = O.isWebGLCubeRenderTarget ? 34067 : 3553, Oe = i.get(Pe).__webglTexture; t.bindTexture(Ye, Oe), R(Ye), t.unbindTexture() } } } function Qe(O) { if (a && O.samples > 0 && Ze(O) === !1) { const I = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture], ie = O.width, we = O.height; let Ce = 16384; const Pe = [], Ye = O.stencilBuffer ? 33306 : 36096, Oe = i.get(O), ye = O.isWebGLMultipleRenderTargets === !0; if (ye) for (let $e = 0; $e < I.length; $e++)t.bindFramebuffer(36160, Oe.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + $e, 36161, null), t.bindFramebuffer(36160, Oe.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + $e, 3553, null, 0); t.bindFramebuffer(36008, Oe.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, Oe.__webglFramebuffer); for (let $e = 0; $e < I.length; $e++) { Pe.push(36064 + $e), O.depthBuffer && Pe.push(Ye); const G = Oe.__ignoreDepthValues !== void 0 ? Oe.__ignoreDepthValues : !1; if (G === !1 && (O.depthBuffer && (Ce |= 256), O.stencilBuffer && (Ce |= 1024)), ye && n.framebufferRenderbuffer(36008, 36064, 36161, Oe.__webglColorRenderbuffer[$e]), G === !0 && (n.invalidateFramebuffer(36008, [Ye]), n.invalidateFramebuffer(36009, [Ye])), ye) { const he = i.get(I[$e]).__webglTexture; n.framebufferTexture2D(36009, 36064, 3553, he, 0) } n.blitFramebuffer(0, 0, ie, we, 0, 0, ie, we, Ce, 9728), m && n.invalidateFramebuffer(36008, Pe) } if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), ye) for (let $e = 0; $e < I.length; $e++) { t.bindFramebuffer(36160, Oe.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + $e, 36161, Oe.__webglColorRenderbuffer[$e]); const G = i.get(I[$e]).__webglTexture; t.bindFramebuffer(36160, Oe.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + $e, 3553, G, 0) } t.bindFramebuffer(36009, Oe.__webglMultisampledFramebuffer) } } function Xe(O) { return Math.min(d, O.samples) } function Ze(O) { const I = i.get(O); return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && I.__useRenderToTexture !== !1 } function gt(O) { const I = o.render.frame; v.get(O) !== I && (v.set(O, I), O.update()) } function wt(O, I) { const ie = O.encoding, we = O.format, Ce = O.type; return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || O.format === Vm || ie !== Js && (ie === St ? a === !1 ? e.has("EXT_sRGB") === !0 && we === Si ? (O.format = Vm, O.minFilter = tn, O.generateMipmaps = !1) : I = nA.sRGBToLinear(I) : (we !== Si || Ce !== js) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", ie)), I } this.allocateTextureUnit = N, this.resetTextureUnits = le, this.setTexture2D = W, this.setTexture2DArray = se, this.setTexture3D = j, this.setTextureCube = oe, this.rebindTextures = _e, this.setupRenderTarget = Ve, this.updateRenderTargetMipmap = Ie, this.updateMultisampleRenderTarget = Qe, this.setupDepthRenderbuffer = pe, this.setupFrameBufferTexture = Le, this.useMultisampledRTT = Ze } function K5(n, e, t) { const i = t.isWebGL2; function r(s, o = null) { let a; if (s === js) return 5121; if (s === v5) return 32819; if (s === x5) return 32820; if (s === m5) return 5120; if (s === g5) return 5122; if (s === Yx) return 5123; if (s === y5) return 5124; if (s === Co) return 5125; if (s === Is) return 5126; if (s === Ic) return i ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (s === A5) return 6406; if (s === Si) return 6408; if (s === M5) return 6409; if (s === _5) return 6410; if (s === Oo) return 6402; if (s === nl) return 34041; if (s === Vm) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (s === w5) return 6403; if (s === S5) return 36244; if (s === C5) return 33319; if (s === E5) return 33320; if (s === b5) return 36249; if (s === sm || s === om || s === am || s === lm) if (o === St) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (s === sm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === om) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === am) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === lm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (s === sm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === om) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === am) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === lm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === Vv || s === Wv || s === jv || s === Jv) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (s === Vv) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === Wv) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === jv) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === Jv) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === T5) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (s === Xv || s === Qv) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (s === Xv) return o === St ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (s === Qv) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === Kv || s === Yv || s === qv || s === Zv || s === $v || s === e2 || s === t2 || s === n2 || s === i2 || s === r2 || s === s2 || s === o2 || s === a2 || s === l2) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (s === Kv) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === Yv) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === qv) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === Zv) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === $v) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === e2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === t2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === n2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === i2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === r2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === s2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === o2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === a2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === l2) return o === St ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === cm) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (s === cm) return o === St ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } else return null; if (s === B5 || s === c2 || s === u2 || s === f2) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) { if (s === cm) return a.COMPRESSED_RED_RGTC1_EXT; if (s === c2) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === u2) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === f2) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === Ja ? i ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null } return { convert: r } } class Y5 extends Ut { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class Fs extends bt { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const Sk = { type: "move" }; class iy { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new Fs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new Fs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new D, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new D), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new Fs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new D, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new D), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const i of e.hand.values()) this._getHandJoint(t, i) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, t, i) { let r = null, s = null, o = null; const a = this._targetRay, l = this._grip, u = this._hand; if (e && t.session.visibilityState !== "visible-blurred") { if (u && e.hand) { o = !0; for (const y of e.hand.values()) { const x = t.getJointPose(y, i), A = this._getHandJoint(u, y); x !== null && (A.matrix.fromArray(x.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.jointRadius = x.radius), A.visible = x !== null } const h = u.joints["index-finger-tip"], d = u.joints["thumb-tip"], p = h.position.distanceTo(d.position), m = .02, v = .005; u.inputState.pinching && p > m + v ? (u.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !u.inputState.pinching && p <= m - v && (u.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1)); a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Sk))) } return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = o !== null), this } _getHandJoint(e, t) { if (e.joints[t.jointName] === void 0) { const i = new Fs; i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i) } return e.joints[t.jointName] } } class q5 extends Zt { constructor(e, t, i, r, s, o, a, l, u, h) { if (h = h !== void 0 ? h : Oo, h !== Oo && h !== nl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); i === void 0 && h === Oo && (i = Co), i === void 0 && h === nl && (i = Ja), super(null, r, s, o, a, l, h, i, u), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : pn, this.minFilter = l !== void 0 ? l : pn, this.flipY = !1, this.generateMipmaps = !1 } } class Ck extends us { constructor(e, t) { super(); const i = this; let r = null, s = 1, o = null, a = "local-floor", l = 1, u = null, h = null, d = null, p = null, m = null, v = null; const y = t.getContextAttributes(); let x = null, A = null; const _ = [], M = [], S = new Set, b = new Map, B = new Ut; B.layers.enable(1), B.viewport = new Ft; const R = new Ut; R.layers.enable(2), R.viewport = new Ft; const E = [B, R], P = new Y5; P.layers.enable(1), P.layers.enable(2); let L = null, z = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (j) { let oe = _[j]; return oe === void 0 && (oe = new iy, _[j] = oe), oe.getTargetRaySpace() }, this.getControllerGrip = function (j) { let oe = _[j]; return oe === void 0 && (oe = new iy, _[j] = oe), oe.getGripSpace() }, this.getHand = function (j) { let oe = _[j]; return oe === void 0 && (oe = new iy, _[j] = oe), oe.getHandSpace() }; function Z(j) { const oe = M.indexOf(j.inputSource); if (oe === -1) return; const ve = _[oe]; ve !== void 0 && ve.dispatchEvent({ type: j.type, data: j.inputSource }) } function J() { r.removeEventListener("select", Z), r.removeEventListener("selectstart", Z), r.removeEventListener("selectend", Z), r.removeEventListener("squeeze", Z), r.removeEventListener("squeezestart", Z), r.removeEventListener("squeezeend", Z), r.removeEventListener("end", J), r.removeEventListener("inputsourceschange", V); for (let j = 0; j < _.length; j++) { const oe = M[j]; oe !== null && (M[j] = null, _[j].disconnect(oe)) } L = null, z = null, e.setRenderTarget(x), m = null, p = null, d = null, r = null, A = null, se.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (j) { s = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (j) { a = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return u || o }, this.setReferenceSpace = function (j) { u = j }, this.getBaseLayer = function () { return p !== null ? p : m }, this.getBinding = function () { return d }, this.getFrame = function () { return v }, this.getSession = function () { return r }, this.setSession = async function (j) { if (r = j, r !== null) { if (x = e.getRenderTarget(), r.addEventListener("select", Z), r.addEventListener("selectstart", Z), r.addEventListener("selectend", Z), r.addEventListener("squeeze", Z), r.addEventListener("squeezestart", Z), r.addEventListener("squeezeend", Z), r.addEventListener("end", J), r.addEventListener("inputsourceschange", V), y.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const oe = { antialias: r.renderState.layers === void 0 ? y.antialias : !0, alpha: y.alpha, depth: y.depth, stencil: y.stencil, framebufferScaleFactor: s }; m = new XRWebGLLayer(r, t, oe), r.updateRenderState({ baseLayer: m }), A = new Or(m.framebufferWidth, m.framebufferHeight, { format: Si, type: js, encoding: e.outputEncoding, stencilBuffer: y.stencil }) } else { let oe = null, ve = null, q = null; y.depth && (q = y.stencil ? 35056 : 33190, oe = y.stencil ? nl : Oo, ve = y.stencil ? Ja : Co); const Te = { colorFormat: 32856, depthFormat: q, scaleFactor: s }; d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(Te), r.updateRenderState({ layers: [p] }), A = new Or(p.textureWidth, p.textureHeight, { format: Si, type: js, depthTexture: new q5(p.textureWidth, p.textureHeight, ve, void 0, void 0, void 0, void 0, void 0, void 0, oe), stencilBuffer: y.stencil, encoding: e.outputEncoding, samples: y.antialias ? 4 : 0 }); const Se = e.properties.get(A); Se.__ignoreDepthValues = p.ignoreDepthValues } A.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await r.requestReferenceSpace(a), se.setContext(r), se.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" }) } }; function V(j) { for (let oe = 0; oe < j.removed.length; oe++) { const ve = j.removed[oe], q = M.indexOf(ve); q >= 0 && (M[q] = null, _[q].disconnect(ve)) } for (let oe = 0; oe < j.added.length; oe++) { const ve = j.added[oe]; let q = M.indexOf(ve); if (q === -1) { for (let Se = 0; Se < _.length; Se++)if (Se >= M.length) { M.push(ve), q = Se; break } else if (M[Se] === null) { M[Se] = ve, q = Se; break } if (q === -1) break } const Te = _[q]; Te && Te.connect(ve) } } const K = new D, ee = new D; function le(j, oe, ve) { K.setFromMatrixPosition(oe.matrixWorld), ee.setFromMatrixPosition(ve.matrixWorld); const q = K.distanceTo(ee), Te = oe.projectionMatrix.elements, Se = ve.projectionMatrix.elements, Fe = Te[14] / (Te[10] - 1), ze = Te[14] / (Te[10] + 1), Le = (Te[9] + 1) / Te[5], be = (Te[9] - 1) / Te[5], de = (Te[8] - 1) / Te[0], pe = (Se[8] + 1) / Se[0], _e = Fe * de, Ve = Fe * pe, Ie = q / (-de + pe), Qe = Ie * -de; oe.matrixWorld.decompose(j.position, j.quaternion, j.scale), j.translateX(Qe), j.translateZ(Ie), j.matrixWorld.compose(j.position, j.quaternion, j.scale), j.matrixWorldInverse.copy(j.matrixWorld).invert(); const Xe = Fe + Ie, Ze = ze + Ie, gt = _e - Qe, wt = Ve + (q - Qe), O = Le * ze / Ze * Xe, I = be * ze / Ze * Xe; j.projectionMatrix.makePerspective(gt, wt, O, I, Xe, Ze) } function N(j, oe) { oe === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(oe.matrixWorld, j.matrix), j.matrixWorldInverse.copy(j.matrixWorld).invert() } this.updateCamera = function (j) { if (r === null) return; P.near = R.near = B.near = j.near, P.far = R.far = B.far = j.far, (L !== P.near || z !== P.far) && (r.updateRenderState({ depthNear: P.near, depthFar: P.far }), L = P.near, z = P.far); const oe = j.parent, ve = P.cameras; N(P, oe); for (let Te = 0; Te < ve.length; Te++)N(ve[Te], oe); P.matrixWorld.decompose(P.position, P.quaternion, P.scale), j.matrix.copy(P.matrix), j.matrix.decompose(j.position, j.quaternion, j.scale); const q = j.children; for (let Te = 0, Se = q.length; Te < Se; Te++)q[Te].updateMatrixWorld(!0); ve.length === 2 ? le(P, B, R) : P.projectionMatrix.copy(B.projectionMatrix) }, this.getCamera = function () { return P }, this.getFoveation = function () { if (!(p === null && m === null)) return l }, this.setFoveation = function (j) { l = j, p !== null && (p.fixedFoveation = j), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = j) }, this.getPlanes = function () { return S }; let H = null; function W(j, oe) { if (h = oe.getViewerPose(u || o), v = oe, h !== null) { const ve = h.views; m !== null && (e.setRenderTargetFramebuffer(A, m.framebuffer), e.setRenderTarget(A)); let q = !1; ve.length !== P.cameras.length && (P.cameras.length = 0, q = !0); for (let Te = 0; Te < ve.length; Te++) { const Se = ve[Te]; let Fe = null; if (m !== null) Fe = m.getViewport(Se); else { const Le = d.getViewSubImage(p, Se); Fe = Le.viewport, Te === 0 && (e.setRenderTargetTextures(A, Le.colorTexture, p.ignoreDepthValues ? void 0 : Le.depthStencilTexture), e.setRenderTarget(A)) } let ze = E[Te]; ze === void 0 && (ze = new Ut, ze.layers.enable(Te), ze.viewport = new Ft, E[Te] = ze), ze.matrix.fromArray(Se.transform.matrix), ze.projectionMatrix.fromArray(Se.projectionMatrix), ze.viewport.set(Fe.x, Fe.y, Fe.width, Fe.height), Te === 0 && P.matrix.copy(ze.matrix), q === !0 && P.cameras.push(ze) } } for (let ve = 0; ve < _.length; ve++) { const q = M[ve], Te = _[ve]; q !== null && Te !== void 0 && Te.update(q, oe, u || o) } if (H && H(j, oe), oe.detectedPlanes) { i.dispatchEvent({ type: "planesdetected", data: oe.detectedPlanes }); let ve = null; for (const q of S) oe.detectedPlanes.has(q) || (ve === null && (ve = []), ve.push(q)); if (ve !== null) for (const q of ve) S.delete(q), b.delete(q), i.dispatchEvent({ type: "planeremoved", data: q }); for (const q of oe.detectedPlanes) if (!S.has(q)) S.add(q), b.set(q, oe.lastChangedTime), i.dispatchEvent({ type: "planeadded", data: q }); else { const Te = b.get(q); q.lastChangedTime > Te && (b.set(q, q.lastChangedTime), i.dispatchEvent({ type: "planechanged", data: q })) } } v = null } const se = new W5; se.setAnimationLoop(W), this.setAnimationLoop = function (j) { H = j }, this.dispose = function () { } } } function Ek(n, e) { function t(y, x) { x.color.getRGB(y.fogColor.value, H5(n)), x.isFog ? (y.fogNear.value = x.near, y.fogFar.value = x.far) : x.isFogExp2 && (y.fogDensity.value = x.density) } function i(y, x, A, _, M) { x.isMeshBasicMaterial || x.isMeshLambertMaterial ? r(y, x) : x.isMeshToonMaterial ? (r(y, x), h(y, x)) : x.isMeshPhongMaterial ? (r(y, x), u(y, x)) : x.isMeshStandardMaterial ? (r(y, x), d(y, x), x.isMeshPhysicalMaterial && p(y, x, M)) : x.isMeshMatcapMaterial ? (r(y, x), m(y, x)) : x.isMeshDepthMaterial ? r(y, x) : x.isMeshDistanceMaterial ? (r(y, x), v(y, x)) : x.isMeshNormalMaterial ? r(y, x) : x.isLineBasicMaterial ? (s(y, x), x.isLineDashedMaterial && o(y, x)) : x.isPointsMaterial ? a(y, x, A, _) : x.isSpriteMaterial ? l(y, x) : x.isShadowMaterial ? (y.color.value.copy(x.color), y.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1) } function r(y, x) { y.opacity.value = x.opacity, x.color && y.diffuse.value.copy(x.color), x.emissive && y.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.bumpMap && (y.bumpMap.value = x.bumpMap, y.bumpScale.value = x.bumpScale, x.side === Bi && (y.bumpScale.value *= -1)), x.displacementMap && (y.displacementMap.value = x.displacementMap, y.displacementScale.value = x.displacementScale, y.displacementBias.value = x.displacementBias), x.emissiveMap && (y.emissiveMap.value = x.emissiveMap), x.normalMap && (y.normalMap.value = x.normalMap, y.normalScale.value.copy(x.normalScale), x.side === Bi && y.normalScale.value.negate()), x.specularMap && (y.specularMap.value = x.specularMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); const A = e.get(x).envMap; if (A && (y.envMap.value = A, y.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = x.reflectivity, y.ior.value = x.ior, y.refractionRatio.value = x.refractionRatio), x.lightMap) { y.lightMap.value = x.lightMap; const S = n.useLegacyLights === !0 ? Math.PI : 1; y.lightMapIntensity.value = x.lightMapIntensity * S } x.aoMap && (y.aoMap.value = x.aoMap, y.aoMapIntensity.value = x.aoMapIntensity); let _; x.map ? _ = x.map : x.specularMap ? _ = x.specularMap : x.displacementMap ? _ = x.displacementMap : x.normalMap ? _ = x.normalMap : x.bumpMap ? _ = x.bumpMap : x.roughnessMap ? _ = x.roughnessMap : x.metalnessMap ? _ = x.metalnessMap : x.alphaMap ? _ = x.alphaMap : x.emissiveMap ? _ = x.emissiveMap : x.clearcoatMap ? _ = x.clearcoatMap : x.clearcoatNormalMap ? _ = x.clearcoatNormalMap : x.clearcoatRoughnessMap ? _ = x.clearcoatRoughnessMap : x.iridescenceMap ? _ = x.iridescenceMap : x.iridescenceThicknessMap ? _ = x.iridescenceThicknessMap : x.specularIntensityMap ? _ = x.specularIntensityMap : x.specularColorMap ? _ = x.specularColorMap : x.transmissionMap ? _ = x.transmissionMap : x.thicknessMap ? _ = x.thicknessMap : x.sheenColorMap ? _ = x.sheenColorMap : x.sheenRoughnessMap && (_ = x.sheenRoughnessMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), y.uvTransform.value.copy(_.matrix)); let M; x.aoMap ? M = x.aoMap : x.lightMap && (M = x.lightMap), M !== void 0 && (M.isWebGLRenderTarget && (M = M.texture), M.matrixAutoUpdate === !0 && M.updateMatrix(), y.uv2Transform.value.copy(M.matrix)) } function s(y, x) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity } function o(y, x) { y.dashSize.value = x.dashSize, y.totalSize.value = x.dashSize + x.gapSize, y.scale.value = x.scale } function a(y, x, A, _) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity, y.size.value = x.size * A, y.scale.value = _ * .5, x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); let M; x.map ? M = x.map : x.alphaMap && (M = x.alphaMap), M !== void 0 && (M.matrixAutoUpdate === !0 && M.updateMatrix(), y.uvTransform.value.copy(M.matrix)) } function l(y, x) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity, y.rotation.value = x.rotation, x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); let A; x.map ? A = x.map : x.alphaMap && (A = x.alphaMap), A !== void 0 && (A.matrixAutoUpdate === !0 && A.updateMatrix(), y.uvTransform.value.copy(A.matrix)) } function u(y, x) { y.specular.value.copy(x.specular), y.shininess.value = Math.max(x.shininess, 1e-4) } function h(y, x) { x.gradientMap && (y.gradientMap.value = x.gradientMap) } function d(y, x) { y.roughness.value = x.roughness, y.metalness.value = x.metalness, x.roughnessMap && (y.roughnessMap.value = x.roughnessMap), x.metalnessMap && (y.metalnessMap.value = x.metalnessMap), e.get(x).envMap && (y.envMapIntensity.value = x.envMapIntensity) } function p(y, x, A) { y.ior.value = x.ior, x.sheen > 0 && (y.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen), y.sheenRoughness.value = x.sheenRoughness, x.sheenColorMap && (y.sheenColorMap.value = x.sheenColorMap), x.sheenRoughnessMap && (y.sheenRoughnessMap.value = x.sheenRoughnessMap)), x.clearcoat > 0 && (y.clearcoat.value = x.clearcoat, y.clearcoatRoughness.value = x.clearcoatRoughness, x.clearcoatMap && (y.clearcoatMap.value = x.clearcoatMap), x.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap), x.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), y.clearcoatNormalMap.value = x.clearcoatNormalMap, x.side === Bi && y.clearcoatNormalScale.value.negate())), x.iridescence > 0 && (y.iridescence.value = x.iridescence, y.iridescenceIOR.value = x.iridescenceIOR, y.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1], x.iridescenceMap && (y.iridescenceMap.value = x.iridescenceMap), x.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = x.iridescenceThicknessMap)), x.transmission > 0 && (y.transmission.value = x.transmission, y.transmissionSamplerMap.value = A.texture, y.transmissionSamplerSize.value.set(A.width, A.height), x.transmissionMap && (y.transmissionMap.value = x.transmissionMap), y.thickness.value = x.thickness, x.thicknessMap && (y.thicknessMap.value = x.thicknessMap), y.attenuationDistance.value = x.attenuationDistance, y.attenuationColor.value.copy(x.attenuationColor)), y.specularIntensity.value = x.specularIntensity, y.specularColor.value.copy(x.specularColor), x.specularIntensityMap && (y.specularIntensityMap.value = x.specularIntensityMap), x.specularColorMap && (y.specularColorMap.value = x.specularColorMap) } function m(y, x) { x.matcap && (y.matcap.value = x.matcap) } function v(y, x) { y.referencePosition.value.copy(x.referencePosition), y.nearDistance.value = x.nearDistance, y.farDistance.value = x.farDistance } return { refreshFogUniforms: t, refreshMaterialUniforms: i } } function bk(n, e, t, i) { let r = {}, s = {}, o = []; const a = t.isWebGL2 ? n.getParameter(35375) : 0; function l(_, M) { const S = M.program; i.uniformBlockBinding(_, S) } function u(_, M) { let S = r[_.id]; S === void 0 && (v(_), S = h(_), r[_.id] = S, _.addEventListener("dispose", x)); const b = M.program; i.updateUBOMapping(_, b); const B = e.render.frame; s[_.id] !== B && (p(_), s[_.id] = B) } function h(_) { const M = d(); _.__bindingPointIndex = M; const S = n.createBuffer(), b = _.__size, B = _.usage; return n.bindBuffer(35345, S), n.bufferData(35345, b, B), n.bindBuffer(35345, null), n.bindBufferBase(35345, M, S), S } function d() { for (let _ = 0; _ < a; _++)if (o.indexOf(_) === -1) return o.push(_), _; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function p(_) { const M = r[_.id], S = _.uniforms, b = _.__cache; n.bindBuffer(35345, M); for (let B = 0, R = S.length; B < R; B++) { const E = S[B]; if (m(E, B, b) === !0) { const P = E.__offset, L = Array.isArray(E.value) ? E.value : [E.value]; let z = 0; for (let Z = 0; Z < L.length; Z++) { const J = L[Z], V = y(J); typeof J == "number" ? (E.__data[0] = J, n.bufferSubData(35345, P + z, E.__data)) : J.isMatrix3 ? (E.__data[0] = J.elements[0], E.__data[1] = J.elements[1], E.__data[2] = J.elements[2], E.__data[3] = J.elements[0], E.__data[4] = J.elements[3], E.__data[5] = J.elements[4], E.__data[6] = J.elements[5], E.__data[7] = J.elements[0], E.__data[8] = J.elements[6], E.__data[9] = J.elements[7], E.__data[10] = J.elements[8], E.__data[11] = J.elements[0]) : (J.toArray(E.__data, z), z += V.storage / Float32Array.BYTES_PER_ELEMENT) } n.bufferSubData(35345, P, E.__data) } } n.bindBuffer(35345, null) } function m(_, M, S) { const b = _.value; if (S[M] === void 0) { if (typeof b == "number") S[M] = b; else { const B = Array.isArray(b) ? b : [b], R = []; for (let E = 0; E < B.length; E++)R.push(B[E].clone()); S[M] = R } return !0 } else if (typeof b == "number") { if (S[M] !== b) return S[M] = b, !0 } else { const B = Array.isArray(S[M]) ? S[M] : [S[M]], R = Array.isArray(b) ? b : [b]; for (let E = 0; E < B.length; E++) { const P = B[E]; if (P.equals(R[E]) === !1) return P.copy(R[E]), !0 } } return !1 } function v(_) { const M = _.uniforms; let S = 0; const b = 16; let B = 0; for (let R = 0, E = M.length; R < E; R++) { const P = M[R], L = { boundary: 0, storage: 0 }, z = Array.isArray(P.value) ? P.value : [P.value]; for (let Z = 0, J = z.length; Z < J; Z++) { const V = z[Z], K = y(V); L.boundary += K.boundary, L.storage += K.storage } if (P.__data = new Float32Array(L.storage / Float32Array.BYTES_PER_ELEMENT), P.__offset = S, R > 0) { B = S % b; const Z = b - B; B !== 0 && Z - L.boundary < 0 && (S += b - B, P.__offset = S) } S += L.storage } return B = S % b, B > 0 && (S += b - B), _.__size = S, _.__cache = {}, this } function y(_) { const M = { boundary: 0, storage: 0 }; return typeof _ == "number" ? (M.boundary = 4, M.storage = 4) : _.isVector2 ? (M.boundary = 8, M.storage = 8) : _.isVector3 || _.isColor ? (M.boundary = 16, M.storage = 12) : _.isVector4 ? (M.boundary = 16, M.storage = 16) : _.isMatrix3 ? (M.boundary = 48, M.storage = 48) : _.isMatrix4 ? (M.boundary = 64, M.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), M } function x(_) { const M = _.target; M.removeEventListener("dispose", x); const S = o.indexOf(M.__bindingPointIndex); o.splice(S, 1), n.deleteBuffer(r[M.id]), delete r[M.id], delete s[M.id] } function A() { for (const _ in r) n.deleteBuffer(r[_]); o = [], r = {}, s = {} } return { bind: l, update: u, dispose: A } } function Tk() { const n = Qf("canvas"); return n.style.display = "block", n } function L0(n = {}) { this.isWebGLRenderer = !0; const e = n.canvas !== void 0 ? n.canvas : Tk(), t = n.context !== void 0 ? n.context : null, i = n.depth !== void 0 ? n.depth : !0, r = n.stencil !== void 0 ? n.stencil : !0, s = n.antialias !== void 0 ? n.antialias : !1, o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0, a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1, l = n.powerPreference !== void 0 ? n.powerPreference : "default", u = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1; let h; t !== null ? h = t.getContextAttributes().alpha : h = n.alpha !== void 0 ? n.alpha : !1; let d = null, p = null; const m = [], v = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Js, this.useLegacyLights = !0, this.toneMapping = Fr, this.toneMappingExposure = 1; const y = this; let x = !1, A = 0, _ = 0, M = null, S = -1, b = null; const B = new Ft, R = new Ft; let E = null, P = e.width, L = e.height, z = 1, Z = null, J = null; const V = new Ft(0, 0, P, L), K = new Ft(0, 0, P, L); let ee = !1; const le = new P0; let N = !1, H = !1, W = null; const se = new st, j = new D, oe = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function ve() { return M === null ? z : 1 } let q = t; function Te(F, ne) { for (let fe = 0; fe < F.length; fe++) { const $ = F[fe], ge = e.getContext($, ne); if (ge !== null) return ge } return null } try { const F = { alpha: !0, depth: i, stencil: r, antialias: s, premultipliedAlpha: o, preserveDrawingBuffer: a, powerPreference: l, failIfMajorPerformanceCaveat: u }; if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${S0}`), e.addEventListener("webglcontextlost", he, !1), e.addEventListener("webglcontextrestored", Ae, !1), e.addEventListener("webglcontextcreationerror", Be, !1), q === null) { const ne = ["webgl2", "webgl", "experimental-webgl"]; if (y.isWebGL1Renderer === !0 && ne.shift(), q = Te(ne, F), q === null) throw Te(ne) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } q.getShaderPrecisionFormat === void 0 && (q.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (F) { throw console.error("THREE.WebGLRenderer: " + F.message), F } let Se, Fe, ze, Le, be, de, pe, _e, Ve, Ie, Qe, Xe, Ze, gt, wt, O, I, ie, we, Ce, Pe, Ye, Oe, ye; function $e() { Se = new W7(q), Fe = new O7(q, Se, n), Se.init(Fe), Ye = new K5(q, Se, Fe), ze = new _k(q, Se, Fe), Le = new X7, be = new uk, de = new wk(q, Se, ze, be, Fe, Ye, Le), pe = new U7(y), _e = new V7(y), Ve = new nI(q, Fe), Oe = new k7(q, Se, Ve, Fe), Ie = new j7(q, Ve, Le, Oe), Qe = new q7(q, Ie, Ve, Le), we = new Y7(q, Fe, de), O = new z7(be), Xe = new ck(y, pe, _e, Se, Fe, Oe, O), Ze = new Ek(y, be), gt = new hk, wt = new vk(Se, Fe), ie = new F7(y, pe, _e, ze, Qe, h, o), I = new Mk(y, Qe, Fe), ye = new bk(q, Le, Fe, ze), Ce = new N7(q, Se, Le, Fe), Pe = new J7(q, Se, Le, Fe), Le.programs = Xe.programs, y.capabilities = Fe, y.extensions = Se, y.properties = be, y.renderLists = gt, y.shadowMap = I, y.state = ze, y.info = Le } $e(); const G = new Ck(y, q); this.xr = G, this.getContext = function () { return q }, this.getContextAttributes = function () { return q.getContextAttributes() }, this.forceContextLoss = function () { const F = Se.get("WEBGL_lose_context"); F && F.loseContext() }, this.forceContextRestore = function () { const F = Se.get("WEBGL_lose_context"); F && F.restoreContext() }, this.getPixelRatio = function () { return z }, this.setPixelRatio = function (F) { F !== void 0 && (z = F, this.setSize(P, L, !1)) }, this.getSize = function (F) { return F.set(P, L) }, this.setSize = function (F, ne, fe = !0) { if (G.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } P = F, L = ne, e.width = Math.floor(F * z), e.height = Math.floor(ne * z), fe === !0 && (e.style.width = F + "px", e.style.height = ne + "px"), this.setViewport(0, 0, F, ne) }, this.getDrawingBufferSize = function (F) { return F.set(P * z, L * z).floor() }, this.setDrawingBufferSize = function (F, ne, fe) { P = F, L = ne, z = fe, e.width = Math.floor(F * fe), e.height = Math.floor(ne * fe), this.setViewport(0, 0, F, ne) }, this.getCurrentViewport = function (F) { return F.copy(B) }, this.getViewport = function (F) { return F.copy(V) }, this.setViewport = function (F, ne, fe, $) { F.isVector4 ? V.set(F.x, F.y, F.z, F.w) : V.set(F, ne, fe, $), ze.viewport(B.copy(V).multiplyScalar(z).floor()) }, this.getScissor = function (F) { return F.copy(K) }, this.setScissor = function (F, ne, fe, $) { F.isVector4 ? K.set(F.x, F.y, F.z, F.w) : K.set(F, ne, fe, $), ze.scissor(R.copy(K).multiplyScalar(z).floor()) }, this.getScissorTest = function () { return ee }, this.setScissorTest = function (F) { ze.setScissorTest(ee = F) }, this.setOpaqueSort = function (F) { Z = F }, this.setTransparentSort = function (F) { J = F }, this.getClearColor = function (F) { return F.copy(ie.getClearColor()) }, this.setClearColor = function () { ie.setClearColor.apply(ie, arguments) }, this.getClearAlpha = function () { return ie.getClearAlpha() }, this.setClearAlpha = function () { ie.setClearAlpha.apply(ie, arguments) }, this.clear = function (F = !0, ne = !0, fe = !0) { let $ = 0; F && ($ |= 16384), ne && ($ |= 256), fe && ($ |= 1024), q.clear($) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", he, !1), e.removeEventListener("webglcontextrestored", Ae, !1), e.removeEventListener("webglcontextcreationerror", Be, !1), gt.dispose(), wt.dispose(), be.dispose(), pe.dispose(), _e.dispose(), Qe.dispose(), Oe.dispose(), ye.dispose(), Xe.dispose(), G.dispose(), G.removeEventListener("sessionstart", xe), G.removeEventListener("sessionend", Ue), W && (W.dispose(), W = null), Je.stop() }; function he(F) { F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0 } function Ae() { console.log("THREE.WebGLRenderer: Context Restored."), x = !1; const F = Le.autoReset, ne = I.enabled, fe = I.autoUpdate, $ = I.needsUpdate, ge = I.type; $e(), Le.autoReset = F, I.enabled = ne, I.autoUpdate = fe, I.needsUpdate = $, I.type = ge } function Be(F) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage) } function tt(F) { const ne = F.target; ne.removeEventListener("dispose", tt), vt(ne) } function vt(F) { Ht(F), be.remove(F) } function Ht(F) { const ne = be.get(F).programs; ne !== void 0 && (ne.forEach(function (fe) { Xe.releaseProgram(fe) }), F.isShaderMaterial && Xe.releaseShaderCache(F)) } this.renderBufferDirect = function (F, ne, fe, $, ge, et) { ne === null && (ne = oe); const ot = ge.isMesh && ge.matrixWorld.determinant() < 0, ft = tg(F, ne, fe, $, ge); ze.setMaterial($, ot); let pt = fe.index, Ct = 1; $.wireframe === !0 && (pt = Ie.getWireframeAttribute(fe), Ct = 2); const xt = fe.drawRange, Mt = fe.attributes.position; let an = xt.start * Ct, li = (xt.start + xt.count) * Ct; et !== null && (an = Math.max(an, et.start * Ct), li = Math.min(li, (et.start + et.count) * Ct)), pt !== null ? (an = Math.max(an, 0), li = Math.min(li, pt.count)) : Mt != null && (an = Math.max(an, 0), li = Math.min(li, Mt.count)); const vr = li - an; if (vr < 0 || vr === 1 / 0) return; Oe.setup(ge, $, ft, fe, pt); let fs, ln = Ce; if (pt !== null && (fs = Ve.get(pt), ln = Pe, ln.setIndex(fs)), ge.isMesh) $.wireframe === !0 ? (ze.setLineWidth($.wireframeLinewidth * ve()), ln.setMode(1)) : ln.setMode(4); else if (ge.isLine) { let yt = $.linewidth; yt === void 0 && (yt = 1), ze.setLineWidth(yt * ve()), ge.isLineSegments ? ln.setMode(1) : ge.isLineLoop ? ln.setMode(2) : ln.setMode(3) } else ge.isPoints ? ln.setMode(0) : ge.isSprite && ln.setMode(4); if (ge.isInstancedMesh) ln.renderInstances(an, vr, ge.count); else if (fe.isInstancedBufferGeometry) { const yt = fe._maxInstanceCount !== void 0 ? fe._maxInstanceCount : 1 / 0, hs = Math.min(fe.instanceCount, yt); ln.renderInstances(an, vr, hs) } else ln.render(an, vr) }, this.compile = function (F, ne) { function fe($, ge, et) { $.transparent === !0 && $.side === Lr && $.forceSinglePass === !1 ? ($.side = Bi, $.needsUpdate = !0, ai($, ge, et), $.side = as, $.needsUpdate = !0, ai($, ge, et), $.side = Lr) : ai($, ge, et) } p = wt.get(F), p.init(), v.push(p), F.traverseVisible(function ($) { $.isLight && $.layers.test(ne.layers) && (p.pushLight($), $.castShadow && p.pushShadow($)) }), p.setupLights(y.useLegacyLights), F.traverse(function ($) { const ge = $.material; if (ge) if (Array.isArray(ge)) for (let et = 0; et < ge.length; et++) { const ot = ge[et]; fe(ot, F, $) } else fe(ge, F, $) }), v.pop(), p = null }; let X = null; function ae(F) { X && X(F) } function xe() { Je.stop() } function Ue() { Je.start() } const Je = new W5; Je.setAnimationLoop(ae), typeof self < "u" && Je.setContext(self), this.setAnimationLoop = function (F) { X = F, G.setAnimationLoop(F), F === null ? Je.stop() : Je.start() }, G.addEventListener("sessionstart", xe), G.addEventListener("sessionend", Ue), this.render = function (F, ne) { if (ne !== void 0 && ne.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (x === !0) return; F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), ne.parent === null && ne.matrixWorldAutoUpdate === !0 && ne.updateMatrixWorld(), G.enabled === !0 && G.isPresenting === !0 && (G.cameraAutoUpdate === !0 && G.updateCamera(ne), ne = G.getCamera()), F.isScene === !0 && F.onBeforeRender(y, F, ne, M), p = wt.get(F, v.length), p.init(), v.push(p), se.multiplyMatrices(ne.projectionMatrix, ne.matrixWorldInverse), le.setFromProjectionMatrix(se), H = this.localClippingEnabled, N = O.init(this.clippingPlanes, H), d = gt.get(F, m.length), d.init(), m.push(d), Nt(F, ne, 0, y.sortObjects), d.finish(), y.sortObjects === !0 && d.sort(Z, J), N === !0 && O.beginShadows(); const fe = p.state.shadowsArray; if (I.render(fe, F, ne), N === !0 && O.endShadows(), this.info.autoReset === !0 && this.info.reset(), ie.render(d, F), p.setupLights(y.useLegacyLights), ne.isArrayCamera) { const $ = ne.cameras; for (let ge = 0, et = $.length; ge < et; ge++) { const ot = $[ge]; mn(d, F, ot, ot.viewport) } } else mn(d, F, ne); M !== null && (de.updateMultisampleRenderTarget(M), de.updateRenderTargetMipmap(M)), F.isScene === !0 && F.onAfterRender(y, F, ne), Oe.resetDefaultState(), S = -1, b = null, v.pop(), v.length > 0 ? p = v[v.length - 1] : p = null, m.pop(), m.length > 0 ? d = m[m.length - 1] : d = null }; function Nt(F, ne, fe, $) { if (F.visible === !1) return; if (F.layers.test(ne.layers)) { if (F.isGroup) fe = F.renderOrder; else if (F.isLOD) F.autoUpdate === !0 && F.update(ne); else if (F.isLight) p.pushLight(F), F.castShadow && p.pushShadow(F); else if (F.isSprite) { if (!F.frustumCulled || le.intersectsSprite(F)) { $ && j.setFromMatrixPosition(F.matrixWorld).applyMatrix4(se); const ot = Qe.update(F), ft = F.material; ft.visible && d.push(F, ot, ft, fe, j.z, null) } } else if ((F.isMesh || F.isLine || F.isPoints) && (F.isSkinnedMesh && F.skeleton.frame !== Le.render.frame && (F.skeleton.update(), F.skeleton.frame = Le.render.frame), !F.frustumCulled || le.intersectsObject(F))) { $ && j.setFromMatrixPosition(F.matrixWorld).applyMatrix4(se); const ot = Qe.update(F), ft = F.material; if (Array.isArray(ft)) { const pt = ot.groups; for (let Ct = 0, xt = pt.length; Ct < xt; Ct++) { const Mt = pt[Ct], an = ft[Mt.materialIndex]; an && an.visible && d.push(F, ot, an, fe, j.z, Mt) } } else ft.visible && d.push(F, ot, ft, fe, j.z, null) } } const et = F.children; for (let ot = 0, ft = et.length; ot < ft; ot++)Nt(et[ot], ne, fe, $) } function mn(F, ne, fe, $) { const ge = F.opaque, et = F.transmissive, ot = F.transparent; p.setupLightsView(fe), N === !0 && O.setGlobalState(y.clippingPlanes, fe), et.length > 0 && zn(ge, ne, fe), $ && ze.viewport(B.copy($)), ge.length > 0 && Ri(ge, ne, fe), et.length > 0 && Ri(et, ne, fe), ot.length > 0 && Ri(ot, ne, fe), ze.buffers.depth.setTest(!0), ze.buffers.depth.setMask(!0), ze.buffers.color.setMask(!0), ze.setPolygonOffset(!1) } function zn(F, ne, fe) { const $ = Fe.isWebGL2; W === null && (W = new Or(1024, 1024, { generateMipmaps: !0, type: Se.has("EXT_color_buffer_half_float") ? Ic : js, minFilter: ls, samples: $ && s === !0 ? 4 : 0 })); const ge = y.getRenderTarget(); y.setRenderTarget(W), y.clear(); const et = y.toneMapping; y.toneMapping = Fr, Ri(F, ne, fe), y.toneMapping = et, de.updateMultisampleRenderTarget(W), de.updateRenderTargetMipmap(W), y.setRenderTarget(ge) } function Ri(F, ne, fe) { const $ = ne.isScene === !0 ? ne.overrideMaterial : null; for (let ge = 0, et = F.length; ge < et; ge++) { const ot = F[ge], ft = ot.object, pt = ot.geometry, Ct = $ === null ? ot.material : $, xt = ot.group; ft.layers.test(fe.layers) && Jt(ft, ne, fe, pt, Ct, xt) } } function Jt(F, ne, fe, $, ge, et) { F.onBeforeRender(y, ne, fe, $, ge, et), F.modelViewMatrix.multiplyMatrices(fe.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), ge.onBeforeRender(y, ne, fe, $, F, et), ge.transparent === !0 && ge.side === Lr && ge.forceSinglePass === !1 ? (ge.side = Bi, ge.needsUpdate = !0, y.renderBufferDirect(fe, ne, $, ge, F, et), ge.side = as, ge.needsUpdate = !0, y.renderBufferDirect(fe, ne, $, ge, F, et), ge.side = Lr) : y.renderBufferDirect(fe, ne, $, ge, F, et), F.onAfterRender(y, ne, fe, $, ge, et) } function ai(F, ne, fe) { ne.isScene !== !0 && (ne = oe); const $ = be.get(F), ge = p.state.lights, et = p.state.shadowsArray, ot = ge.state.version, ft = Xe.getParameters(F, ge.state, et, ne, fe), pt = Xe.getProgramCacheKey(ft); let Ct = $.programs; $.environment = F.isMeshStandardMaterial ? ne.environment : null, $.fog = ne.fog, $.envMap = (F.isMeshStandardMaterial ? _e : pe).get(F.envMap || $.environment), Ct === void 0 && (F.addEventListener("dispose", tt), Ct = new Map, $.programs = Ct); let xt = Ct.get(pt); if (xt !== void 0) { if ($.currentProgram === xt && $.lightsStateVersion === ot) return Yi(F, ft), xt } else ft.uniforms = Xe.getUniforms(F), F.onBuild(fe, ft, y), F.onBeforeCompile(ft, y), xt = Xe.acquireProgram(ft, pt), Ct.set(pt, xt), $.uniforms = ft.uniforms; const Mt = $.uniforms; (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (Mt.clippingPlanes = O.uniform), Yi(F, ft), $.needsLights = Uh(F), $.lightsStateVersion = ot, $.needsLights && (Mt.ambientLightColor.value = ge.state.ambient, Mt.lightProbe.value = ge.state.probe, Mt.directionalLights.value = ge.state.directional, Mt.directionalLightShadows.value = ge.state.directionalShadow, Mt.spotLights.value = ge.state.spot, Mt.spotLightShadows.value = ge.state.spotShadow, Mt.rectAreaLights.value = ge.state.rectArea, Mt.ltc_1.value = ge.state.rectAreaLTC1, Mt.ltc_2.value = ge.state.rectAreaLTC2, Mt.pointLights.value = ge.state.point, Mt.pointLightShadows.value = ge.state.pointShadow, Mt.hemisphereLights.value = ge.state.hemi, Mt.directionalShadowMap.value = ge.state.directionalShadowMap, Mt.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, Mt.spotShadowMap.value = ge.state.spotShadowMap, Mt.spotLightMatrix.value = ge.state.spotLightMatrix, Mt.spotLightMap.value = ge.state.spotLightMap, Mt.pointShadowMap.value = ge.state.pointShadowMap, Mt.pointShadowMatrix.value = ge.state.pointShadowMatrix); const an = xt.getUniforms(), li = hm.seqWithValue(an.seq, Mt); return $.currentProgram = xt, $.uniformsList = li, xt } function Yi(F, ne) { const fe = be.get(F); fe.outputEncoding = ne.outputEncoding, fe.instancing = ne.instancing, fe.skinning = ne.skinning, fe.morphTargets = ne.morphTargets, fe.morphNormals = ne.morphNormals, fe.morphColors = ne.morphColors, fe.morphTargetsCount = ne.morphTargetsCount, fe.numClippingPlanes = ne.numClippingPlanes, fe.numIntersection = ne.numClipIntersection, fe.vertexAlphas = ne.vertexAlphas, fe.vertexTangents = ne.vertexTangents, fe.toneMapping = ne.toneMapping } function tg(F, ne, fe, $, ge) { ne.isScene !== !0 && (ne = oe), de.resetTextureUnits(); const et = ne.fog, ot = $.isMeshStandardMaterial ? ne.environment : null, ft = M === null ? y.outputEncoding : M.isXRRenderTarget === !0 ? M.texture.encoding : Js, pt = ($.isMeshStandardMaterial ? _e : pe).get($.envMap || ot), Ct = $.vertexColors === !0 && !!fe.attributes.color && fe.attributes.color.itemSize === 4, xt = !!$.normalMap && !!fe.attributes.tangent, Mt = !!fe.morphAttributes.position, an = !!fe.morphAttributes.normal, li = !!fe.morphAttributes.color, vr = $.toneMapped ? y.toneMapping : Fr, fs = fe.morphAttributes.position || fe.morphAttributes.normal || fe.morphAttributes.color, ln = fs !== void 0 ? fs.length : 0, yt = be.get($), hs = p.state.lights; if (N === !0 && (H === !0 || F !== b)) { const un = F === b && $.id === S; O.setState($, F, un) } let cn = !1; $.version === yt.__version ? (yt.needsLights && yt.lightsStateVersion !== hs.state.version || yt.outputEncoding !== ft || ge.isInstancedMesh && yt.instancing === !1 || !ge.isInstancedMesh && yt.instancing === !0 || ge.isSkinnedMesh && yt.skinning === !1 || !ge.isSkinnedMesh && yt.skinning === !0 || yt.envMap !== pt || $.fog === !0 && yt.fog !== et || yt.numClippingPlanes !== void 0 && (yt.numClippingPlanes !== O.numPlanes || yt.numIntersection !== O.numIntersection) || yt.vertexAlphas !== Ct || yt.vertexTangents !== xt || yt.morphTargets !== Mt || yt.morphNormals !== an || yt.morphColors !== li || yt.toneMapping !== vr || Fe.isWebGL2 === !0 && yt.morphTargetsCount !== ln) && (cn = !0) : (cn = !0, yt.__version = $.version); let xr = yt.currentProgram; cn === !0 && (xr = ai($, ne, ge)); let Gh = !1, ds = !1, Hr = !1; const Xt = xr.getUniforms(), Tt = yt.uniforms; if (ze.useProgram(xr.program) && (Gh = !0, ds = !0, Hr = !0), $.id !== S && (S = $.id, ds = !0), Gh || b !== F) { if (Xt.setValue(q, "projectionMatrix", F.projectionMatrix), Fe.logarithmicDepthBuffer && Xt.setValue(q, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)), b !== F && (b = F, ds = !0, Hr = !0), $.isShaderMaterial || $.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshStandardMaterial || $.envMap) { const un = Xt.map.cameraPosition; un !== void 0 && un.setValue(q, j.setFromMatrixPosition(F.matrixWorld)) } ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial) && Xt.setValue(q, "isOrthographic", F.isOrthographicCamera === !0), ($.isMeshPhongMaterial || $.isMeshToonMaterial || $.isMeshLambertMaterial || $.isMeshBasicMaterial || $.isMeshStandardMaterial || $.isShaderMaterial || $.isShadowMaterial || ge.isSkinnedMesh) && Xt.setValue(q, "viewMatrix", F.matrixWorldInverse) } if (ge.isSkinnedMesh) { Xt.setOptional(q, ge, "bindMatrix"), Xt.setOptional(q, ge, "bindMatrixInverse"); const un = ge.skeleton; un && (Fe.floatVertexTextures ? (un.boneTexture === null && un.computeBoneTexture(), Xt.setValue(q, "boneTexture", un.boneTexture, de), Xt.setValue(q, "boneTextureSize", un.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const Dt = fe.morphAttributes; if ((Dt.position !== void 0 || Dt.normal !== void 0 || Dt.color !== void 0 && Fe.isWebGL2 === !0) && we.update(ge, fe, xr), (ds || yt.receiveShadow !== ge.receiveShadow) && (yt.receiveShadow = ge.receiveShadow, Xt.setValue(q, "receiveShadow", ge.receiveShadow)), $.isMeshGouraudMaterial && $.envMap !== null && (Tt.envMap.value = pt, Tt.flipEnvMap.value = pt.isCubeTexture && pt.isRenderTargetTexture === !1 ? -1 : 1), ds && (Xt.setValue(q, "toneMappingExposure", y.toneMappingExposure), yt.needsLights && ng(Tt, Hr), et && $.fog === !0 && Ze.refreshFogUniforms(Tt, et), Ze.refreshMaterialUniforms(Tt, $, z, L, W), hm.upload(q, yt.uniformsList, Tt, de)), $.isShaderMaterial && $.uniformsNeedUpdate === !0 && (hm.upload(q, yt.uniformsList, Tt, de), $.uniformsNeedUpdate = !1), $.isSpriteMaterial && Xt.setValue(q, "center", ge.center), Xt.setValue(q, "modelViewMatrix", ge.modelViewMatrix), Xt.setValue(q, "normalMatrix", ge.normalMatrix), Xt.setValue(q, "modelMatrix", ge.matrixWorld), $.isShaderMaterial || $.isRawShaderMaterial) { const un = $.uniformsGroups; for (let An = 0, Xn = un.length; An < Xn; An++)if (Fe.isWebGL2) { const Vr = un[An]; ye.update(Vr, xr), ye.bind(Vr, xr) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return xr } function ng(F, ne) { F.ambientLightColor.needsUpdate = ne, F.lightProbe.needsUpdate = ne, F.directionalLights.needsUpdate = ne, F.directionalLightShadows.needsUpdate = ne, F.pointLights.needsUpdate = ne, F.pointLightShadows.needsUpdate = ne, F.spotLights.needsUpdate = ne, F.spotLightShadows.needsUpdate = ne, F.rectAreaLights.needsUpdate = ne, F.hemisphereLights.needsUpdate = ne } function Uh(F) { return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0 } this.getActiveCubeFace = function () { return A }, this.getActiveMipmapLevel = function () { return _ }, this.getRenderTarget = function () { return M }, this.setRenderTargetTextures = function (F, ne, fe) { be.get(F.texture).__webglTexture = ne, be.get(F.depthTexture).__webglTexture = fe; const $ = be.get(F); $.__hasExternalTextures = !0, $.__hasExternalTextures && ($.__autoAllocateDepthBuffer = fe === void 0, $.__autoAllocateDepthBuffer || Se.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), $.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (F, ne) { const fe = be.get(F); fe.__webglFramebuffer = ne, fe.__useDefaultFramebuffer = ne === void 0 }, this.setRenderTarget = function (F, ne = 0, fe = 0) { M = F, A = ne, _ = fe; let $ = !0, ge = null, et = !1, ot = !1; if (F) { const pt = be.get(F); pt.__useDefaultFramebuffer !== void 0 ? (ze.bindFramebuffer(36160, null), $ = !1) : pt.__webglFramebuffer === void 0 ? de.setupRenderTarget(F) : pt.__hasExternalTextures && de.rebindTextures(F, be.get(F.texture).__webglTexture, be.get(F.depthTexture).__webglTexture); const Ct = F.texture; (Ct.isData3DTexture || Ct.isDataArrayTexture || Ct.isCompressedArrayTexture) && (ot = !0); const xt = be.get(F).__webglFramebuffer; F.isWebGLCubeRenderTarget ? (ge = xt[ne], et = !0) : Fe.isWebGL2 && F.samples > 0 && de.useMultisampledRTT(F) === !1 ? ge = be.get(F).__webglMultisampledFramebuffer : ge = xt, B.copy(F.viewport), R.copy(F.scissor), E = F.scissorTest } else B.copy(V).multiplyScalar(z).floor(), R.copy(K).multiplyScalar(z).floor(), E = ee; if (ze.bindFramebuffer(36160, ge) && Fe.drawBuffers && $ && ze.drawBuffers(F, ge), ze.viewport(B), ze.scissor(R), ze.setScissorTest(E), et) { const pt = be.get(F.texture); q.framebufferTexture2D(36160, 36064, 34069 + ne, pt.__webglTexture, fe) } else if (ot) { const pt = be.get(F.texture), Ct = ne || 0; q.framebufferTextureLayer(36160, 36064, pt.__webglTexture, fe || 0, Ct) } S = -1 }, this.readRenderTargetPixels = function (F, ne, fe, $, ge, et, ot) { if (!(F && F.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let ft = be.get(F).__webglFramebuffer; if (F.isWebGLCubeRenderTarget && ot !== void 0 && (ft = ft[ot]), ft) { ze.bindFramebuffer(36160, ft); try { const pt = F.texture, Ct = pt.format, xt = pt.type; if (Ct !== Si && Ye.convert(Ct) !== q.getParameter(35739)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const Mt = xt === Ic && (Se.has("EXT_color_buffer_half_float") || Fe.isWebGL2 && Se.has("EXT_color_buffer_float")); if (xt !== js && Ye.convert(xt) !== q.getParameter(35738) && !(xt === Is && (Fe.isWebGL2 || Se.has("OES_texture_float") || Se.has("WEBGL_color_buffer_float"))) && !Mt) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ne >= 0 && ne <= F.width - $ && fe >= 0 && fe <= F.height - ge && q.readPixels(ne, fe, $, ge, Ye.convert(Ct), Ye.convert(xt), et) } finally { const pt = M !== null ? be.get(M).__webglFramebuffer : null; ze.bindFramebuffer(36160, pt) } } }, this.copyFramebufferToTexture = function (F, ne, fe = 0) { const $ = Math.pow(2, -fe), ge = Math.floor(ne.image.width * $), et = Math.floor(ne.image.height * $); de.setTexture2D(ne, 0), q.copyTexSubImage2D(3553, fe, 0, 0, F.x, F.y, ge, et), ze.unbindTexture() }, this.copyTextureToTexture = function (F, ne, fe, $ = 0) { const ge = ne.image.width, et = ne.image.height, ot = Ye.convert(fe.format), ft = Ye.convert(fe.type); de.setTexture2D(fe, 0), q.pixelStorei(37440, fe.flipY), q.pixelStorei(37441, fe.premultiplyAlpha), q.pixelStorei(3317, fe.unpackAlignment), ne.isDataTexture ? q.texSubImage2D(3553, $, F.x, F.y, ge, et, ot, ft, ne.image.data) : ne.isCompressedTexture ? q.compressedTexSubImage2D(3553, $, F.x, F.y, ne.mipmaps[0].width, ne.mipmaps[0].height, ot, ne.mipmaps[0].data) : q.texSubImage2D(3553, $, F.x, F.y, ot, ft, ne.image), $ === 0 && fe.generateMipmaps && q.generateMipmap(3553), ze.unbindTexture() }, this.copyTextureToTexture3D = function (F, ne, fe, $, ge = 0) { if (y.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const et = F.max.x - F.min.x + 1, ot = F.max.y - F.min.y + 1, ft = F.max.z - F.min.z + 1, pt = Ye.convert($.format), Ct = Ye.convert($.type); let xt; if ($.isData3DTexture) de.setTexture3D($, 0), xt = 32879; else if ($.isDataArrayTexture) de.setTexture2DArray($, 0), xt = 35866; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } q.pixelStorei(37440, $.flipY), q.pixelStorei(37441, $.premultiplyAlpha), q.pixelStorei(3317, $.unpackAlignment); const Mt = q.getParameter(3314), an = q.getParameter(32878), li = q.getParameter(3316), vr = q.getParameter(3315), fs = q.getParameter(32877), ln = fe.isCompressedTexture ? fe.mipmaps[0] : fe.image; q.pixelStorei(3314, ln.width), q.pixelStorei(32878, ln.height), q.pixelStorei(3316, F.min.x), q.pixelStorei(3315, F.min.y), q.pixelStorei(32877, F.min.z), fe.isDataTexture || fe.isData3DTexture ? q.texSubImage3D(xt, ge, ne.x, ne.y, ne.z, et, ot, ft, pt, Ct, ln.data) : fe.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), q.compressedTexSubImage3D(xt, ge, ne.x, ne.y, ne.z, et, ot, ft, pt, ln.data)) : q.texSubImage3D(xt, ge, ne.x, ne.y, ne.z, et, ot, ft, pt, Ct, ln), q.pixelStorei(3314, Mt), q.pixelStorei(32878, an), q.pixelStorei(3316, li), q.pixelStorei(3315, vr), q.pixelStorei(32877, fs), ge === 0 && $.generateMipmaps && q.generateMipmap(xt), ze.unbindTexture() }, this.initTexture = function (F) { F.isCubeTexture ? de.setTextureCube(F, 0) : F.isData3DTexture ? de.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? de.setTexture2DArray(F, 0) : de.setTexture2D(F, 0), ze.unbindTexture() }, this.resetState = function () { A = 0, _ = 0, M = null, ze.reset(), Oe.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } Object.defineProperties(L0.prototype, { physicallyCorrectLights: { get: function () { return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights }, set: function (n) { console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !n } } }); class Z5 extends L0 { } Z5.prototype.isWebGL1Renderer = !0; class I0 { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new Re(e), this.density = t } clone() { return new I0(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } class D0 { constructor(e, t = 1, i = 1e3) { this.isFog = !0, this.name = "", this.color = new Re(e), this.near = t, this.far = i } clone() { return new D0(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } class fA extends bt { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t } get autoUpdate() { return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate } set autoUpdate(e) { console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e } } class vh { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Jf, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Vi() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.stride, i *= t.stride; for (let r = 0, s = this.stride; r < s; r++)this.array[e + r] = t.array[i + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride); return i.setUsage(this.usage), i } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const fi = new D; class jo { constructor(e, t, i, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, i = this.data.count; t < i; t++)fi.fromBufferAttribute(this, t), fi.applyMatrix4(e), this.setXYZ(t, fi.x, fi.y, fi.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)fi.fromBufferAttribute(this, t), fi.applyNormalMatrix(e), this.setXYZ(t, fi.x, fi.y, fi.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)fi.fromBufferAttribute(this, t), fi.transformDirection(e), this.setXYZ(t, fi.x, fi.y, fi.z); return this } setX(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Ds(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Ds(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Ds(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Ds(t, this.array)), t } setXY(e, t, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this } setXYZW(e, t, i, r, s) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let i = 0; i < this.count; i++) { const r = i * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return new It(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new jo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let i = 0; i < this.count; i++) { const r = i * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class hA extends En { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Re(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let Hl; const Nu = new D, Vl = new D, Wl = new D, jl = new me, Ou = new me, $5 = new st, yp = new D, zu = new D, vp = new D, Kw = new me, ry = new me, Yw = new me; class eT extends bt { constructor(e) { if (super(), this.isSprite = !0, this.type = "Sprite", Hl === void 0) { Hl = new ut; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), i = new vh(t, 5); Hl.setIndex([0, 1, 2, 0, 2, 3]), Hl.setAttribute("position", new jo(i, 3, 0, !1)), Hl.setAttribute("uv", new jo(i, 2, 3, !1)) } this.geometry = Hl, this.material = e !== void 0 ? e : new hA, this.center = new me(.5, .5) } raycast(e, t) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Vl.setFromMatrixScale(this.matrixWorld), $5.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Wl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Vl.multiplyScalar(-Wl.z); const i = this.material.rotation; let r, s; i !== 0 && (s = Math.cos(i), r = Math.sin(i)); const o = this.center; xp(yp.set(-.5, -.5, 0), Wl, o, Vl, r, s), xp(zu.set(.5, -.5, 0), Wl, o, Vl, r, s), xp(vp.set(.5, .5, 0), Wl, o, Vl, r, s), Kw.set(0, 0), ry.set(1, 0), Yw.set(1, 1); let a = e.ray.intersectTriangle(yp, zu, vp, !1, Nu); if (a === null && (xp(zu.set(-.5, .5, 0), Wl, o, Vl, r, s), ry.set(0, 1), a = e.ray.intersectTriangle(yp, vp, zu, !1, Nu), a === null)) return; const l = e.ray.origin.distanceTo(Nu); l < e.near || l > e.far || t.push({ distance: l, point: Nu.clone(), uv: fr.getUV(Nu, yp, zu, vp, Kw, ry, Yw, new me), face: null, object: this }) } copy(e, t) { return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function xp(n, e, t, i, r, s) { jl.subVectors(n, t).addScalar(.5).multiply(i), r !== void 0 ? (Ou.x = s * jl.x - r * jl.y, Ou.y = r * jl.x + s * jl.y) : Ou.copy(jl), n.copy(e), n.x += Ou.x, n.y += Ou.y, n.applyMatrix4($5) } const Ap = new D, qw = new D; class tT extends bt { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; this.addLevel(s.object.clone(), s.distance, s.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, i = 0) { t = Math.abs(t); const r = this.levels; let s; for (s = 0; s < r.length && !(t < r[s].distance); s++); return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let i, r; for (i = 1, r = t.length; i < r; i++) { let s = t[i].distance; if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break } return t[i - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { Ap.setFromMatrixPosition(this.matrixWorld); const r = e.ray.origin.distanceTo(Ap); this.getObjectForDistance(r).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { Ap.setFromMatrixPosition(e.matrixWorld), qw.setFromMatrixPosition(this.matrixWorld); const i = Ap.distanceTo(qw) / e.zoom; t[0].object.visible = !0; let r, s; for (r = 1, s = t.length; r < s; r++) { let o = t[r].distance; if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = !1, t[r].object.visible = !0; else break } for (this._currentLevel = r - 1; r < s; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = []; const i = this.levels; for (let r = 0, s = i.length; r < s; r++) { const o = i[r]; t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis }) } return t } } const Zw = new D, $w = new Ft, eS = new Ft, Bk = new D, tS = new st; class dA extends Pn { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new st, this.bindMatrixInverse = new st } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Ft, t = this.geometry.attributes.skinWeight; for (let i = 0, r = t.count; i < r; i++) { e.fromBufferAttribute(t, i); const s = 1 / e.manhattanLength(); s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const i = this.skeleton, r = this.geometry; $w.fromBufferAttribute(r.attributes.skinIndex, e), eS.fromBufferAttribute(r.attributes.skinWeight, e), Zw.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let s = 0; s < 4; s++) { const o = eS.getComponent(s); if (o !== 0) { const a = $w.getComponent(s); tS.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(Bk.copy(Zw).applyMatrix4(tS), o) } } return t.applyMatrix4(this.bindMatrixInverse) } } class F0 extends bt { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class wc extends Zt { constructor(e = null, t = 1, i = 1, r, s, o, a, l, u = pn, h = pn, d, p) { super(null, o, a, l, u, h, r, s, d, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const nS = new st, Pk = new st; class xh { constructor(e = [], t = []) { this.uuid = Vi(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let i = 0, r = this.bones.length; i < r; i++)this.boneInverses.push(new st) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const i = new st; this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const i = this.bones[e]; i && i.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const i = this.bones[e]; i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale)) } } update() { const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture; for (let s = 0, o = e.length; s < o; s++) { const a = e[s] ? e[s].matrixWorld : Pk; nS.multiplyMatrices(a, t[s]), nS.toArray(i, s * 16) } r !== null && (r.needsUpdate = !0) } clone() { return new xh(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = O5(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const i = new wc(t, e, e, Si, Is); return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, i = this.bones.length; t < i; t++) { const r = this.bones[t]; if (r.name === e) return r } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let i = 0, r = e.bones.length; i < r; i++) { const s = e.bones[i]; let o = t[s]; o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new F0), this.bones.push(o), this.boneInverses.push(new st().fromArray(e.boneInverses[i])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, i = this.boneInverses; for (let r = 0, s = t.length; r < s; r++) { const o = t[r]; e.bones.push(o.uuid); const a = i[r]; e.boneInverses.push(a.toArray()) } return e } } class Nc extends It { constructor(e, t, i, r = 1) { super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const iS = new st, rS = new st, Mp = [], Rk = new st, Uu = new Pn; class nT extends Pn { constructor(e, t, i) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Nc(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1; for (let r = 0; r < i; r++)this.setMatrixAt(r, Rk) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const i = this.matrixWorld, r = this.count; if (Uu.geometry = this.geometry, Uu.material = this.material, Uu.material !== void 0) for (let s = 0; s < r; s++) { this.getMatrixAt(s, iS), rS.multiplyMatrices(i, iS), Uu.matrixWorld = rS, Uu.raycast(e, Mp); for (let o = 0, a = Mp.length; o < a; o++) { const l = Mp[o]; l.instanceId = s, l.object = this, t.push(l) } Mp.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new Nc(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class oi extends En { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Re(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const sS = new D, oS = new D, aS = new st, sy = new mh, _p = new $o; class Xs extends bt { constructor(e = new ut, t = new oi) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, i = [0]; for (let r = 1, s = t.count; r < s; r++)sS.fromBufferAttribute(t, r - 1), oS.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += sS.distanceTo(oS); e.setAttribute("lineDistance", new je(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange; if (i.boundingSphere === null && i.computeBoundingSphere(), _p.copy(i.boundingSphere), _p.applyMatrix4(r), _p.radius += s, e.ray.intersectsSphere(_p) === !1) return; aS.copy(r).invert(), sy.copy(e.ray).applyMatrix4(aS); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, u = new D, h = new D, d = new D, p = new D, m = this.isLineSegments ? 2 : 1, v = i.index, x = i.attributes.position; if (v !== null) { const A = Math.max(0, o.start), _ = Math.min(v.count, o.start + o.count); for (let M = A, S = _ - 1; M < S; M += m) { const b = v.getX(M), B = v.getX(M + 1); if (u.fromBufferAttribute(x, b), h.fromBufferAttribute(x, B), sy.distanceSqToSegment(u, h, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const E = e.ray.origin.distanceTo(p); E < e.near || E > e.far || t.push({ distance: E, point: d.clone().applyMatrix4(this.matrixWorld), index: M, face: null, faceIndex: null, object: this }) } } else { const A = Math.max(0, o.start), _ = Math.min(x.count, o.start + o.count); for (let M = A, S = _ - 1; M < S; M += m) { if (u.fromBufferAttribute(x, M), h.fromBufferAttribute(x, M + 1), sy.distanceSqToSegment(u, h, p, d) > l) continue; p.applyMatrix4(this.matrixWorld); const B = e.ray.origin.distanceTo(p); B < e.near || B > e.far || t.push({ distance: B, point: d.clone().applyMatrix4(this.matrixWorld), index: M, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } } const lS = new D, cS = new D; class zr extends Xs { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, i = []; for (let r = 0, s = t.count; r < s; r += 2)lS.fromBufferAttribute(t, r), cS.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + lS.distanceTo(cS); e.setAttribute("lineDistance", new je(i, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class pA extends Xs { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class Ah extends En { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Re(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const uS = new st, g2 = new mh, wp = new $o, Sp = new D; let mA = class extends bt { constructor(e = new ut, t = new Ah) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange; if (i.boundingSphere === null && i.computeBoundingSphere(), wp.copy(i.boundingSphere), wp.applyMatrix4(r), wp.radius += s, e.ray.intersectsSphere(wp) === !1) return; uS.copy(r).invert(), g2.copy(e.ray).applyMatrix4(uS); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, u = i.index, d = i.attributes.position; if (u !== null) { const p = Math.max(0, o.start), m = Math.min(u.count, o.start + o.count); for (let v = p, y = m; v < y; v++) { const x = u.getX(v); Sp.fromBufferAttribute(d, x), fS(Sp, x, l, r, e, t, this) } } else { const p = Math.max(0, o.start), m = Math.min(d.count, o.start + o.count); for (let v = p, y = m; v < y; v++)Sp.fromBufferAttribute(d, v), fS(Sp, v, l, r, e, t, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } }; function fS(n, e, t, i, r, s, o) { const a = g2.distanceSqToPoint(n); if (a < t) { const l = new D; g2.closestPointToPoint(n, l), l.applyMatrix4(i); const u = r.ray.origin.distanceTo(l); if (u < r.near || u > r.far) return; s.push({ distance: u, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o }) } } class Lk extends Zt { constructor(e, t, i, r, s, o, a, l, u) { super(e, t, i, r, s, o, a, l, u), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : tn, this.magFilter = s !== void 0 ? s : tn, this.generateMipmaps = !1; const h = this; function d() { h.needsUpdate = !0, e.requestVideoFrameCallback(d) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class Ik extends Zt { constructor(e, t, i) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = i, this.magFilter = pn, this.minFilter = pn, this.generateMipmaps = !1, this.needsUpdate = !0 } } class gA extends Zt { constructor(e, t, i, r, s, o, a, l, u, h, d, p) { super(null, o, a, l, u, h, r, s, d, p), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class Dk extends gA { constructor(e, t, i, r, s, o) { super(e, t, i, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Hn } } class Fk extends Zt { constructor(e, t, i, r, s, o, a, l, u) { super(e, t, i, r, s, o, a, l, u), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class Ur { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const i = this.getUtoTmapping(e); return this.getPoint(i, t) } getPoints(e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPointAt(i / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let i, r = this.getPoint(0), s = 0; t.push(0); for (let o = 1; o <= e; o++)i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const i = this.getLengths(); let r = 0; const s = i.length; let o; t ? o = t : o = e * i[s - 1]; let a = 0, l = s - 1, u; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), u = i[r] - o, u < 0) a = r + 1; else if (u > 0) l = r - 1; else { l = r; break } if (r = l, i[r] === o) return r / (s - 1); const h = i[r], p = i[r + 1] - h, m = (o - h) / p; return (r + m) / (s - 1) } getTangent(e, t) { let r = e - 1e-4, s = e + 1e-4; r < 0 && (r = 0), s > 1 && (s = 1); const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new me : new D); return l.copy(a).sub(o).normalize(), l } getTangentAt(e, t) { const i = this.getUtoTmapping(e); return this.getTangent(i, t) } computeFrenetFrames(e, t) { const i = new D, r = [], s = [], o = [], a = new D, l = new st; for (let m = 0; m <= e; m++) { const v = m / e; r[m] = this.getTangentAt(v, new D) } s[0] = new D, o[0] = new D; let u = Number.MAX_VALUE; const h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z); h <= u && (u = h, i.set(1, 0, 0)), d <= u && (u = d, i.set(0, 1, 0)), p <= u && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]); for (let m = 1; m <= e; m++) { if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(r[m - 1], r[m]), a.length() > Number.EPSILON) { a.normalize(); const v = Math.acos(xn(r[m - 1].dot(r[m]), -1, 1)); s[m].applyMatrix4(l.makeRotationAxis(a, v)) } o[m].crossVectors(r[m], s[m]) } if (t === !0) { let m = Math.acos(xn(s[0].dot(s[e]), -1, 1)); m /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m); for (let v = 1; v <= e; v++)s[v].applyMatrix4(l.makeRotationAxis(r[v], m * v)), o[v].crossVectors(r[v], s[v]) } return { tangents: r, normals: s, binormals: o } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class k0 extends Ur { constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l } getPoint(e, t) { const i = t || new me, r = Math.PI * 2; let s = this.aEndAngle - this.aStartAngle; const o = Math.abs(s) < Number.EPSILON; for (; s < 0;)s += r; for (; s > r;)s -= r; s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r); const a = this.aStartAngle + e * s; let l = this.aX + this.xRadius * Math.cos(a), u = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, m = u - this.aY; l = p * h - m * d + this.aX, u = p * d + m * h + this.aY } return i.set(l, u) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class iT extends k0 { constructor(e, t, i, r, s, o) { super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve" } } function yA() { let n = 0, e = 0, t = 0, i = 0; function r(s, o, a, l) { n = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l } return { initCatmullRom: function (s, o, a, l, u) { r(o, a, u * (a - s), u * (l - o)) }, initNonuniformCatmullRom: function (s, o, a, l, u, h, d) { let p = (o - s) / u - (a - s) / (u + h) + (a - o) / h, m = (a - o) / h - (l - o) / (h + d) + (l - a) / d; p *= h, m *= h, r(o, a, p, m) }, calc: function (s) { const o = s * s, a = o * s; return n + e * s + t * o + i * a } } } const Cp = new D, oy = new yA, ay = new yA, ly = new yA; class rT extends Ur { constructor(e = [], t = !1, i = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r } getPoint(e, t = new D) { const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e; let a = Math.floor(o), l = o - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1); let u, h; this.closed || a > 0 ? u = r[(a - 1) % s] : (Cp.subVectors(r[0], r[1]).add(r[0]), u = Cp); const d = r[a % s], p = r[(a + 1) % s]; if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (Cp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = Cp), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let v = Math.pow(u.distanceToSquared(d), m), y = Math.pow(d.distanceToSquared(p), m), x = Math.pow(p.distanceToSquared(h), m); y < 1e-4 && (y = 1), v < 1e-4 && (v = y), x < 1e-4 && (x = y), oy.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, v, y, x), ay.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, v, y, x), ly.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, v, y, x) } else this.curveType === "catmullrom" && (oy.initCatmullRom(u.x, d.x, p.x, h.x, this.tension), ay.initCatmullRom(u.y, d.y, p.y, h.y, this.tension), ly.initCatmullRom(u.z, d.z, p.z, h.z, this.tension)); return i.set(oy.calc(l), ay.calc(l), ly.calc(l)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(new D().fromArray(r)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function hS(n, e, t, i, r) { const s = (i - e) * .5, o = (r - t) * .5, a = n * n, l = n * a; return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t } function kk(n, e) { const t = 1 - n; return t * t * e } function Nk(n, e) { return 2 * (1 - n) * n * e } function Ok(n, e) { return n * n * e } function mf(n, e, t, i) { return kk(n, e) + Nk(n, t) + Ok(n, i) } function zk(n, e) { const t = 1 - n; return t * t * t * e } function Uk(n, e) { const t = 1 - n; return 3 * t * t * n * e } function Gk(n, e) { return 3 * (1 - n) * n * n * e } function Hk(n, e) { return n * n * n * e } function gf(n, e, t, i, r) { return zk(n, e) + Uk(n, t) + Gk(n, i) + Hk(n, r) } class vA extends Ur { constructor(e = new me, t = new me, i = new me, r = new me) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new me) { const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return i.set(gf(e, r.x, s.x, o.x, a.x), gf(e, r.y, s.y, o.y, a.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class sT extends Ur { constructor(e = new D, t = new D, i = new D, r = new D) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new D) { const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return i.set(gf(e, r.x, s.x, o.x, a.x), gf(e, r.y, s.y, o.y, a.y), gf(e, r.z, s.z, o.z, a.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class N0 extends Ur { constructor(e = new me, t = new me) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new me) { const i = t; return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new me) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class oT extends Ur { constructor(e = new D, t = new D) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new D) { const i = t; return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new D) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class xA extends Ur { constructor(e = new me, t = new me, i = new me) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new me) { const i = t, r = this.v0, s = this.v1, o = this.v2; return i.set(mf(e, r.x, s.x, o.x), mf(e, r.y, s.y, o.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class AA extends Ur { constructor(e = new D, t = new D, i = new D) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new D) { const i = t, r = this.v0, s = this.v1, o = this.v2; return i.set(mf(e, r.x, s.x, o.x), mf(e, r.y, s.y, o.y), mf(e, r.z, s.z, o.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class MA extends Ur { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new me) { const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], u = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2]; return i.set(hS(a, l.x, u.x, h.x, d.x), hS(a, l.y, u.y, h.y, d.y)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(new me().fromArray(r)) } return this } } var _A = Object.freeze({ __proto__: null, ArcCurve: iT, CatmullRomCurve3: rT, CubicBezierCurve: vA, CubicBezierCurve3: sT, EllipseCurve: k0, LineCurve: N0, LineCurve3: oT, QuadraticBezierCurve: xA, QuadraticBezierCurve3: AA, SplineCurve: MA }); class aT extends Ur { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new N0(t, e)) } getPoint(e, t) { const i = e * this.getLength(), r = this.getCurveLengths(); let s = 0; for (; s < r.length;) { if (r[s] >= i) { const o = r[s] - i, a = this.curves[s], l = a.getLength(), u = l === 0 ? 0 : 1 - o / l; return a.getPointAt(u, t) } s++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let i = 0, r = this.curves.length; i < r; i++)t += this.curves[i].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let i; for (let r = 0, s = this.curves; r < s.length; r++) { const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a); for (let u = 0; u < l.length; u++) { const h = l[u]; i && i.equals(h) || (t.push(h), i = h) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const r = e.curves[t]; this.curves.push(r.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, i = this.curves.length; t < i; t++) { const r = this.curves[t]; e.curves.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const r = e.curves[t]; this.curves.push(new _A[r.type]().fromJSON(r)) } return this } } class Kf extends aT { constructor(e) { super(), this.type = "Path", this.currentPoint = new me, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, i = e.length; t < i; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const i = new N0(this.currentPoint.clone(), new me(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, i, r) { const s = new xA(this.currentPoint.clone(), new me(e, t), new me(i, r)); return this.curves.push(s), this.currentPoint.set(i, r), this } bezierCurveTo(e, t, i, r, s, o) { const a = new vA(this.currentPoint.clone(), new me(e, t), new me(i, r), new me(s, o)); return this.curves.push(a), this.currentPoint.set(s, o), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), i = new MA(t); return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, i, r, s, o) { const a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + a, t + l, i, r, s, o), this } absarc(e, t, i, r, s, o) { return this.absellipse(e, t, i, i, r, s, o), this } ellipse(e, t, i, r, s, o, a, l) { const u = this.currentPoint.x, h = this.currentPoint.y; return this.absellipse(e + u, t + h, i, r, s, o, a, l), this } absellipse(e, t, i, r, s, o, a, l) { const u = new k0(e, t, i, r, s, o, a, l); if (this.curves.length > 0) { const d = u.getPoint(0); d.equals(this.currentPoint) || this.lineTo(d.x, d.y) } this.curves.push(u); const h = u.getPoint(1); return this.currentPoint.copy(h), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Yc extends ut { constructor(e = [new me(0, -.5), new me(.5, 0), new me(0, .5)], t = 12, i = 0, r = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = xn(r, 0, Math.PI * 2); const s = [], o = [], a = [], l = [], u = [], h = 1 / t, d = new D, p = new me, m = new D, v = new D, y = new D; let x = 0, A = 0; for (let _ = 0; _ <= e.length - 1; _++)switch (_) { case 0: x = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -x, m.z = A * 0, y.copy(m), m.normalize(), l.push(m.x, m.y, m.z); break; case e.length - 1: l.push(y.x, y.y, y.z); break; default: x = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -x, m.z = A * 0, v.copy(m), m.x += y.x, m.y += y.y, m.z += y.z, m.normalize(), l.push(m.x, m.y, m.z), y.copy(v) }for (let _ = 0; _ <= t; _++) { const M = i + _ * h * r, S = Math.sin(M), b = Math.cos(M); for (let B = 0; B <= e.length - 1; B++) { d.x = e[B].x * S, d.y = e[B].y, d.z = e[B].x * b, o.push(d.x, d.y, d.z), p.x = _ / t, p.y = B / (e.length - 1), a.push(p.x, p.y); const R = l[3 * B + 0] * S, E = l[3 * B + 1], P = l[3 * B + 0] * b; u.push(R, E, P) } } for (let _ = 0; _ < t; _++)for (let M = 0; M < e.length - 1; M++) { const S = M + _ * e.length, b = S, B = S + e.length, R = S + e.length + 1, E = S + 1; s.push(b, B, E), s.push(R, E, B) } this.setIndex(s), this.setAttribute("position", new je(o, 3)), this.setAttribute("uv", new je(a, 2)), this.setAttribute("normal", new je(u, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Yc(e.points, e.segments, e.phiStart, e.phiLength) } } class Mh extends Yc { constructor(e = 1, t = 1, i = 4, r = 8) { const s = new Kf; s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, height: t, capSegments: i, radialSegments: r } } static fromJSON(e) { return new Mh(e.radius, e.length, e.capSegments, e.radialSegments) } } class _h extends ut { constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t); const s = [], o = [], a = [], l = [], u = new D, h = new me; o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5); for (let d = 0, p = 3; d <= t; d++, p += 3) { const m = i + d / t * r; u.x = e * Math.cos(m), u.y = e * Math.sin(m), o.push(u.x, u.y, u.z), a.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, l.push(h.x, h.y) } for (let d = 1; d <= t; d++)s.push(d, d + 1, 0); this.setIndex(s), this.setAttribute("position", new je(o, 3)), this.setAttribute("normal", new je(a, 3)), this.setAttribute("uv", new je(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new _h(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class cl extends ut { constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l }; const u = this; r = Math.floor(r), s = Math.floor(s); const h = [], d = [], p = [], m = []; let v = 0; const y = [], x = i / 2; let A = 0; _(), o === !1 && (e > 0 && M(!0), t > 0 && M(!1)), this.setIndex(h), this.setAttribute("position", new je(d, 3)), this.setAttribute("normal", new je(p, 3)), this.setAttribute("uv", new je(m, 2)); function _() { const S = new D, b = new D; let B = 0; const R = (t - e) / i; for (let E = 0; E <= s; E++) { const P = [], L = E / s, z = L * (t - e) + e; for (let Z = 0; Z <= r; Z++) { const J = Z / r, V = J * l + a, K = Math.sin(V), ee = Math.cos(V); b.x = z * K, b.y = -L * i + x, b.z = z * ee, d.push(b.x, b.y, b.z), S.set(K, R, ee).normalize(), p.push(S.x, S.y, S.z), m.push(J, 1 - L), P.push(v++) } y.push(P) } for (let E = 0; E < r; E++)for (let P = 0; P < s; P++) { const L = y[P][E], z = y[P + 1][E], Z = y[P + 1][E + 1], J = y[P][E + 1]; h.push(L, z, J), h.push(z, Z, J), B += 6 } u.addGroup(A, B, 0), A += B } function M(S) { const b = v, B = new me, R = new D; let E = 0; const P = S === !0 ? e : t, L = S === !0 ? 1 : -1; for (let Z = 1; Z <= r; Z++)d.push(0, x * L, 0), p.push(0, L, 0), m.push(.5, .5), v++; const z = v; for (let Z = 0; Z <= r; Z++) { const V = Z / r * l + a, K = Math.cos(V), ee = Math.sin(V); R.x = P * ee, R.y = x * L, R.z = P * K, d.push(R.x, R.y, R.z), p.push(0, L, 0), B.x = K * .5 + .5, B.y = ee * .5 * L + .5, m.push(B.x, B.y), v++ } for (let Z = 0; Z < r; Z++) { const J = b + Z, V = z + Z; S === !0 ? h.push(V, V + 1, J) : h.push(V + 1, V, J), E += 3 } u.addGroup(A, E, S === !0 ? 1 : 2), A += E } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new cl(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class wh extends cl { constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) { super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a } } static fromJSON(e) { return new wh(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Ys extends ut { constructor(e = [], t = [], i = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r }; const s = [], o = []; a(r), u(i), h(), this.setAttribute("position", new je(s, 3)), this.setAttribute("normal", new je(s.slice(), 3)), this.setAttribute("uv", new je(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a(_) { const M = new D, S = new D, b = new D; for (let B = 0; B < t.length; B += 3)m(t[B + 0], M), m(t[B + 1], S), m(t[B + 2], b), l(M, S, b, _) } function l(_, M, S, b) { const B = b + 1, R = []; for (let E = 0; E <= B; E++) { R[E] = []; const P = _.clone().lerp(S, E / B), L = M.clone().lerp(S, E / B), z = B - E; for (let Z = 0; Z <= z; Z++)Z === 0 && E === B ? R[E][Z] = P : R[E][Z] = P.clone().lerp(L, Z / z) } for (let E = 0; E < B; E++)for (let P = 0; P < 2 * (B - E) - 1; P++) { const L = Math.floor(P / 2); P % 2 === 0 ? (p(R[E][L + 1]), p(R[E + 1][L]), p(R[E][L])) : (p(R[E][L + 1]), p(R[E + 1][L + 1]), p(R[E + 1][L])) } } function u(_) { const M = new D; for (let S = 0; S < s.length; S += 3)M.x = s[S + 0], M.y = s[S + 1], M.z = s[S + 2], M.normalize().multiplyScalar(_), s[S + 0] = M.x, s[S + 1] = M.y, s[S + 2] = M.z } function h() { const _ = new D; for (let M = 0; M < s.length; M += 3) { _.x = s[M + 0], _.y = s[M + 1], _.z = s[M + 2]; const S = x(_) / 2 / Math.PI + .5, b = A(_) / Math.PI + .5; o.push(S, 1 - b) } v(), d() } function d() { for (let _ = 0; _ < o.length; _ += 6) { const M = o[_ + 0], S = o[_ + 2], b = o[_ + 4], B = Math.max(M, S, b), R = Math.min(M, S, b); B > .9 && R < .1 && (M < .2 && (o[_ + 0] += 1), S < .2 && (o[_ + 2] += 1), b < .2 && (o[_ + 4] += 1)) } } function p(_) { s.push(_.x, _.y, _.z) } function m(_, M) { const S = _ * 3; M.x = e[S + 0], M.y = e[S + 1], M.z = e[S + 2] } function v() { const _ = new D, M = new D, S = new D, b = new D, B = new me, R = new me, E = new me; for (let P = 0, L = 0; P < s.length; P += 9, L += 6) { _.set(s[P + 0], s[P + 1], s[P + 2]), M.set(s[P + 3], s[P + 4], s[P + 5]), S.set(s[P + 6], s[P + 7], s[P + 8]), B.set(o[L + 0], o[L + 1]), R.set(o[L + 2], o[L + 3]), E.set(o[L + 4], o[L + 5]), b.copy(_).add(M).add(S).divideScalar(3); const z = x(b); y(B, L + 0, _, z), y(R, L + 2, M, z), y(E, L + 4, S, z) } } function y(_, M, S, b) { b < 0 && _.x === 1 && (o[M] = _.x - 1), S.x === 0 && S.z === 0 && (o[M] = b / 2 / Math.PI + .5) } function x(_) { return Math.atan2(_.z, -_.x) } function A(_) { return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ys(e.vertices, e.indices, e.radius, e.details) } } class Sh extends Ys { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2, r = 1 / i, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Sh(e.radius, e.detail) } } const Ep = new D, bp = new D, cy = new D, Tp = new fr; class lT extends ut { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const r = Math.pow(10, 4), s = Math.cos(Qa * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, u = [0, 0, 0], h = ["a", "b", "c"], d = new Array(3), p = {}, m = []; for (let v = 0; v < l; v += 3) { o ? (u[0] = o.getX(v), u[1] = o.getX(v + 1), u[2] = o.getX(v + 2)) : (u[0] = v, u[1] = v + 1, u[2] = v + 2); const { a: y, b: x, c: A } = Tp; if (y.fromBufferAttribute(a, u[0]), x.fromBufferAttribute(a, u[1]), A.fromBufferAttribute(a, u[2]), Tp.getNormal(cy), d[0] = `${Math.round(y.x * r)},${Math.round(y.y * r)},${Math.round(y.z * r)}`, d[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`, d[2] = `${Math.round(A.x * r)},${Math.round(A.y * r)},${Math.round(A.z * r)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let _ = 0; _ < 3; _++) { const M = (_ + 1) % 3, S = d[_], b = d[M], B = Tp[h[_]], R = Tp[h[M]], E = `${S}_${b}`, P = `${b}_${S}`; P in p && p[P] ? (cy.dot(p[P].normal) <= s && (m.push(B.x, B.y, B.z), m.push(R.x, R.y, R.z)), p[P] = null) : E in p || (p[E] = { index0: u[_], index1: u[M], normal: cy.clone() }) } } for (const v in p) if (p[v]) { const { index0: y, index1: x } = p[v]; Ep.fromBufferAttribute(a, y), bp.fromBufferAttribute(a, x), m.push(Ep.x, Ep.y, Ep.z), m.push(bp.x, bp.y, bp.z) } this.setAttribute("position", new je(m, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class Ya extends Kf { constructor(e) { super(e), this.uuid = Vi(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let i = 0, r = this.holes.length; i < r; i++)t[i] = this.holes[i].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const r = e.holes[t]; this.holes.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, i = this.holes.length; t < i; t++) { const r = this.holes[t]; e.holes.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const r = e.holes[t]; this.holes.push(new Kf().fromJSON(r)) } return this } } const Vk = { triangulate: function (n, e, t = 2) { const i = e && e.length, r = i ? e[0] * t : n.length; let s = cT(n, 0, r, t, !0); const o = []; if (!s || s.next === s.prev) return o; let a, l, u, h, d, p, m; if (i && (s = Qk(n, e, s, t)), n.length > 80 * t) { a = u = n[0], l = h = n[1]; for (let v = t; v < r; v += t)d = n[v], p = n[v + 1], d < a && (a = d), p < l && (l = p), d > u && (u = d), p > h && (h = p); m = Math.max(u - a, h - l), m = m !== 0 ? 32767 / m : 0 } return Yf(s, o, t, a, l, m, 0), o } }; function cT(n, e, t, i, r) { let s, o; if (r === sN(n, e, t, i) > 0) for (s = e; s < t; s += i)o = dS(s, n[s], n[s + 1], o); else for (s = t - i; s >= e; s -= i)o = dS(s, n[s], n[s + 1], o); return o && O0(o, o.next) && (Zf(o), o = o.next), o } function rl(n, e) { if (!n) return n; e || (e = n); let t = n, i; do if (i = !1, !t.steiner && (O0(t, t.next) || nn(t.prev, t, t.next) === 0)) { if (Zf(t), t = e = t.prev, t === t.next) break; i = !0 } else t = t.next; while (i || t !== e); return e } function Yf(n, e, t, i, r, s, o) { if (!n) return; !o && s && $k(n, i, r, s); let a = n, l, u; for (; n.prev !== n.next;) { if (l = n.prev, u = n.next, s ? jk(n, i, r, s) : Wk(n)) { e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(u.i / t | 0), Zf(n), n = u.next, a = u.next; continue } if (n = u, n === a) { o ? o === 1 ? (n = Jk(rl(n), e, t), Yf(n, e, t, i, r, s, 2)) : o === 2 && Xk(n, e, t, i, r, s) : Yf(rl(n), e, t, i, r, s, 1); break } } } function Wk(n) { const e = n.prev, t = n, i = n.next; if (nn(e, t, i) >= 0) return !1; const r = e.x, s = t.x, o = i.x, a = e.y, l = t.y, u = i.y, h = r < s ? r < o ? r : o : s < o ? s : o, d = a < l ? a < u ? a : u : l < u ? l : u, p = r > s ? r > o ? r : o : s > o ? s : o, m = a > l ? a > u ? a : u : l > u ? l : u; let v = i.next; for (; v !== e;) { if (v.x >= h && v.x <= p && v.y >= d && v.y <= m && uc(r, a, s, l, o, u, v.x, v.y) && nn(v.prev, v, v.next) >= 0) return !1; v = v.next } return !0 } function jk(n, e, t, i) { const r = n.prev, s = n, o = n.next; if (nn(r, s, o) >= 0) return !1; const a = r.x, l = s.x, u = o.x, h = r.y, d = s.y, p = o.y, m = a < l ? a < u ? a : u : l < u ? l : u, v = h < d ? h < p ? h : p : d < p ? d : p, y = a > l ? a > u ? a : u : l > u ? l : u, x = h > d ? h > p ? h : p : d > p ? d : p, A = y2(m, v, e, t, i), _ = y2(y, x, e, t, i); let M = n.prevZ, S = n.nextZ; for (; M && M.z >= A && S && S.z <= _;) { if (M.x >= m && M.x <= y && M.y >= v && M.y <= x && M !== r && M !== o && uc(a, h, l, d, u, p, M.x, M.y) && nn(M.prev, M, M.next) >= 0 || (M = M.prevZ, S.x >= m && S.x <= y && S.y >= v && S.y <= x && S !== r && S !== o && uc(a, h, l, d, u, p, S.x, S.y) && nn(S.prev, S, S.next) >= 0)) return !1; S = S.nextZ } for (; M && M.z >= A;) { if (M.x >= m && M.x <= y && M.y >= v && M.y <= x && M !== r && M !== o && uc(a, h, l, d, u, p, M.x, M.y) && nn(M.prev, M, M.next) >= 0) return !1; M = M.prevZ } for (; S && S.z <= _;) { if (S.x >= m && S.x <= y && S.y >= v && S.y <= x && S !== r && S !== o && uc(a, h, l, d, u, p, S.x, S.y) && nn(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } return !0 } function Jk(n, e, t) { let i = n; do { const r = i.prev, s = i.next.next; !O0(r, s) && uT(r, i, i.next, s) && qf(r, s) && qf(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Zf(i), Zf(i.next), i = n = s), i = i.next } while (i !== n); return rl(i) } function Xk(n, e, t, i, r, s) { let o = n; do { let a = o.next.next; for (; a !== o.prev;) { if (o.i !== a.i && nN(o, a)) { let l = fT(o, a); o = rl(o, o.next), l = rl(l, l.next), Yf(o, e, t, i, r, s, 0), Yf(l, e, t, i, r, s, 0); return } a = a.next } o = o.next } while (o !== n) } function Qk(n, e, t, i) { const r = []; let s, o, a, l, u; for (s = 0, o = e.length; s < o; s++)a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n.length, u = cT(n, a, l, i, !1), u === u.next && (u.steiner = !0), r.push(tN(u)); for (r.sort(Kk), s = 0; s < r.length; s++)t = Yk(r[s], t); return t } function Kk(n, e) { return n.x - e.x } function Yk(n, e) { const t = qk(n, e); if (!t) return e; const i = fT(t, n); return rl(i, i.next), rl(t, t.next) } function qk(n, e) { let t = e, i = -1 / 0, r; const s = n.x, o = n.y; do { if (o <= t.y && o >= t.next.y && t.next.y !== t.y) { const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (p <= s && p > i && (i = p, r = t.x < t.next.x ? t : t.next, p === s)) return r } t = t.next } while (t !== e); if (!r) return null; const a = r, l = r.x, u = r.y; let h = 1 / 0, d; t = r; do s >= t.x && t.x >= l && s !== t.x && uc(o < u ? s : i, o, l, u, o < u ? i : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x), qf(t, n) && (d < h || d === h && (t.x > r.x || t.x === r.x && Zk(r, t))) && (r = t, h = d)), t = t.next; while (t !== a); return r } function Zk(n, e) { return nn(n.prev, n, e.prev) < 0 && nn(e.next, n, n.next) < 0 } function $k(n, e, t, i) { let r = n; do r.z === 0 && (r.z = y2(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== n); r.prevZ.nextZ = null, r.prevZ = null, eN(r) } function eN(n) { let e, t, i, r, s, o, a, l, u = 1; do { for (t = n, n = null, s = null, o = 0; t;) { for (o++, i = t, a = 0, e = 0; e < u && (a++, i = i.nextZ, !!i); e++); for (l = u; a > 0 || l > 0 && i;)a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r; t = i } s.nextZ = null, u *= 2 } while (o > 1); return n } function y2(n, e, t, i, r) { return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1 } function tN(n) { let e = n, t = n; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n); return t } function uc(n, e, t, i, r, s, o, a) { return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a) } function nN(n, e) { return n.next.i !== e.i && n.prev.i !== e.i && !iN(n, e) && (qf(n, e) && qf(e, n) && rN(n, e) && (nn(n.prev, n, e.prev) || nn(n, e.prev, e)) || O0(n, e) && nn(n.prev, n, n.next) > 0 && nn(e.prev, e, e.next) > 0) } function nn(n, e, t) { return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y) } function O0(n, e) { return n.x === e.x && n.y === e.y } function uT(n, e, t, i) { const r = Pp(nn(n, e, t)), s = Pp(nn(n, e, i)), o = Pp(nn(t, i, n)), a = Pp(nn(t, i, e)); return !!(r !== s && o !== a || r === 0 && Bp(n, t, e) || s === 0 && Bp(n, i, e) || o === 0 && Bp(t, n, i) || a === 0 && Bp(t, e, i)) } function Bp(n, e, t) { return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y) } function Pp(n) { return n > 0 ? 1 : n < 0 ? -1 : 0 } function iN(n, e) { let t = n; do { if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && uT(t, t.next, n, e)) return !0; t = t.next } while (t !== n); return !1 } function qf(n, e) { return nn(n.prev, n, n.next) < 0 ? nn(n, e, n.next) >= 0 && nn(n, n.prev, e) >= 0 : nn(n, e, n.prev) < 0 || nn(n, n.next, e) < 0 } function rN(n, e) { let t = n, i = !1; const r = (n.x + e.x) / 2, s = (n.y + e.y) / 2; do t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n); return i } function fT(n, e) { const t = new v2(n.i, n.x, n.y), i = new v2(e.i, e.x, e.y), r = n.next, s = e.prev; return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i } function dS(n, e, t, i) { const r = new v2(n, e, t); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function Zf(n) { n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ) } function v2(n, e, t) { this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function sN(n, e, t, i) { let r = 0; for (let s = e, o = t - i; s < t; s += i)r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s; return r } class rs { static area(e) { const t = e.length; let i = 0; for (let r = t - 1, s = 0; s < t; r = s++)i += e[r].x * e[s].y - e[s].x * e[r].y; return i * .5 } static isClockWise(e) { return rs.area(e) < 0 } static triangulateShape(e, t) { const i = [], r = [], s = []; pS(e), mS(i, e); let o = e.length; t.forEach(pS); for (let l = 0; l < t.length; l++)r.push(o), o += t[l].length, mS(i, t[l]); const a = Vk.triangulate(i, r); for (let l = 0; l < a.length; l += 3)s.push(a.slice(l, l + 3)); return s } } function pS(n) { const e = n.length; e > 2 && n[e - 1].equals(n[0]) && n.pop() } function mS(n, e) { for (let t = 0; t < e.length; t++)n.push(e[t].x), n.push(e[t].y) } class Ch extends ut { constructor(e = new Ya([new me(.5, .5), new me(-.5, .5), new me(-.5, -.5), new me(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const i = this, r = [], s = []; for (let a = 0, l = e.length; a < l; a++) { const u = e[a]; o(u) } this.setAttribute("position", new je(r, 3)), this.setAttribute("uv", new je(s, 2)), this.computeVertexNormals(); function o(a) { const l = [], u = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1; let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, v = t.bevelSize !== void 0 ? t.bevelSize : m - .1, y = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const A = t.extrudePath, _ = t.UVGenerator !== void 0 ? t.UVGenerator : oN; let M, S = !1, b, B, R, E; A && (M = A.getSpacedPoints(h), S = !0, p = !1, b = A.computeFrenetFrames(h, !1), B = new D, R = new D, E = new D), p || (x = 0, m = 0, v = 0, y = 0); const P = a.extractPoints(u); let L = P.shape; const z = P.holes; if (!rs.isClockWise(L)) { L = L.reverse(); for (let de = 0, pe = z.length; de < pe; de++) { const _e = z[de]; rs.isClockWise(_e) && (z[de] = _e.reverse()) } } const J = rs.triangulateShape(L, z), V = L; for (let de = 0, pe = z.length; de < pe; de++) { const _e = z[de]; L = L.concat(_e) } function K(de, pe, _e) { return pe || console.error("THREE.ExtrudeGeometry: vec does not exist"), de.clone().addScaledVector(pe, _e) } const ee = L.length, le = J.length; function N(de, pe, _e) { let Ve, Ie, Qe; const Xe = de.x - pe.x, Ze = de.y - pe.y, gt = _e.x - de.x, wt = _e.y - de.y, O = Xe * Xe + Ze * Ze, I = Xe * wt - Ze * gt; if (Math.abs(I) > Number.EPSILON) { const ie = Math.sqrt(O), we = Math.sqrt(gt * gt + wt * wt), Ce = pe.x - Ze / ie, Pe = pe.y + Xe / ie, Ye = _e.x - wt / we, Oe = _e.y + gt / we, ye = ((Ye - Ce) * wt - (Oe - Pe) * gt) / (Xe * wt - Ze * gt); Ve = Ce + Xe * ye - de.x, Ie = Pe + Ze * ye - de.y; const $e = Ve * Ve + Ie * Ie; if ($e <= 2) return new me(Ve, Ie); Qe = Math.sqrt($e / 2) } else { let ie = !1; Xe > Number.EPSILON ? gt > Number.EPSILON && (ie = !0) : Xe < -Number.EPSILON ? gt < -Number.EPSILON && (ie = !0) : Math.sign(Ze) === Math.sign(wt) && (ie = !0), ie ? (Ve = -Ze, Ie = Xe, Qe = Math.sqrt(O)) : (Ve = Xe, Ie = Ze, Qe = Math.sqrt(O / 2)) } return new me(Ve / Qe, Ie / Qe) } const H = []; for (let de = 0, pe = V.length, _e = pe - 1, Ve = de + 1; de < pe; de++, _e++, Ve++)_e === pe && (_e = 0), Ve === pe && (Ve = 0), H[de] = N(V[de], V[_e], V[Ve]); const W = []; let se, j = H.concat(); for (let de = 0, pe = z.length; de < pe; de++) { const _e = z[de]; se = []; for (let Ve = 0, Ie = _e.length, Qe = Ie - 1, Xe = Ve + 1; Ve < Ie; Ve++, Qe++, Xe++)Qe === Ie && (Qe = 0), Xe === Ie && (Xe = 0), se[Ve] = N(_e[Ve], _e[Qe], _e[Xe]); W.push(se), j = j.concat(se) } for (let de = 0; de < x; de++) { const pe = de / x, _e = m * Math.cos(pe * Math.PI / 2), Ve = v * Math.sin(pe * Math.PI / 2) + y; for (let Ie = 0, Qe = V.length; Ie < Qe; Ie++) { const Xe = K(V[Ie], H[Ie], Ve); Se(Xe.x, Xe.y, -_e) } for (let Ie = 0, Qe = z.length; Ie < Qe; Ie++) { const Xe = z[Ie]; se = W[Ie]; for (let Ze = 0, gt = Xe.length; Ze < gt; Ze++) { const wt = K(Xe[Ze], se[Ze], Ve); Se(wt.x, wt.y, -_e) } } } const oe = v + y; for (let de = 0; de < ee; de++) { const pe = p ? K(L[de], j[de], oe) : L[de]; S ? (R.copy(b.normals[0]).multiplyScalar(pe.x), B.copy(b.binormals[0]).multiplyScalar(pe.y), E.copy(M[0]).add(R).add(B), Se(E.x, E.y, E.z)) : Se(pe.x, pe.y, 0) } for (let de = 1; de <= h; de++)for (let pe = 0; pe < ee; pe++) { const _e = p ? K(L[pe], j[pe], oe) : L[pe]; S ? (R.copy(b.normals[de]).multiplyScalar(_e.x), B.copy(b.binormals[de]).multiplyScalar(_e.y), E.copy(M[de]).add(R).add(B), Se(E.x, E.y, E.z)) : Se(_e.x, _e.y, d / h * de) } for (let de = x - 1; de >= 0; de--) { const pe = de / x, _e = m * Math.cos(pe * Math.PI / 2), Ve = v * Math.sin(pe * Math.PI / 2) + y; for (let Ie = 0, Qe = V.length; Ie < Qe; Ie++) { const Xe = K(V[Ie], H[Ie], Ve); Se(Xe.x, Xe.y, d + _e) } for (let Ie = 0, Qe = z.length; Ie < Qe; Ie++) { const Xe = z[Ie]; se = W[Ie]; for (let Ze = 0, gt = Xe.length; Ze < gt; Ze++) { const wt = K(Xe[Ze], se[Ze], Ve); S ? Se(wt.x, wt.y + M[h - 1].y, M[h - 1].x + _e) : Se(wt.x, wt.y, d + _e) } } } ve(), q(); function ve() { const de = r.length / 3; if (p) { let pe = 0, _e = ee * pe; for (let Ve = 0; Ve < le; Ve++) { const Ie = J[Ve]; Fe(Ie[2] + _e, Ie[1] + _e, Ie[0] + _e) } pe = h + x * 2, _e = ee * pe; for (let Ve = 0; Ve < le; Ve++) { const Ie = J[Ve]; Fe(Ie[0] + _e, Ie[1] + _e, Ie[2] + _e) } } else { for (let pe = 0; pe < le; pe++) { const _e = J[pe]; Fe(_e[2], _e[1], _e[0]) } for (let pe = 0; pe < le; pe++) { const _e = J[pe]; Fe(_e[0] + ee * h, _e[1] + ee * h, _e[2] + ee * h) } } i.addGroup(de, r.length / 3 - de, 0) } function q() { const de = r.length / 3; let pe = 0; Te(V, pe), pe += V.length; for (let _e = 0, Ve = z.length; _e < Ve; _e++) { const Ie = z[_e]; Te(Ie, pe), pe += Ie.length } i.addGroup(de, r.length / 3 - de, 1) } function Te(de, pe) { let _e = de.length; for (; --_e >= 0;) { const Ve = _e; let Ie = _e - 1; Ie < 0 && (Ie = de.length - 1); for (let Qe = 0, Xe = h + x * 2; Qe < Xe; Qe++) { const Ze = ee * Qe, gt = ee * (Qe + 1), wt = pe + Ve + Ze, O = pe + Ie + Ze, I = pe + Ie + gt, ie = pe + Ve + gt; ze(wt, O, I, ie) } } } function Se(de, pe, _e) { l.push(de), l.push(pe), l.push(_e) } function Fe(de, pe, _e) { Le(de), Le(pe), Le(_e); const Ve = r.length / 3, Ie = _.generateTopUV(i, r, Ve - 3, Ve - 2, Ve - 1); be(Ie[0]), be(Ie[1]), be(Ie[2]) } function ze(de, pe, _e, Ve) { Le(de), Le(pe), Le(Ve), Le(pe), Le(_e), Le(Ve); const Ie = r.length / 3, Qe = _.generateSideWallUV(i, r, Ie - 6, Ie - 3, Ie - 2, Ie - 1); be(Qe[0]), be(Qe[1]), be(Qe[3]), be(Qe[1]), be(Qe[2]), be(Qe[3]) } function Le(de) { r.push(l[de * 3 + 0]), r.push(l[de * 3 + 1]), r.push(l[de * 3 + 2]) } function be(de) { s.push(de.x), s.push(de.y) } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options; return aN(t, i, e) } static fromJSON(e, t) { const i = []; for (let s = 0, o = e.shapes.length; s < o; s++) { const a = t[e.shapes[s]]; i.push(a) } const r = e.options.extrudePath; return r !== void 0 && (e.options.extrudePath = new _A[r.type]().fromJSON(r)), new Ch(i, e.options) } } const oN = { generateTopUV: function (n, e, t, i, r) { const s = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], u = e[r * 3], h = e[r * 3 + 1]; return [new me(s, o), new me(a, l), new me(u, h)] }, generateSideWallUV: function (n, e, t, i, r, s) { const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], u = e[i * 3], h = e[i * 3 + 1], d = e[i * 3 + 2], p = e[r * 3], m = e[r * 3 + 1], v = e[r * 3 + 2], y = e[s * 3], x = e[s * 3 + 1], A = e[s * 3 + 2]; return Math.abs(a - h) < Math.abs(o - u) ? [new me(o, 1 - l), new me(u, 1 - d), new me(p, 1 - v), new me(y, 1 - A)] : [new me(a, 1 - l), new me(h, 1 - d), new me(m, 1 - v), new me(x, 1 - A)] } }; function aN(n, e, t) { if (t.shapes = [], Array.isArray(n)) for (let i = 0, r = n.length; i < r; i++) { const s = n[i]; t.shapes.push(s.uuid) } else t.shapes.push(n.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class Eh extends Ys { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2, r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Eh(e.radius, e.detail) } } class qc extends Ys { constructor(e = 1, t = 0) { const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new qc(e.radius, e.detail) } } class bh extends ut { constructor(e = .5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: s, thetaLength: o }, i = Math.max(3, i), r = Math.max(1, r); const a = [], l = [], u = [], h = []; let d = e; const p = (t - e) / r, m = new D, v = new me; for (let y = 0; y <= r; y++) { for (let x = 0; x <= i; x++) { const A = s + x / i * o; m.x = d * Math.cos(A), m.y = d * Math.sin(A), l.push(m.x, m.y, m.z), u.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, h.push(v.x, v.y) } d += p } for (let y = 0; y < r; y++) { const x = y * (i + 1); for (let A = 0; A < i; A++) { const _ = A + x, M = _, S = _ + i + 1, b = _ + i + 2, B = _ + 1; a.push(M, S, B), a.push(S, b, B) } } this.setIndex(a), this.setAttribute("position", new je(l, 3)), this.setAttribute("normal", new je(u, 3)), this.setAttribute("uv", new je(h, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new bh(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class Th extends ut { constructor(e = new Ya([new me(0, .5), new me(-.5, -.5), new me(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const i = [], r = [], s = [], o = []; let a = 0, l = 0; if (Array.isArray(e) === !1) u(e); else for (let h = 0; h < e.length; h++)u(e[h]), this.addGroup(a, l, h), a += l, l = 0; this.setIndex(i), this.setAttribute("position", new je(r, 3)), this.setAttribute("normal", new je(s, 3)), this.setAttribute("uv", new je(o, 2)); function u(h) { const d = r.length / 3, p = h.extractPoints(t); let m = p.shape; const v = p.holes; rs.isClockWise(m) === !1 && (m = m.reverse()); for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; rs.isClockWise(_) === !0 && (v[x] = _.reverse()) } const y = rs.triangulateShape(m, v); for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; m = m.concat(_) } for (let x = 0, A = m.length; x < A; x++) { const _ = m[x]; r.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y) } for (let x = 0, A = y.length; x < A; x++) { const _ = y[x], M = _[0] + d, S = _[1] + d, b = _[2] + d; i.push(M, S, b), l += 3 } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return lN(t, e) } static fromJSON(e, t) { const i = []; for (let r = 0, s = e.shapes.length; r < s; r++) { const o = t[e.shapes[r]]; i.push(o) } return new Th(i, e.curveSegments) } } function lN(n, e) { if (e.shapes = [], Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) { const r = n[t]; e.shapes.push(r.uuid) } else e.shapes.push(n.uuid); return e } class Zc extends ut { constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i)); const l = Math.min(o + a, Math.PI); let u = 0; const h = [], d = new D, p = new D, m = [], v = [], y = [], x = []; for (let A = 0; A <= i; A++) { const _ = [], M = A / i; let S = 0; A == 0 && o == 0 ? S = .5 / t : A == i && l == Math.PI && (S = -.5 / t); for (let b = 0; b <= t; b++) { const B = b / t; d.x = -e * Math.cos(r + B * s) * Math.sin(o + M * a), d.y = e * Math.cos(o + M * a), d.z = e * Math.sin(r + B * s) * Math.sin(o + M * a), v.push(d.x, d.y, d.z), p.copy(d).normalize(), y.push(p.x, p.y, p.z), x.push(B + S, 1 - M), _.push(u++) } h.push(_) } for (let A = 0; A < i; A++)for (let _ = 0; _ < t; _++) { const M = h[A][_ + 1], S = h[A][_], b = h[A + 1][_], B = h[A + 1][_ + 1]; (A !== 0 || o > 0) && m.push(M, S, B), (A !== i - 1 || l < Math.PI) && m.push(S, b, B) } this.setIndex(m), this.setAttribute("position", new je(v, 3)), this.setAttribute("normal", new je(y, 3)), this.setAttribute("uv", new je(x, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Zc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class Bh extends Ys { constructor(e = 1, t = 0) { const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Bh(e.radius, e.detail) } } class Ph extends ut { constructor(e = 1, t = .4, i = 12, r = 48, s = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }, i = Math.floor(i), r = Math.floor(r); const o = [], a = [], l = [], u = [], h = new D, d = new D, p = new D; for (let m = 0; m <= i; m++)for (let v = 0; v <= r; v++) { const y = v / r * s, x = m / i * Math.PI * 2; d.x = (e + t * Math.cos(x)) * Math.cos(y), d.y = (e + t * Math.cos(x)) * Math.sin(y), d.z = t * Math.sin(x), a.push(d.x, d.y, d.z), h.x = e * Math.cos(y), h.y = e * Math.sin(y), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), u.push(v / r), u.push(m / i) } for (let m = 1; m <= i; m++)for (let v = 1; v <= r; v++) { const y = (r + 1) * m + v - 1, x = (r + 1) * (m - 1) + v - 1, A = (r + 1) * (m - 1) + v, _ = (r + 1) * m + v; o.push(y, x, _), o.push(x, A, _) } this.setIndex(o), this.setAttribute("position", new je(a, 3)), this.setAttribute("normal", new je(l, 3)), this.setAttribute("uv", new je(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Ph(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class Rh extends ut { constructor(e = 1, t = .4, i = 64, r = 8, s = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: s, q: o }, i = Math.floor(i), r = Math.floor(r); const a = [], l = [], u = [], h = [], d = new D, p = new D, m = new D, v = new D, y = new D, x = new D, A = new D; for (let M = 0; M <= i; ++M) { const S = M / i * s * Math.PI * 2; _(S, s, o, e, m), _(S + .01, s, o, e, v), x.subVectors(v, m), A.addVectors(v, m), y.crossVectors(x, A), A.crossVectors(y, x), y.normalize(), A.normalize(); for (let b = 0; b <= r; ++b) { const B = b / r * Math.PI * 2, R = -t * Math.cos(B), E = t * Math.sin(B); d.x = m.x + (R * A.x + E * y.x), d.y = m.y + (R * A.y + E * y.y), d.z = m.z + (R * A.z + E * y.z), l.push(d.x, d.y, d.z), p.subVectors(d, m).normalize(), u.push(p.x, p.y, p.z), h.push(M / i), h.push(b / r) } } for (let M = 1; M <= i; M++)for (let S = 1; S <= r; S++) { const b = (r + 1) * (M - 1) + (S - 1), B = (r + 1) * M + (S - 1), R = (r + 1) * M + S, E = (r + 1) * (M - 1) + S; a.push(b, B, E), a.push(B, R, E) } this.setIndex(a), this.setAttribute("position", new je(l, 3)), this.setAttribute("normal", new je(u, 3)), this.setAttribute("uv", new je(h, 2)); function _(M, S, b, B, R) { const E = Math.cos(M), P = Math.sin(M), L = b / S * M, z = Math.cos(L); R.x = B * (2 + z) * .5 * E, R.y = B * (2 + z) * P * .5, R.z = B * Math.sin(L) * .5 } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Rh(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Lh extends ut { constructor(e = new AA(new D(-1, -1, 0), new D(-1, 1, 0), new D(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: s }; const o = e.computeFrenetFrames(t, s); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const a = new D, l = new D, u = new me; let h = new D; const d = [], p = [], m = [], v = []; y(), this.setIndex(v), this.setAttribute("position", new je(d, 3)), this.setAttribute("normal", new je(p, 3)), this.setAttribute("uv", new je(m, 2)); function y() { for (let M = 0; M < t; M++)x(M); x(s === !1 ? t : 0), _(), A() } function x(M) { h = e.getPointAt(M / t, h); const S = o.normals[M], b = o.binormals[M]; for (let B = 0; B <= r; B++) { const R = B / r * Math.PI * 2, E = Math.sin(R), P = -Math.cos(R); l.x = P * S.x + E * b.x, l.y = P * S.y + E * b.y, l.z = P * S.z + E * b.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = h.x + i * l.x, a.y = h.y + i * l.y, a.z = h.z + i * l.z, d.push(a.x, a.y, a.z) } } function A() { for (let M = 1; M <= t; M++)for (let S = 1; S <= r; S++) { const b = (r + 1) * (M - 1) + (S - 1), B = (r + 1) * M + (S - 1), R = (r + 1) * M + S, E = (r + 1) * (M - 1) + S; v.push(b, B, E), v.push(B, R, E) } } function _() { for (let M = 0; M <= t; M++)for (let S = 0; S <= r; S++)u.x = M / t, u.y = S / r, m.push(u.x, u.y) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Lh(new _A[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class hT extends ut { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], i = new Set, r = new D, s = new D; if (e.index !== null) { const o = e.attributes.position, a = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let u = 0, h = l.length; u < h; ++u) { const d = l[u], p = d.start, m = d.count; for (let v = p, y = p + m; v < y; v += 3)for (let x = 0; x < 3; x++) { const A = a.getX(v + x), _ = a.getX(v + (x + 1) % 3); r.fromBufferAttribute(o, A), s.fromBufferAttribute(o, _), gS(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } } else { const o = e.attributes.position; for (let a = 0, l = o.count / 3; a < l; a++)for (let u = 0; u < 3; u++) { const h = 3 * a + u, d = 3 * a + (u + 1) % 3; r.fromBufferAttribute(o, h), s.fromBufferAttribute(o, d), gS(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } this.setAttribute("position", new je(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function gS(n, e, t) { const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`; return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0) } var yS = Object.freeze({ __proto__: null, BoxGeometry: ea, CapsuleGeometry: Mh, CircleGeometry: _h, ConeGeometry: wh, CylinderGeometry: cl, DodecahedronGeometry: Sh, EdgesGeometry: lT, ExtrudeGeometry: Ch, IcosahedronGeometry: Eh, LatheGeometry: Yc, OctahedronGeometry: qc, PlaneGeometry: Qc, PolyhedronGeometry: Ys, RingGeometry: bh, ShapeGeometry: Th, SphereGeometry: Zc, TetrahedronGeometry: Bh, TorusGeometry: Ph, TorusKnotGeometry: Rh, TubeGeometry: Lh, WireframeGeometry: hT }); class dT extends En { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Re(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class pT extends cs { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class $c extends En { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Re(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Re(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class qs extends $c { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new me(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return xn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Re(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Re(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Re(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e) } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class mT extends En { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Re(16777215), this.specular = new Re(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Re(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ph, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class gT extends En { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Re(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Re(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class yT extends En { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class vT extends En { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Re(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Re(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ph, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class xT extends En { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Re(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ks, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class AT extends oi { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function lr(n, e, t) { return wA(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t) } function Ga(n, e, t) { return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n) } function wA(n) { return ArrayBuffer.isView(n) && !(n instanceof DataView) } function MT(n) { function e(r, s) { return n[r] - n[s] } const t = n.length, i = new Array(t); for (let r = 0; r !== t; ++r)i[r] = r; return i.sort(e), i } function x2(n, e, t) { const i = n.length, r = new n.constructor(i); for (let s = 0, o = 0; o !== i; ++s) { const a = t[s] * e; for (let l = 0; l !== e; ++l)r[o++] = n[a + l] } return r } function SA(n, e, t, i) { let r = 1, s = n[0]; for (; s !== void 0 && s[i] === void 0;)s = n[r++]; if (s === void 0) return; let o = s[i]; if (o !== void 0) if (Array.isArray(o)) do o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++]; while (s !== void 0); else if (o.toArray !== void 0) do o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++]; while (s !== void 0); else do o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++]; while (s !== void 0) } function cN(n, e, t, i, r = 30) { const s = n.clone(); s.name = e; const o = []; for (let l = 0; l < s.tracks.length; ++l) { const u = s.tracks[l], h = u.getValueSize(), d = [], p = []; for (let m = 0; m < u.times.length; ++m) { const v = u.times[m] * r; if (!(v < t || v >= i)) { d.push(u.times[m]); for (let y = 0; y < h; ++y)p.push(u.values[m * h + y]) } } d.length !== 0 && (u.times = Ga(d, u.times.constructor), u.values = Ga(p, u.values.constructor), o.push(u)) } s.tracks = o; let a = 1 / 0; for (let l = 0; l < s.tracks.length; ++l)a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]); for (let l = 0; l < s.tracks.length; ++l)s.tracks[l].shift(-1 * a); return s.resetDuration(), s } function uN(n, e = 0, t = n, i = 30) { i <= 0 && (i = 30); const r = t.tracks.length, s = e / i; for (let o = 0; o < r; ++o) { const a = t.tracks[o], l = a.ValueTypeName; if (l === "bool" || l === "string") continue; const u = n.tracks.find(function (A) { return A.name === a.name && A.ValueTypeName === l }); if (u === void 0) continue; let h = 0; const d = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3); let p = 0; const m = u.getValueSize(); u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3); const v = a.times.length - 1; let y; if (s <= a.times[0]) { const A = h, _ = d - h; y = lr(a.values, A, _) } else if (s >= a.times[v]) { const A = v * d + h, _ = A + d - h; y = lr(a.values, A, _) } else { const A = a.createInterpolant(), _ = h, M = d - h; A.evaluate(s), y = lr(A.resultBuffer, _, M) } l === "quaternion" && new jn().fromArray(y).normalize().conjugate().toArray(y); const x = u.times.length; for (let A = 0; A < x; ++A) { const _ = A * m + p; if (l === "quaternion") jn.multiplyQuaternionsFlat(u.values, _, y, 0, u.values, _); else { const M = m - p * 2; for (let S = 0; S < M; ++S)u.values[_ + S] -= y[S] } } } return n.blendMode = qx, n } const fN = { arraySlice: lr, convertArray: Ga, isTypedArray: wA, getKeyframeOrder: MT, sortedArray: x2, flattenJSON: SA, subclip: cN, makeClipAdditive: uN }; class eu { constructor(e, t, i, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let i = this._cachedIndex, r = t[i], s = t[i - 1]; e: { t: { let o; n: { i: if (!(e < r)) { for (let a = i + 2; ;) { if (r === void 0) { if (e < s) break i; return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } if (i === a) break; if (s = r, r = t[++i], e < r) break t } o = t.length; break n } if (!(e >= s)) { const a = t[1]; e < a && (i = 2, s = a); for (let l = i - 2; ;) { if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === l) break; if (r = s, s = t[--i - 1], e >= s) break t } o = i, i = 0; break n } break e } for (; i < o;) { const a = i + o >>> 1; e < t[a] ? o = a : i = a + 1 } if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } this._cachedIndex = i, this.intervalChanged_(i, s, r) } return this.interpolate_(i, s, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r; for (let o = 0; o !== r; ++o)t[o] = i[s + o]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class _T extends eu { constructor(e, t, i, r) { super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Oa, endingEnd: Oa } } intervalChanged_(e, t, i) { const r = this.parameterPositions; let s = e - 2, o = e + 1, a = r[s], l = r[o]; if (a === void 0) switch (this.getSettings_().endingStart) { case za: s = e, a = 2 * t - i; break; case jf: s = r.length - 2, a = t + r[s] - r[s + 1]; break; default: s = e, a = i }if (l === void 0) switch (this.getSettings_().endingEnd) { case za: o = e, l = 2 * i - t; break; case jf: o = 1, l = i + r[1] - r[0]; break; default: o = e - 1, l = t }const u = (i - t) * .5, h = this.valueSize; this._weightPrev = u / (t - a), this._weightNext = u / (l - i), this._offsetPrev = s * h, this._offsetNext = o * h } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, u = l - a, h = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, m = this._weightNext, v = (i - t) / (r - t), y = v * v, x = y * v, A = -p * x + 2 * p * y - p * v, _ = (1 + p) * x + (-1.5 - 2 * p) * y + (-.5 + p) * v + 1, M = (-1 - m) * x + (1.5 + m) * y + .5 * v, S = m * x - m * y; for (let b = 0; b !== a; ++b)s[b] = A * o[h + b] + _ * o[u + b] + M * o[l + b] + S * o[d + b]; return s } } class CA extends eu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, u = l - a, h = (i - t) / (r - t), d = 1 - h; for (let p = 0; p !== a; ++p)s[p] = o[u + p] * d + o[l + p] * h; return s } } class wT extends eu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Gr { constructor(e, t, i, r) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Ga(t, this.TimeBufferType), this.values = Ga(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let i; if (t.toJSON !== this.toJSON) i = t.toJSON(e); else { i = { name: e.name, times: Ga(e.times, Array), values: Ga(e.values, Array) }; const r = e.getInterpolation(); r !== e.DefaultInterpolation && (i.interpolation = r) } return i.type = e.ValueTypeName, i } InterpolantFactoryMethodDiscrete(e) { return new wT(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new CA(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new _T(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case Dc: t = this.InterpolantFactoryMethodDiscrete; break; case il: t = this.InterpolantFactoryMethodLinear; break; case um: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(i); return console.warn("THREE.KeyframeTrack:", i), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Dc; case this.InterpolantFactoryMethodLinear: return il; case this.InterpolantFactoryMethodSmooth: return um } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] *= e } return this } trim(e, t) { const i = this.times, r = i.length; let s = 0, o = r - 1; for (; s !== r && i[s] < e;)++s; for (; o !== -1 && i[o] > t;)--o; if (++o, s !== 0 || o !== r) { s >= o && (o = Math.max(o, 1), s = o - 1); const a = this.getValueSize(); this.times = lr(i, s, o), this.values = lr(this.values, s * a, o * a) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const i = this.times, r = this.values, s = i.length; s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let o = null; for (let a = 0; a !== s; a++) { const l = i[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1; break } if (o !== null && o > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1; break } o = l } if (r !== void 0 && wA(r)) for (let a = 0, l = r.length; a !== l; ++a) { const u = r[a]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), e = !1; break } } return e } optimize() { const e = lr(this.times), t = lr(this.values), i = this.getValueSize(), r = this.getInterpolation() === um, s = e.length - 1; let o = 1; for (let a = 1; a < s; ++a) { let l = !1; const u = e[a], h = e[a + 1]; if (u !== h && (a !== 1 || u !== e[0])) if (r) l = !0; else { const d = a * i, p = d - i, m = d + i; for (let v = 0; v !== i; ++v) { const y = t[d + v]; if (y !== t[p + v] || y !== t[m + v]) { l = !0; break } } } if (l) { if (a !== o) { e[o] = e[a]; const d = a * i, p = o * i; for (let m = 0; m !== i; ++m)t[p + m] = t[d + m] } ++o } } if (s > 0) { e[o] = e[s]; for (let a = s * i, l = o * i, u = 0; u !== i; ++u)t[l + u] = t[a + u]; ++o } return o !== e.length ? (this.times = lr(e, 0, o), this.values = lr(t, 0, o * i)) : (this.times = e, this.values = t), this } clone() { const e = lr(this.times, 0), t = lr(this.values, 0), i = this.constructor, r = new i(this.name, e, t); return r.createInterpolant = this.createInterpolant, r } } Gr.prototype.TimeBufferType = Float32Array; Gr.prototype.ValueBufferType = Float32Array; Gr.prototype.DefaultInterpolation = il; class ul extends Gr { } ul.prototype.ValueTypeName = "bool"; ul.prototype.ValueBufferType = Array; ul.prototype.DefaultInterpolation = Dc; ul.prototype.InterpolantFactoryMethodLinear = void 0; ul.prototype.InterpolantFactoryMethodSmooth = void 0; class EA extends Gr { } EA.prototype.ValueTypeName = "color"; class Oc extends Gr { } Oc.prototype.ValueTypeName = "number"; class ST extends eu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (i - t) / (r - t); let u = e * a; for (let h = u + a; u !== h; u += 4)jn.slerpFlat(s, 0, o, u - a, o, u, l); return s } } class Jo extends Gr { InterpolantFactoryMethodLinear(e) { return new ST(this.times, this.values, this.getValueSize(), e) } } Jo.prototype.ValueTypeName = "quaternion"; Jo.prototype.DefaultInterpolation = il; Jo.prototype.InterpolantFactoryMethodSmooth = void 0; class fl extends Gr { } fl.prototype.ValueTypeName = "string"; fl.prototype.ValueBufferType = Array; fl.prototype.DefaultInterpolation = Dc; fl.prototype.InterpolantFactoryMethodLinear = void 0; fl.prototype.InterpolantFactoryMethodSmooth = void 0; class zc extends Gr { } zc.prototype.ValueTypeName = "vector"; class Uc { constructor(e, t = -1, i, r = T0) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Vi(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], i = e.tracks, r = 1 / (e.fps || 1); for (let o = 0, a = i.length; o !== a; ++o)t.push(dN(i[o]).scale(r)); const s = new this(e.name, e.duration, t, e.blendMode); return s.uuid = e.uuid, s } static toJSON(e) { const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let s = 0, o = i.length; s !== o; ++s)t.push(Gr.toJSON(i[s])); return r } static CreateFromMorphTargetSequence(e, t, i, r) { const s = t.length, o = []; for (let a = 0; a < s; a++) { let l = [], u = []; l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0); const h = MT(l); l = x2(l, 1, h), u = x2(u, 1, h), !r && l[0] === 0 && (l.push(s), u.push(u[0])), o.push(new Oc(".morphTargetInfluences[" + t[a].name + "]", l, u).scale(1 / i)) } return new this(e, -1, o) } static findByName(e, t) { let i = e; if (!Array.isArray(e)) { const r = e; i = r.geometry && r.geometry.animations || r.animations } for (let r = 0; r < i.length; r++)if (i[r].name === t) return i[r]; return null } static CreateClipsFromMorphTargetSequences(e, t, i) { const r = {}, s = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = e.length; a < l; a++) { const u = e[a], h = u.name.match(s); if (h && h.length > 1) { const d = h[1]; let p = r[d]; p || (r[d] = p = []), p.push(u) } } const o = []; for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i)); return o } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const i = function (d, p, m, v, y) { if (m.length !== 0) { const x = [], A = []; SA(m, x, A, v), x.length !== 0 && y.push(new d(p, x, A)) } }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode; let l = e.length || -1; const u = e.hierarchy || []; for (let d = 0; d < u.length; d++) { const p = u[d].keys; if (!(!p || p.length === 0)) if (p[0].morphTargets) { const m = {}; let v; for (v = 0; v < p.length; v++)if (p[v].morphTargets) for (let y = 0; y < p[v].morphTargets.length; y++)m[p[v].morphTargets[y]] = -1; for (const y in m) { const x = [], A = []; for (let _ = 0; _ !== p[v].morphTargets.length; ++_) { const M = p[v]; x.push(M.time), A.push(M.morphTarget === y ? 1 : 0) } r.push(new Oc(".morphTargetInfluence[" + y + "]", x, A)) } l = m.length * o } else { const m = ".bones[" + t[d].name + "]"; i(zc, m + ".position", p, "pos", r), i(Jo, m + ".quaternion", p, "rot", r), i(zc, m + ".scale", p, "scl", r) } } return r.length === 0 ? null : new this(s, l, r, a) } resetDuration() { const e = this.tracks; let t = 0; for (let i = 0, r = e.length; i !== r; ++i) { const s = this.tracks[i]; t = Math.max(t, s.times[s.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function hN(n) { switch (n.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Oc; case "vector": case "vector2": case "vector3": case "vector4": return zc; case "color": return EA; case "quaternion": return Jo; case "bool": case "boolean": return ul; case "string": return fl }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n) } function dN(n) { if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = hN(n.type); if (n.times === void 0) { const t = [], i = []; SA(n.keys, t, i, "value"), n.times = t, n.values = i } return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation) } const sl = { enabled: !1, files: {}, add: function (n, e) { this.enabled !== !1 && (this.files[n] = e) }, get: function (n) { if (this.enabled !== !1) return this.files[n] }, remove: function (n) { delete this.files[n] }, clear: function () { this.files = {} } }; class bA { constructor(e, t, i) { const r = this; let s = !1, o = 0, a = 0, l; const u = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (h) { a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), s = !0 }, this.itemEnd = function (h) { o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad()) }, this.itemError = function (h) { r.onError !== void 0 && r.onError(h) }, this.resolveURL = function (h) { return l ? l(h) : h }, this.setURLModifier = function (h) { return l = h, this }, this.addHandler = function (h, d) { return u.push(h, d), this }, this.removeHandler = function (h) { const d = u.indexOf(h); return d !== -1 && u.splice(d, 2), this }, this.getHandler = function (h) { for (let d = 0, p = u.length; d < p; d += 2) { const m = u[d], v = u[d + 1]; if (m.global && (m.lastIndex = 0), m.test(h)) return v } return null } } } const fc = new bA; class vi { constructor(e) { this.manager = e !== void 0 ? e : fc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const i = this; return new Promise(function (r, s) { i.load(e, r, t, s) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const Cs = {}; class pN extends Error { constructor(e, t) { super(e), this.response = t } } class ji extends vi { constructor(e) { super(e) } load(e, t, i, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = sl.get(e); if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(s), this.manager.itemEnd(e) }, 0), s; if (Cs[e] !== void 0) { Cs[e].push({ onLoad: t, onProgress: i, onError: r }); return } Cs[e] = [], Cs[e].push({ onLoad: t, onProgress: i, onError: r }); const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(o).then(u => { if (u.status === 200 || u.status === 0) { if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u; const h = Cs[e], d = u.body.getReader(), p = u.headers.get("Content-Length") || u.headers.get("X-File-Size"), m = p ? parseInt(p) : 0, v = m !== 0; let y = 0; const x = new ReadableStream({ start(A) { _(); function _() { d.read().then(({ done: M, value: S }) => { if (M) A.close(); else { y += S.byteLength; const b = new ProgressEvent("progress", { lengthComputable: v, loaded: y, total: m }); for (let B = 0, R = h.length; B < R; B++) { const E = h[B]; E.onProgress && E.onProgress(b) } A.enqueue(S), _() } }) } } }); return new Response(x) } else throw new pN(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u) }).then(u => { switch (l) { case "arraybuffer": return u.arrayBuffer(); case "blob": return u.blob(); case "document": return u.text().then(h => new DOMParser().parseFromString(h, a)); case "json": return u.json(); default: if (a === void 0) return u.text(); { const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, m = new TextDecoder(p); return u.arrayBuffer().then(v => m.decode(v)) } } }).then(u => { sl.add(e, u); const h = Cs[e]; delete Cs[e]; for (let d = 0, p = h.length; d < p; d++) { const m = h[d]; m.onLoad && m.onLoad(u) } }).catch(u => { const h = Cs[e]; if (h === void 0) throw this.manager.itemError(e), u; delete Cs[e]; for (let d = 0, p = h.length; d < p; d++) { const m = h[d]; m.onError && m.onError(u) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class mN extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new ji(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = []; for (let i = 0; i < e.length; i++) { const r = Uc.parse(e[i]); t.push(r) } return t } } class gN extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = [], a = new gA, l = new ji(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials); let u = 0; function h(d) { l.load(e[d], function (p) { const m = s.parse(p, !0); o[d] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, u += 1, u === 6 && (m.mipmapCount === 1 && (a.minFilter = tn), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a)) }, i, r) } if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d)h(d); else l.load(e, function (d) { const p = s.parse(d, !0); if (p.isCubemap) { const m = p.mipmaps.length / p.mipmapCount; for (let v = 0; v < m; v++) { o[v] = { mipmaps: [] }; for (let y = 0; y < p.mipmapCount; y++)o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + y]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height } a.image = o } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps; p.mipmapCount === 1 && (a.minFilter = tn), a.format = p.format, a.needsUpdate = !0, t && t(a) }, i, r); return a } } class $f extends vi { constructor(e) { super(e) } load(e, t, i, r) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = sl.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = Qf("img"); function l() { h(), sl.add(e, this), t && t(this), s.manager.itemEnd(e) } function u(d) { h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e) } function h() { a.removeEventListener("load", l, !1), a.removeEventListener("error", u, !1) } return a.addEventListener("load", l, !1), a.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a } } class yN extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = new yh, o = new $f(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let a = 0; function l(u) { o.load(e[u], function (h) { s.images[u] = h, a++, a === 6 && (s.needsUpdate = !0, t && t(s)) }, void 0, r) } for (let u = 0; u < e.length; ++u)l(u); return s } } class vN extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new wc, a = new ji(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function (l) { const u = s.parse(l); u && (u.image !== void 0 ? o.image = u.image : u.data !== void 0 && (o.image.width = u.width, o.image.height = u.height, o.image.data = u.data), o.wrapS = u.wrapS !== void 0 ? u.wrapS : Hn, o.wrapT = u.wrapT !== void 0 ? u.wrapT : Hn, o.magFilter = u.magFilter !== void 0 ? u.magFilter : tn, o.minFilter = u.minFilter !== void 0 ? u.minFilter : tn, o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.encoding !== void 0 && (o.encoding = u.encoding), u.flipY !== void 0 && (o.flipY = u.flipY), u.format !== void 0 && (o.format = u.format), u.type !== void 0 && (o.type = u.type), u.mipmaps !== void 0 && (o.mipmaps = u.mipmaps, o.minFilter = ls), u.mipmapCount === 1 && (o.minFilter = tn), u.generateMipmaps !== void 0 && (o.generateMipmaps = u.generateMipmaps), o.needsUpdate = !0, t && t(o, u)) }, i, r), o } } class Ih extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = new Zt, o = new $f(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) { s.image = a, s.needsUpdate = !0, t !== void 0 && t(s) }, i, r), s } } class ta extends bt { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Re(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t } } class CT extends ta { constructor(e, t, i) { super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Re(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const uy = new st, vS = new D, xS = new D; class TA { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new me(512, 512), this.map = null, this.mapPass = null, this.matrix = new st, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new P0, this._frameExtents = new me(1, 1), this._viewportCount = 1, this._viewports = [new Ft(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, i = this.matrix; vS.setFromMatrixPosition(e.matrixWorld), t.position.copy(vS), xS.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(xS), t.updateMatrixWorld(), uy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(uy), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(uy) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class xN extends TA { constructor() { super(new Ut(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, i = Xf * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far; (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class BA extends ta { constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt, this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new xN } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const AS = new st, Gu = new D, fy = new D; class AN extends TA { constructor() { super(new Ut(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new me(4, 2), this._viewportCount = 6, this._viewports = [new Ft(2, 1, 1, 1), new Ft(0, 1, 1, 1), new Ft(3, 1, 1, 1), new Ft(1, 1, 1, 1), new Ft(3, 0, 1, 1), new Ft(1, 0, 1, 1)], this._cubeDirections = [new D(1, 0, 0), new D(-1, 0, 0), new D(0, 0, 1), new D(0, 0, -1), new D(0, 1, 0), new D(0, -1, 0)], this._cubeUps = [new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 1, 0), new D(0, 0, 1), new D(0, 0, -1)] } updateMatrices(e, t = 0) { const i = this.camera, r = this.matrix, s = e.distance || i.far; s !== i.far && (i.far = s, i.updateProjectionMatrix()), Gu.setFromMatrixPosition(e.matrixWorld), i.position.copy(Gu), fy.copy(i.position), fy.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(fy), i.updateMatrixWorld(), r.makeTranslation(-Gu.x, -Gu.y, -Gu.z), AS.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(AS) } } class PA extends ta { constructor(e, t, i = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new AN } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class MN extends TA { constructor() { super(new kr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class RA extends ta { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt, this.shadow = new MN } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class ET extends ta { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class bT extends ta { constructor(e, t, i = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class TT { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new D) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const i = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], .546274 * (i * i - r * r)), t } getIrradianceAt(e, t) { const i = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * i), t.addScaledVector(o[4], 2 * .429043 * i * r), t.addScaledVector(o[5], 2 * .429043 * r * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * i * s), t.addScaledVector(o[8], .429043 * (i * i - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].addScaledVector(e.coefficients[i], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].lerp(e.coefficients[i], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].fromArray(e, t + r * 3); return this } toArray(e = [], t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].toArray(e, t + r * 3); return e } static getBasisAt(e, t) { const i = e.x, r = e.y, s = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * s, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = .546274 * (i * i - r * r) } } class z0 extends ta { constructor(e = new TT, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class U0 extends vi { constructor(e) { super(e), this.textures = {} } load(e, t, i, r) { const s = this, o = new ji(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = this.textures; function i(s) { return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s] } const r = U0.createMaterialFromType(e.type); if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Re().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) { const o = e.uniforms[s]; switch (r.uniforms[s] = {}, o.type) { case "t": r.uniforms[s].value = i(o.value); break; case "c": r.uniforms[s].value = new Re().setHex(o.value); break; case "v2": r.uniforms[s].value = new me().fromArray(o.value); break; case "v3": r.uniforms[s].value = new D().fromArray(o.value); break; case "v4": r.uniforms[s].value = new Ft().fromArray(o.value); break; case "m3": r.uniforms[s].value = new Vn().fromArray(o.value); break; case "m4": r.uniforms[s].value = new st().fromArray(o.value); break; default: r.uniforms[s].value = o.value } } if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) r.extensions[s] = e.extensions[s]; if (e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) { let s = e.normalScale; Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new me().fromArray(s) } return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new me().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: dT, SpriteMaterial: hA, RawShaderMaterial: pT, ShaderMaterial: cs, PointsMaterial: Ah, MeshPhysicalMaterial: qs, MeshStandardMaterial: $c, MeshPhongMaterial: mT, MeshToonMaterial: gT, MeshNormalMaterial: yT, MeshLambertMaterial: vT, MeshDepthMaterial: cA, MeshDistanceMaterial: uA, MeshBasicMaterial: Gi, MeshMatcapMaterial: xT, LineDashedMaterial: AT, LineBasicMaterial: oi, Material: En }; return new t[e] } } class ss { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let i = 0, r = e.length; i < r; i++)t += String.fromCharCode(e[i]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class BT extends ut { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class PT extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new ji(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = {}, i = {}; function r(m, v) { if (t[v] !== void 0) return t[v]; const x = m.interleavedBuffers[v], A = s(m, x.buffer), _ = lc(x.type, A), M = new vh(_, x.stride); return M.uuid = x.uuid, t[v] = M, M } function s(m, v) { if (i[v] !== void 0) return i[v]; const x = m.arrayBuffers[v], A = new Uint32Array(x).buffer; return i[v] = A, A } const o = e.isInstancedBufferGeometry ? new BT : new ut, a = e.data.index; if (a !== void 0) { const m = lc(a.type, a.array); o.setIndex(new It(m, 1)) } const l = e.data.attributes; for (const m in l) { const v = l[m]; let y; if (v.isInterleavedBufferAttribute) { const x = r(e.data, v.data); y = new jo(x, v.itemSize, v.offset, v.normalized) } else { const x = lc(v.type, v.array), A = v.isInstancedBufferAttribute ? Nc : It; y = new A(x, v.itemSize, v.normalized) } v.name !== void 0 && (y.name = v.name), v.usage !== void 0 && y.setUsage(v.usage), v.updateRange !== void 0 && (y.updateRange.offset = v.updateRange.offset, y.updateRange.count = v.updateRange.count), o.setAttribute(m, y) } const u = e.data.morphAttributes; if (u) for (const m in u) { const v = u[m], y = []; for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; let M; if (_.isInterleavedBufferAttribute) { const S = r(e.data, _.data); M = new jo(S, _.itemSize, _.offset, _.normalized) } else { const S = lc(_.type, _.array); M = new It(S, _.itemSize, _.normalized) } _.name !== void 0 && (M.name = _.name), y.push(M) } o.morphAttributes[m] = y } e.data.morphTargetsRelative && (o.morphTargetsRelative = !0); const d = e.data.groups || e.data.drawcalls || e.data.offsets; if (d !== void 0) for (let m = 0, v = d.length; m !== v; ++m) { const y = d[m]; o.addGroup(y.start, y.count, y.materialIndex) } const p = e.data.boundingSphere; if (p !== void 0) { const m = new D; p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new $o(m, p.radius) } return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o } } class _N extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = this.path === "" ? ss.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || o; const a = new ji(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { let u = null; try { u = JSON.parse(l) } catch (d) { r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message); return } const h = u.metadata; if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") { r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } s.parse(u, t) }, i, r) } async loadAsync(e, t) { const i = this, r = this.path === "" ? ss.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || r; const s = new ji(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials); const o = await s.loadAsync(e, t), a = JSON.parse(o), l = a.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await i.parseAsync(a) } parse(e, t) { const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function () { t !== void 0 && t(u) }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), u = this.parseObject(e.object, s, l, a, i), h = this.parseSkeletons(e.skeletons, u); if (this.bindSkeletons(u, h), t !== void 0) { let d = !1; for (const p in o) if (o[p].data instanceof HTMLImageElement) { d = !0; break } d === !1 && t(u) } return u } async parseAsync(e) { const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), u = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, u), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let i = 0, r = e.length; i < r; i++) { const s = new Ya().fromJSON(e[i]); t[s.uuid] = s } return t } parseSkeletons(e, t) { const i = {}, r = {}; if (t.traverse(function (s) { s.isBone && (r[s.uuid] = s) }), e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = new xh().fromJSON(e[s], r); i[a.uuid] = a } return i } parseGeometries(e, t) { const i = {}; if (e !== void 0) { const r = new PT; for (let s = 0, o = e.length; s < o; s++) { let a; const l = e[s]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = r.parse(l); break; default: l.type in yS ? a = yS[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a } } return i } parseMaterials(e, t) { const i = {}, r = {}; if (e !== void 0) { const s = new U0; s.setTextures(t); for (let o = 0, a = e.length; o < a; o++) { const l = e[o]; i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), r[l.uuid] = i[l.uuid] } } return r } parseAnimations(e) { const t = {}; if (e !== void 0) for (let i = 0; i < e.length; i++) { const r = e[i], s = Uc.parse(r); t[s.uuid] = s } return t } parseImages(e, t) { const i = this, r = {}; let s; function o(l) { return i.manager.itemStart(l), s.load(l, function () { i.manager.itemEnd(l) }, void 0, function () { i.manager.itemError(l), i.manager.itemEnd(l) }) } function a(l) { if (typeof l == "string") { const u = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u; return o(h) } else return l.data ? { data: lc(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new bA(t); s = new $f(l), s.setCrossOrigin(this.crossOrigin); for (let u = 0, h = e.length; u < h; u++) { const d = e[u], p = d.url; if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const x = p[v], A = a(x); A !== null && (A instanceof HTMLImageElement ? m.push(A) : m.push(new wc(A.data, A.width, A.height))) } r[d.uuid] = new Ua(m) } else { const m = a(d.url); r[d.uuid] = new Ua(m) } } } return r } async parseImagesAsync(e) { const t = this, i = {}; let r; async function s(o) { if (typeof o == "string") { const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a; return await r.loadAsync(l) } else return o.data ? { data: lc(o.type, o.data), width: o.width, height: o.height } : null } if (e !== void 0 && e.length > 0) { r = new $f(this.manager), r.setCrossOrigin(this.crossOrigin); for (let o = 0, a = e.length; o < a; o++) { const l = e[o], u = l.url; if (Array.isArray(u)) { const h = []; for (let d = 0, p = u.length; d < p; d++) { const m = u[d], v = await s(m); v !== null && (v instanceof HTMLImageElement ? h.push(v) : h.push(new wc(v.data, v.width, v.height))) } i[l.uuid] = new Ua(h) } else { const h = await s(l.url); i[l.uuid] = new Ua(h) } } } return i } parseTextures(e, t) { function i(s, o) { return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]) } const r = {}; if (e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = e[s]; a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image); const l = t[a.image], u = l.data; let h; Array.isArray(u) ? (h = new yh, u.length === 6 && (h.needsUpdate = !0)) : (u && u.data ? h = new wc : h = new Zt, u && (h.needsUpdate = !0)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = i(a.mapping, wN)), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = i(a.wrap[0], MS), h.wrapT = i(a.wrap[1], MS)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, _S)), a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, _S)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (h.userData = a.userData), r[a.uuid] = h } return r } parseObject(e, t, i, r, s) { let o; function a(p) { return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p] } function l(p) { if (p !== void 0) { if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const x = p[v]; i[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), m.push(i[x]) } return m } return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p] } } function u(p) { return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p] } let h, d; switch (e.type) { case "Scene": o = new fA, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Re(e.background) : o.background = u(e.background)), e.environment !== void 0 && (o.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new D0(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new I0(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity); break; case "PerspectiveCamera": o = new Ut(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "OrthographicCamera": o = new kr(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "AmbientLight": o = new ET(e.color, e.intensity); break; case "DirectionalLight": o = new RA(e.color, e.intensity); break; case "PointLight": o = new PA(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": o = new bT(e.color, e.intensity, e.width, e.height); break; case "SpotLight": o = new BA(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": o = new CT(e.color, e.groundColor, e.intensity); break; case "LightProbe": o = new z0().fromJSON(e); break; case "SkinnedMesh": h = a(e.geometry), d = l(e.material), o = new dA(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton); break; case "Mesh": h = a(e.geometry), d = l(e.material), o = new Pn(h, d); break; case "InstancedMesh": h = a(e.geometry), d = l(e.material); const p = e.count, m = e.instanceMatrix, v = e.instanceColor; o = new nT(h, d, p), o.instanceMatrix = new Nc(new Float32Array(m.array), 16), v !== void 0 && (o.instanceColor = new Nc(new Float32Array(v.array), v.itemSize)); break; case "LOD": o = new tT; break; case "Line": o = new Xs(a(e.geometry), l(e.material)); break; case "LineLoop": o = new pA(a(e.geometry), l(e.material)); break; case "LineSegments": o = new zr(a(e.geometry), l(e.material)); break; case "PointCloud": case "Points": o = new mA(a(e.geometry), l(e.material)); break; case "Sprite": o = new eT(l(e.material)); break; case "Group": o = new Fs; break; case "Bone": o = new F0; break; default: o = new bt }if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) { const p = e.children; for (let m = 0; m < p.length; m++)o.add(this.parseObject(p[m], t, i, r, s)) } if (e.animations !== void 0) { const p = e.animations; for (let m = 0; m < p.length; m++) { const v = p[m]; o.animations.push(s[v]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate); const p = e.levels; for (let m = 0; m < p.length; m++) { const v = p[m], y = o.getObjectByProperty("uuid", v.object); y !== void 0 && o.addLevel(y, v.distance, v.hysteresis) } } return o } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (i) { if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) { const r = t[i.skeleton]; r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix) } }) } } const wN = { UVMapping: E0, CubeReflectionMapping: Ho, CubeRefractionMapping: Vo, EquirectangularReflectionMapping: Hf, EquirectangularRefractionMapping: Vf, CubeUVReflectionMapping: Xc }, MS = { RepeatWrapping: Wo, ClampToEdgeWrapping: Hn, MirroredRepeatWrapping: Lc }, _S = { NearestFilter: pn, NearestMipmapNearestFilter: Wf, NearestMipmapLinearFilter: Mc, LinearFilter: tn, LinearMipmapNearestFilter: b0, LinearMipmapLinearFilter: ls }; class RT extends vi { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, i, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = sl.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = {}; a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" })) }).then(function (l) { sl.add(e, l), t && t(l), s.manager.itemEnd(e) }).catch(function (l) { r && r(l), s.manager.itemError(e), s.manager.itemEnd(e) }), s.manager.itemStart(e) } } let Rp; class LA { static getContext() { return Rp === void 0 && (Rp = new (window.AudioContext || window.webkitAudioContext)), Rp } static setContext(e) { Rp = e } } class SN extends vi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new ji(this.manager); o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { const l = a.slice(0); LA.getContext().decodeAudioData(l, function (h) { t(h) }) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } } class CN extends z0 { constructor(e, t, i = 1) { super(void 0, i), this.isHemisphereLightProbe = !0; const r = new Re().set(e), s = new Re().set(t), o = new D(r.r, r.g, r.b), a = new D(s.r, s.g, s.b), l = Math.sqrt(Math.PI), u = l * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u) } } class EN extends z0 { constructor(e, t = 1) { super(void 0, t), this.isAmbientLightProbe = !0; const i = new Re().set(e); this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } const wS = new st, SS = new st, ga = new st; class bN { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ut, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ut, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ga.copy(e.projectionMatrix); const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(Qa * t.fov * .5) / t.zoom; let a, l; SS.elements[12] = -r, wS.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, ga.elements[0] = 2 * t.near / (l - a), ga.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ga), a = -o * t.aspect - s, l = o * t.aspect - s, ga.elements[0] = 2 * t.near / (l - a), ga.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ga) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(SS), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(wS) } } class IA { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = CS(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = CS(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function CS() { return (typeof performance > "u" ? Date : performance).now() } const ya = new D, ES = new jn, TN = new D, va = new D; class BN extends bt { constructor() { super(), this.type = "AudioListener", this.context = LA.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new IA } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, i = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ya, ES, TN), va.set(0, 0, -1).applyQuaternion(ES), t.positionX) { const r = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(ya.x, r), t.positionY.linearRampToValueAtTime(ya.y, r), t.positionZ.linearRampToValueAtTime(ya.z, r), t.forwardX.linearRampToValueAtTime(va.x, r), t.forwardY.linearRampToValueAtTime(va.y, r), t.forwardZ.linearRampToValueAtTime(va.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r) } else t.setPosition(ya.x, ya.y, ya.z), t.setOrientation(va.x, va.y, va.z, i.x, i.y, i.z) } } class LT extends bt { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const xa = new D, bS = new jn, PN = new D, Aa = new D; class RN extends LT { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(xa, bS, PN), Aa.set(0, 0, 1).applyQuaternion(bS); const t = this.panner; if (t.positionX) { const i = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(xa.x, i), t.positionY.linearRampToValueAtTime(xa.y, i), t.positionZ.linearRampToValueAtTime(xa.z, i), t.orientationX.linearRampToValueAtTime(Aa.x, i), t.orientationY.linearRampToValueAtTime(Aa.y, i), t.orientationZ.linearRampToValueAtTime(Aa.z, i) } else t.setPosition(xa.x, xa.y, xa.z), t.setOrientation(Aa.x, Aa.y, Aa.z) } } class LN { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let i = 0; i < t.length; i++)e += t[i]; return e / t.length } } class IT { constructor(e, t, i) { this.binding = e, this.valueSize = i; let r, s, o; switch (t) { case "quaternion": r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5; break; case "string": case "bool": r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5); break; default: r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const i = this.buffer, r = this.valueSize, s = e * r + r; let o = this.cumulativeWeight; if (o === 0) { for (let a = 0; a !== r; ++a)i[s + a] = i[a]; o = t } else { o += t; const a = t / o; this._mixBufferRegion(i, s, 0, a, r) } this.cumulativeWeight = o } accumulateAdditive(e) { const t = this.buffer, i = this.valueSize, r = i * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) { const l = t * this._origIndex; this._mixBufferRegion(i, r, l, 1 - s, t) } o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t); for (let l = t, u = t + t; l !== u; ++l)if (i[l] !== i[l + t]) { a.setValue(i, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex; e.getValue(t, r); for (let s = i, o = r; s !== o; ++s)t[s] = t[r + s % i]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let i = e; i < t; i++)this.buffer[i] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let i = 0; i < this.valueSize; i++)this.buffer[t + i] = this.buffer[e + i] } _select(e, t, i, r, s) { if (r >= .5) for (let o = 0; o !== s; ++o)e[t + o] = e[i + o] } _slerp(e, t, i, r) { jn.slerpFlat(e, t, e, t, e, i, r) } _slerpAdditive(e, t, i, r, s) { const o = this._workIndex * s; jn.multiplyQuaternionsFlat(e, o, e, t, e, i), jn.slerpFlat(e, t, e, t, e, o, r) } _lerp(e, t, i, r, s) { const o = 1 - r; for (let a = 0; a !== s; ++a) { const l = t + a; e[l] = e[l] * o + e[i + a] * r } } _lerpAdditive(e, t, i, r, s) { for (let o = 0; o !== s; ++o) { const a = t + o; e[a] = e[a] + e[i + o] * r } } } const DA = "\\[\\]\\.:\\/", IN = new RegExp("[" + DA + "]", "g"), FA = "[^" + DA + "]", DN = "[^" + DA.replace("\\.", "") + "]", FN = /((?:WC+[\/:])*)/.source.replace("WC", FA), kN = /(WCOD+)?/.source.replace("WCOD", DN), NN = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", FA), ON = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", FA), zN = new RegExp("^" + FN + kN + NN + ON + "$"), UN = ["material", "materials", "bones", "map"]; class GN { constructor(e, t, i) { const r = i || Et.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const i = this._targetGroup.nCachedObjects_, r = this._bindings[i]; r !== void 0 && r.getValue(e, t) } setValue(e, t) { const i = this._bindings; for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)i[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } } class Et { constructor(e, t, i) { this.path = t, this.parsedPath = i || Et.parseTrackName(t), this.node = Et.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, i) { return e && e.isAnimationObjectGroup ? new Et.Composite(e, t, i) : new Et(e, t, i) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(IN, "") } static parseTrackName(e) { const t = zN.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf("."); if (r !== void 0 && r !== -1) { const s = i.nodeName.substring(r + 1); UN.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s) } if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const i = e.skeleton.getBoneByName(t); if (i !== void 0) return i } if (e.children) { const i = function (s) { for (let o = 0; o < s.length; o++) { const a = s[o]; if (a.name === t || a.uuid === t) return a; const l = i(a.children); if (l) return l } return null }, r = i(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)e[t++] = i[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, i = t.objectName, r = t.propertyName; let s = t.propertyIndex; if (e || (e = Et.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); return } if (i) { let u = t.objectIndex; switch (i) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let h = 0; h < e.length; h++)if (e[h].name === u) { u = h; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[i] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[i] }if (u !== void 0) { if (e[u] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[u] } } const o = e[r]; if (o === void 0) { const u = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (s !== void 0) { if (r === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Et.Composite = GN; Et.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Et.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Et.prototype.GetterByBindingType = [Et.prototype._getValue_direct, Et.prototype._getValue_array, Et.prototype._getValue_arrayElement, Et.prototype._getValue_toArray]; Et.prototype.SetterByBindingTypeAndVersioning = [[Et.prototype._setValue_direct, Et.prototype._setValue_direct_setNeedsUpdate, Et.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Et.prototype._setValue_array, Et.prototype._setValue_array_setNeedsUpdate, Et.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Et.prototype._setValue_arrayElement, Et.prototype._setValue_arrayElement_setNeedsUpdate, Et.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Et.prototype._setValue_fromArray, Et.prototype._setValue_fromArray_setNeedsUpdate, Et.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class HN { constructor() { this.isAnimationObjectGroup = !0, this.uuid = Vi(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let i = 0, r = arguments.length; i !== r; ++i)e[arguments[i].uuid] = i; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length; let a, l = e.length, u = this.nCachedObjects_; for (let h = 0, d = arguments.length; h !== d; ++h) { const p = arguments[h], m = p.uuid; let v = t[m]; if (v === void 0) { v = l++, t[m] = v, e.push(p); for (let y = 0, x = o; y !== x; ++y)s[y].push(new Et(p, i[y], r[y])) } else if (v < u) { a = e[v]; const y = --u, x = e[y]; t[x.uuid] = v, e[v] = x, t[m] = y, e[y] = p; for (let A = 0, _ = o; A !== _; ++A) { const M = s[A], S = M[y]; let b = M[v]; M[v] = S, b === void 0 && (b = new Et(p, i[A], r[A])), M[y] = b } } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = u } remove() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let s = this.nCachedObjects_; for (let o = 0, a = arguments.length; o !== a; ++o) { const l = arguments[o], u = l.uuid, h = t[u]; if (h !== void 0 && h >= s) { const d = s++, p = e[d]; t[p.uuid] = h, e[h] = p, t[u] = d, e[d] = l; for (let m = 0, v = r; m !== v; ++m) { const y = i[m], x = y[d], A = y[h]; y[h] = x, y[d] = A } } } this.nCachedObjects_ = s } uncache() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let s = this.nCachedObjects_, o = e.length; for (let a = 0, l = arguments.length; a !== l; ++a) { const u = arguments[a], h = u.uuid, d = t[h]; if (d !== void 0) if (delete t[h], d < s) { const p = --s, m = e[p], v = --o, y = e[v]; t[m.uuid] = d, e[d] = m, t[y.uuid] = p, e[p] = y, e.pop(); for (let x = 0, A = r; x !== A; ++x) { const _ = i[x], M = _[p], S = _[v]; _[d] = M, _[p] = S, _.pop() } } else { const p = --o, m = e[p]; p > 0 && (t[m.uuid] = d), e[d] = m, e.pop(); for (let v = 0, y = r; v !== y; ++v) { const x = i[v]; x[d] = x[p], x.pop() } } } this.nCachedObjects_ = s } subscribe_(e, t) { const i = this._bindingsIndicesByPath; let r = i[e]; const s = this._bindings; if (r !== void 0) return s[r]; const o = this._paths, a = this._parsedPaths, l = this._objects, u = l.length, h = this.nCachedObjects_, d = new Array(u); r = s.length, i[e] = r, o.push(e), a.push(t), s.push(d); for (let p = h, m = l.length; p !== m; ++p) { const v = l[p]; d[p] = new Et(v, e, t) } return d } unsubscribe_(e) { const t = this._bindingsIndicesByPath, i = t[e]; if (i !== void 0) { const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], u = e[a]; t[u] = i, o[i] = l, o.pop(), s[i] = s[a], s.pop(), r[i] = r[a], r.pop() } } } class VN { constructor(e, t, i = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r; const s = t.tracks, o = s.length, a = new Array(o), l = { endingStart: Oa, endingEnd: Oa }; for (let u = 0; u !== o; ++u) { const h = s[u].createInterpolant(null); a[u] = h, h.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = R5, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s; e.warp(1, o, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, i) { return e.crossFadeFrom(this, t, i) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { const r = this._mixer, s = r.time, o = this.timeScale; let a = this._timeScaleInterpolant; a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); const l = a.parameterPositions, u = a.sampleValues; return l[0] = s, l[1] = s + i, u[0] = e / o, u[1] = t / o, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, i, r) { if (!this.enabled) { this._updateWeight(e); return } const s = this._startTime; if (s !== null) { const l = (e - s) * i; l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l) } t *= this._updateTimeScale(e); const o = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const l = this._interpolants, u = this._propertyBindings; switch (this.blendMode) { case qx: for (let h = 0, d = l.length; h !== d; ++h)l[h].evaluate(o), u[h].accumulateAdditive(a); break; case T0: default: for (let h = 0, d = l.length; h !== d; ++h)l[h].evaluate(o), u[h].accumulate(r, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const i = this._weightInterpolant; if (i !== null) { const r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const i = this._timeScaleInterpolant; if (i !== null) { const r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, i = this.loop; let r = this.time + e, s = this._loopCount; const o = i === L5; if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r; if (i === P5) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) { const a = Math.floor(r / t); r -= t * a, s += Math.abs(a); const l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const u = e < 0; this._setEndings(u, !u, o) } else this._setEndings(!1, !1, o); this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (s & 1) === 1) return t - r } return r } _setEndings(e, t, i) { const r = this._interpolantSettings; i ? (r.endingStart = za, r.endingEnd = za) : (e ? r.endingStart = this.zeroSlopeAtStart ? za : Oa : r.endingStart = jf, t ? r.endingEnd = this.zeroSlopeAtEnd ? za : Oa : r.endingEnd = jf) } _scheduleFading(e, t, i) { const r = this._mixer, s = r.time; let o = this._weightInterpolant; o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this } } const WN = new Float32Array(1); class jN extends us { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = i.uuid, u = this._bindingsByRootAndName; let h = u[l]; h === void 0 && (h = {}, u[l] = h); for (let d = 0; d !== s; ++d) { const p = r[d], m = p.name; let v = h[m]; if (v !== void 0) ++v.referenceCount, o[d] = v; else { if (v = o[d], v !== void 0) { v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, m)); continue } const y = t && t._propertyBindings[d].binding.parsedPath; v = new IT(Et.create(i, m, y), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, m), o[d] = v } a[d].resultBuffer = v.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r]; this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i) } const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, i) { const r = this._actions, s = this._actionsByClip; let o = s[t]; if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = o; else { const a = o.knownActions; e._byClipCacheIndex = a.length, a.push(e) } e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e } _removeInactiveAction(e) { const t = this._actions, i = t[t.length - 1], r = e._cacheIndex; i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null; const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, u = l[l.length - 1], h = e._byClipCacheIndex; u._byClipCacheIndex = h, l[h] = u, l.pop(), e._byClipCacheIndex = null; const d = a.actionByRoot, p = (e._localRoot || this._root).uuid; delete d[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; --s.referenceCount === 0 && this._removeInactiveBinding(s) } } _lendAction(e) { const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _takeBackAction(e) { const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _addInactiveBinding(e, t, i) { const r = this._bindingsByRootAndName, s = this._bindings; let o = r[t]; o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e) } _removeInactiveBinding(e) { const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], u = e._cacheIndex; l._cacheIndex = u, t[u] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r] } _lendBinding(e) { const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _takeBackBinding(e) { const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let i = e[t]; return i === void 0 && (i = new CA(new Float32Array(2), new Float32Array(2), 1, WN), i.__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r]; e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s } clipAction(e, t, i) { const r = t || this._root, s = r.uuid; let o = typeof e == "string" ? Uc.findByName(r, e) : e; const a = o !== null ? o.uuid : e, l = this._actionsByClip[a]; let u = null; if (i === void 0 && (o !== null ? i = o.blendMode : i = T0), l !== void 0) { const d = l.actionByRoot[s]; if (d !== void 0 && d.blendMode === i) return d; u = l.knownActions[0], o === null && (o = u._clip) } if (o === null) return null; const h = new VN(this, o, t, i); return this._bindAction(h, u), this._addInactiveAction(h, a, s), h } existingAction(e, t) { const i = t || this._root, r = i.uuid, s = typeof e == "string" ? Uc.findByName(i, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o]; return a !== void 0 && a.actionByRoot[r] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let i = t - 1; i >= 0; --i)e[i].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1; for (let u = 0; u !== i; ++u)t[u]._update(r, e, s, o); const a = this._bindings, l = this._nActiveBindings; for (let u = 0; u !== l; ++u)a[u].apply(o); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i]; if (s !== void 0) { const o = s.knownActions; for (let a = 0, l = o.length; a !== l; ++a) { const u = o[a]; this._deactivateAction(u); const h = u._cacheIndex, d = t[t.length - 1]; u._cacheIndex = null, u._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(u) } delete r[i] } } uncacheRoot(e) { const t = e.uuid, i = this._actionsByClip; for (const o in i) { const a = i[o].actionByRoot, l = a[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const r = this._bindingsByRootAndName, s = r[t]; if (s !== void 0) for (const o in s) { const a = s[o]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction(e, t) { const i = this.existingAction(e, t); i !== null && (this._deactivateAction(i), this._removeInactiveAction(i)) } } class kA { constructor(e) { this.value = e } clone() { return new kA(this.value.clone === void 0 ? this.value : this.value.clone()) } } let JN = 0; class XN extends us { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: JN++ }), this.name = "", this.usage = Jf, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let i = 0, r = t.length; i < r; i++)this.uniforms.push(t[i].clone()); return this } clone() { return new this.constructor().copy(this) } } class QN extends vh { constructor(e, t, i = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class KN { constructor(e, t, i, r, s) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } class DT { constructor(e, t, i = 0, r = 1 / 0) { this.ray = new mh(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Ka, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, i = []) { return A2(e, this, i, t), i.sort(TS), i } intersectObjects(e, t = !0, i = []) { for (let r = 0, s = e.length; r < s; r++)A2(e[r], this, i, t); return i.sort(TS), i } } function TS(n, e) { return n.distance - e.distance } function A2(n, e, t, i) { if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) { const r = n.children; for (let s = 0, o = r.length; s < o; s++)A2(r[s], e, t, !0) } } class M2 { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.phi = t, this.theta = i, this } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(xn(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class YN { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.theta = t, this.y = i, this } set(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } clone() { return new this.constructor().copy(this) } } const BS = new me; class qN { constructor(e = new me(1 / 0, 1 / 0), t = new me(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = BS.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, BS).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const PS = new D, Lp = new D; class ZN { constructor(e = new D, t = new D) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { PS.subVectors(e, this.start), Lp.subVectors(this.end, this.start); const i = Lp.dot(Lp); let s = Lp.dot(PS) / i; return t && (s = xn(s, 0, 1)), s } closestPointToPoint(e, t, i) { const r = this.closestPointToPointParameter(e, t); return this.delta(i).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const RS = new D; class $N extends bt { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const i = new ut, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, a = 1, l = 32; o < l; o++, a++) { const u = o / l * Math.PI * 2, h = a / l * Math.PI * 2; r.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1) } i.setAttribute("position", new je(r, 3)); const s = new oi({ fog: !1, toneMapped: !1 }); this.cone = new zr(i, s), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), RS.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(RS), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const fo = new D, Ip = new st, hy = new st; class eO extends zr { constructor(e) { const t = FT(e), i = new ut, r = [], s = [], o = new Re(0, 0, 1), a = new Re(0, 1, 0); for (let u = 0; u < t.length; u++) { const h = t[u]; h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b)) } i.setAttribute("position", new je(r, 3)), i.setAttribute("color", new je(s, 3)); const l = new oi({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, i = this.geometry, r = i.getAttribute("position"); hy.copy(this.root.matrixWorld).invert(); for (let s = 0, o = 0; s < t.length; s++) { const a = t[s]; a.parent && a.parent.isBone && (Ip.multiplyMatrices(hy, a.matrixWorld), fo.setFromMatrixPosition(Ip), r.setXYZ(o, fo.x, fo.y, fo.z), Ip.multiplyMatrices(hy, a.parent.matrixWorld), fo.setFromMatrixPosition(Ip), r.setXYZ(o + 1, fo.x, fo.y, fo.z), o += 2) } i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function FT(n) { const e = []; n.isBone === !0 && e.push(n); for (let t = 0; t < n.children.length; t++)e.push.apply(e, FT(n.children[t])); return e } class tO extends Pn { constructor(e, t, i) { const r = new Zc(t, 4, 2), s = new Gi({ wireframe: !0, fog: !1, toneMapped: !1 }); super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const nO = new D, LS = new Re, IS = new Re; class iO extends bt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper"; const r = new qc(t); r.rotateY(Math.PI * .5), this.material = new Gi({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const s = r.getAttribute("position"), o = new Float32Array(s.count * 3); r.setAttribute("color", new It(o, 3)), this.add(new Pn(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); LS.copy(this.light.color), IS.copy(this.light.groundColor); for (let i = 0, r = t.count; i < r; i++) { const s = i < r / 2 ? LS : IS; t.setXYZ(i, s.r, s.g, s.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(nO.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class rO extends zr { constructor(e = 10, t = 10, i = 4473924, r = 8947848) { i = new Re(i), r = new Re(r); const s = t / 2, o = e / t, a = e / 2, l = [], u = []; for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) { l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a); const y = p === s ? i : r; y.toArray(u, m), m += 3, y.toArray(u, m), m += 3, y.toArray(u, m), m += 3, y.toArray(u, m), m += 3 } const h = new ut; h.setAttribute("position", new je(l, 3)), h.setAttribute("color", new je(u, 3)); const d = new oi({ vertexColors: !0, toneMapped: !1 }); super(h, d), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class sO extends zr { constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) { s = new Re(s), o = new Re(o); const a = [], l = []; if (t > 1) for (let d = 0; d < t; d++) { const p = d / t * (Math.PI * 2), m = Math.sin(p) * e, v = Math.cos(p) * e; a.push(0, 0, 0), a.push(m, 0, v); const y = d & 1 ? s : o; l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b) } for (let d = 0; d < i; d++) { const p = d & 1 ? s : o, m = e - e / i * d; for (let v = 0; v < r; v++) { let y = v / r * (Math.PI * 2), x = Math.sin(y) * m, A = Math.cos(y) * m; a.push(x, 0, A), l.push(p.r, p.g, p.b), y = (v + 1) / r * (Math.PI * 2), x = Math.sin(y) * m, A = Math.cos(y) * m, a.push(x, 0, A), l.push(p.r, p.g, p.b) } } const u = new ut; u.setAttribute("position", new je(a, 3)), u.setAttribute("color", new je(l, 3)); const h = new oi({ vertexColors: !0, toneMapped: !1 }); super(u, h), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const DS = new D, Dp = new D, FS = new D; class oO extends bt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let r = new ut; r.setAttribute("position", new je([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const s = new oi({ fog: !1, toneMapped: !1 }); this.lightPlane = new Xs(r, s), this.add(this.lightPlane), r = new ut, r.setAttribute("position", new je([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Xs(r, s), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), DS.setFromMatrixPosition(this.light.matrixWorld), Dp.setFromMatrixPosition(this.light.target.matrixWorld), FS.subVectors(Dp, DS), this.lightPlane.lookAt(Dp), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Dp), this.targetLine.scale.z = FS.length() } } const Fp = new D, hn = new gh; class aO extends zr { constructor(e) { const t = new ut, i = new oi({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a(v, y) { l(v), l(y) } function l(v) { r.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(r.length / 3 - 1) } t.setAttribute("position", new je(r, 3)), t.setAttribute("color", new je(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update(); const u = new Re(16755200), h = new Re(16711680), d = new Re(43775), p = new Re(16777215), m = new Re(3355443); this.setColors(u, h, d, p, m) } setColors(e, t, i, r, s) { const a = this.geometry.getAttribute("color"); a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, i = 1, r = 1; hn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yn("c", t, e, hn, 0, 0, -1), yn("t", t, e, hn, 0, 0, 1), yn("n1", t, e, hn, -i, -r, -1), yn("n2", t, e, hn, i, -r, -1), yn("n3", t, e, hn, -i, r, -1), yn("n4", t, e, hn, i, r, -1), yn("f1", t, e, hn, -i, -r, 1), yn("f2", t, e, hn, i, -r, 1), yn("f3", t, e, hn, -i, r, 1), yn("f4", t, e, hn, i, r, 1), yn("u1", t, e, hn, i * .7, r * 1.1, -1), yn("u2", t, e, hn, -i * .7, r * 1.1, -1), yn("u3", t, e, hn, 0, r * 2, -1), yn("cf1", t, e, hn, -i, 0, 1), yn("cf2", t, e, hn, i, 0, 1), yn("cf3", t, e, hn, 0, -r, 1), yn("cf4", t, e, hn, 0, r, 1), yn("cn1", t, e, hn, -i, 0, -1), yn("cn2", t, e, hn, i, 0, -1), yn("cn3", t, e, hn, 0, -r, -1), yn("cn4", t, e, hn, 0, r, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function yn(n, e, t, i, r, s, o) { Fp.set(r, s, o).unproject(i); const a = e[n]; if (a !== void 0) { const l = t.getAttribute("position"); for (let u = 0, h = a.length; u < h; u++)l.setXYZ(a[u], Fp.x, Fp.y, Fp.z) } } const kp = new Zo; class lO extends zr { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new ut; s.setIndex(new It(i, 1)), s.setAttribute("position", new It(r, 3)), super(s, new oi({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && kp.setFromObject(this.object), kp.isEmpty()) return; const t = kp.min, i = kp.max, r = this.geometry.attributes.position, s = r.array; s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class cO extends zr { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new ut; s.setIndex(new It(i, 1)), s.setAttribute("position", new je(r, 3)), super(s, new oi({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class uO extends Xs { constructor(e, t = 1, i = 16776960) { const r = i, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new ut; o.setAttribute("position", new je(s, 3)), o.computeBoundingSphere(), super(o, new oi({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new ut; l.setAttribute("position", new je(a, 3)), l.computeBoundingSphere(), this.add(new Pn(l, new Gi({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const kS = new D; let Np, dy; class fO extends bt { constructor(e = new D(0, 0, 1), t = new D(0, 0, 0), i = 1, r = 16776960, s = i * .2, o = s * .2) { super(), this.type = "ArrowHelper", Np === void 0 && (Np = new ut, Np.setAttribute("position", new je([0, 0, 0, 0, 1, 0], 3)), dy = new cl(0, .5, 1, 5, 1), dy.translate(0, -.5, 0)), this.position.copy(t), this.line = new Xs(Np, new oi({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Pn(dy, new Gi({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { kS.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(kS, t) } } setLength(e, t = e * .2, i = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class hO extends zr { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], r = new ut; r.setAttribute("position", new je(t, 3)), r.setAttribute("color", new je(i, 3)); const s = new oi({ vertexColors: !0, toneMapped: !1 }); super(r, s), this.type = "AxesHelper" } setColors(e, t, i) { const r = new Re, s = this.geometry.attributes.color.array; return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class dO { constructor() { this.type = "ShapePath", this.color = new Re, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Kf, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, i, r) { return this.currentPath.quadraticCurveTo(e, t, i, r), this } bezierCurveTo(e, t, i, r, s, o) { return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(A) { const _ = []; for (let M = 0, S = A.length; M < S; M++) { const b = A[M], B = new Ya; B.curves = b.curves, _.push(B) } return _ } function i(A, _) { const M = _.length; let S = !1; for (let b = M - 1, B = 0; B < M; b = B++) { let R = _[b], E = _[B], P = E.x - R.x, L = E.y - R.y; if (Math.abs(L) > Number.EPSILON) { if (L < 0 && (R = _[B], P = -P, E = _[b], L = -L), A.y < R.y || A.y > E.y) continue; if (A.y === R.y) { if (A.x === R.x) return !0 } else { const z = L * (A.x - R.x) - P * (A.y - R.y); if (z === 0) return !0; if (z < 0) continue; S = !S } } else { if (A.y !== R.y) continue; if (E.x <= A.x && A.x <= R.x || R.x <= A.x && A.x <= E.x) return !0 } } return S } const r = rs.isClockWise, s = this.subPaths; if (s.length === 0) return []; let o, a, l; const u = []; if (s.length === 1) return a = s[0], l = new Ya, l.curves = a.curves, u.push(l), u; let h = !r(s[0].getPoints()); h = e ? !h : h; const d = [], p = []; let m = [], v = 0, y; p[v] = void 0, m[v] = []; for (let A = 0, _ = s.length; A < _; A++)a = s[A], y = a.getPoints(), o = r(y), o = e ? !o : o, o ? (!h && p[v] && v++, p[v] = { s: new Ya, p: y }, p[v].s.curves = a.curves, h && v++, m[v] = []) : m[v].push({ h: a, p: y[0] }); if (!p[0]) return t(s); if (p.length > 1) { let A = !1, _ = 0; for (let M = 0, S = p.length; M < S; M++)d[M] = []; for (let M = 0, S = p.length; M < S; M++) { const b = m[M]; for (let B = 0; B < b.length; B++) { const R = b[B]; let E = !0; for (let P = 0; P < p.length; P++)i(R.p, p[P].p) && (M !== P && _++, E ? (E = !1, d[P].push(R)) : A = !0); E && d[M].push(R) } } _ > 0 && A === !1 && (m = d) } let x; for (let A = 0, _ = p.length; A < _; A++) { l = p[A].s, u.push(l), x = m[A]; for (let M = 0, S = x.length; M < S; M++)l.holes.push(x[M].h) } return u } } const Bs = pO(); function pO() { const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), i = new Uint32Array(512), r = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const u = l - 127; u < -27 ? (i[l] = 0, i[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : u < -14 ? (i[l] = 1024 >> -u - 14, i[l | 256] = 1024 >> -u - 14 | 32768, r[l] = -u - 1, r[l | 256] = -u - 1) : u <= 15 ? (i[l] = u + 15 << 10, i[l | 256] = u + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : u < 128 ? (i[l] = 31744, i[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, r[l] = 13, r[l | 256] = 13) } const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let u = l << 13, h = 0; for (; !(u & 8388608);)u <<= 1, h -= 8388608; u &= -8388609, h += 947912704, s[l] = u | h } for (let l = 1024; l < 2048; ++l)s[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)o[l] = l << 23; o[31] = 1199570944, o[32] = 2147483648; for (let l = 33; l < 63; ++l)o[l] = 2147483648 + (l - 32 << 23); o[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (a[l] = 1024); return { floatView: e, uint32View: t, baseTable: i, shiftTable: r, mantissaTable: s, exponentTable: o, offsetTable: a } } function mO(n) { Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = xn(n, -65504, 65504), Bs.floatView[0] = n; const e = Bs.uint32View[0], t = e >> 23 & 511; return Bs.baseTable[t] + ((e & 8388607) >> Bs.shiftTable[t]) } function gO(n) { const e = n >> 10; return Bs.uint32View[0] = Bs.mantissaTable[Bs.offsetTable[e] + (n & 1023)] + Bs.exponentTable[e], Bs.floatView[0] } const yO = { toHalfFloat: mO, fromHalfFloat: gO }; class vO extends ea { constructor(e, t, i, r, s, o) { console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, i, r, s, o) } } class xO extends Mh { constructor(e, t, i, r) { console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, i, r) } } class AO extends _h { constructor(e, t, i, r) { console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, i, r) } } class MO extends wh { constructor(e, t, i, r, s, o, a) { console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, i, r, s, o, a) } } class _O extends cl { constructor(e, t, i, r, s, o, a, l) { console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, i, r, s, o, a, l) } } class wO extends Sh { constructor(e, t) { console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t) } } class SO extends Ch { constructor(e, t) { console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t) } } class CO extends Eh { constructor(e, t) { console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t) } } class EO extends Yc { constructor(e, t, i, r) { console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, i, r) } } class bO extends qc { constructor(e, t) { console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t) } } class TO extends Qc { constructor(e, t, i, r) { console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, i, r) } } class BO extends Ys { constructor(e, t, i, r) { console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, i, r) } } class PO extends bh { constructor(e, t, i, r, s, o) { console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, i, r, s, o) } } class RO extends Th { constructor(e, t) { console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t) } } class LO extends Zc { constructor(e, t, i, r, s, o, a) { console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, i, r, s, o, a) } } class IO extends Bh { constructor(e, t) { console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t) } } class DO extends Ph { constructor(e, t, i, r, s) { console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, i, r, s) } } class FO extends Rh { constructor(e, t, i, r, s, o) { console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, i, r, s, o) } } class kO extends Lh { constructor(e, t, i, r, s) { console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, i, r, s) } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: S0 } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = S0); const NO = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: Kx, AddEquation: Ra, AddOperation: u5, AdditiveAnimationBlendMode: qx, AdditiveBlending: Ov, AlphaFormat: A5, AlwaysDepth: i5, AlwaysStencilFunc: N5, AmbientLight: ET, AmbientLightProbe: EN, AnimationClip: Uc, AnimationLoader: mN, AnimationMixer: jN, AnimationObjectGroup: HN, AnimationUtils: fN, ArcCurve: iT, ArrayCamera: Y5, ArrowHelper: fO, Audio: LT, AudioAnalyser: LN, AudioContext: LA, AudioListener: BN, AudioLoader: SN, AxesHelper: hO, BackSide: Bi, BasicDepthPacking: D5, BasicShadowMap: Vb, Bone: F0, BooleanKeyframeTrack: ul, Box2: qN, Box3: Zo, Box3Helper: cO, BoxBufferGeometry: vO, BoxGeometry: ea, BoxHelper: lO, BufferAttribute: It, BufferGeometry: ut, BufferGeometryLoader: PT, ByteType: m5, Cache: sl, Camera: gh, CameraHelper: aO, CanvasTexture: Fk, CapsuleBufferGeometry: xO, CapsuleGeometry: Mh, CatmullRomCurve3: rT, CineonToneMapping: d5, CircleBufferGeometry: AO, CircleGeometry: _h, ClampToEdgeWrapping: Hn, Clock: IA, Color: Re, ColorKeyframeTrack: EA, ColorManagement: ni, CompressedArrayTexture: Dk, CompressedTexture: gA, CompressedTextureLoader: gN, ConeBufferGeometry: MO, ConeGeometry: wh, CubeCamera: oA, CubeReflectionMapping: Ho, CubeRefractionMapping: Vo, CubeTexture: yh, CubeTextureLoader: yN, CubeUVReflectionMapping: Xc, CubicBezierCurve: vA, CubicBezierCurve3: sT, CubicInterpolant: _T, CullFaceBack: Nv, CullFaceFront: Hb, CullFaceFrontBack: DR, CullFaceNone: Gb, Curve: Ur, CurvePath: aT, CustomBlending: Wb, CustomToneMapping: p5, CylinderBufferGeometry: _O, CylinderGeometry: cl, Cylindrical: YN, Data3DTexture: iA, DataArrayTexture: B0, DataTexture: wc, DataTextureLoader: vN, DataUtils: yO, DecrementStencilOp: jR, DecrementWrapStencilOp: XR, DefaultLoadingManager: fc, DepthFormat: Oo, DepthStencilFormat: nl, DepthTexture: q5, DirectionalLight: RA, DirectionalLightHelper: oO, DiscreteInterpolant: wT, DisplayP3ColorSpace: $x, DodecahedronBufferGeometry: wO, DodecahedronGeometry: Sh, DoubleSide: Lr, DstAlphaFactor: qb, DstColorFactor: $b, DynamicCopyUsage: aL, DynamicDrawUsage: Xa, DynamicReadUsage: rL, EdgesGeometry: lT, EllipseCurve: k0, EqualDepth: s5, EqualStencilFunc: qR, EquirectangularReflectionMapping: Hf, EquirectangularRefractionMapping: Vf, Euler: ll, EventDispatcher: us, ExtrudeBufferGeometry: SO, ExtrudeGeometry: Ch, FileLoader: ji, Float16BufferAttribute: XL, Float32BufferAttribute: je, Float64BufferAttribute: QL, FloatType: Is, Fog: D0, FogExp2: I0, FramebufferTexture: Ik, FrontSide: as, Frustum: P0, GLBufferAttribute: KN, GLSL1: cL, GLSL3: h2, GreaterDepth: a5, GreaterEqualDepth: o5, GreaterEqualStencilFunc: tL, GreaterStencilFunc: $R, GridHelper: rO, Group: Fs, HalfFloatType: Ic, HemisphereLight: CT, HemisphereLightHelper: iO, HemisphereLightProbe: CN, IcosahedronBufferGeometry: CO, IcosahedronGeometry: Eh, ImageBitmapLoader: RT, ImageLoader: $f, ImageUtils: nA, IncrementStencilOp: WR, IncrementWrapStencilOp: JR, InstancedBufferAttribute: Nc, InstancedBufferGeometry: BT, InstancedInterleavedBuffer: QN, InstancedMesh: nT, Int16BufferAttribute: jL, Int32BufferAttribute: JL, Int8BufferAttribute: HL, IntType: y5, InterleavedBuffer: vh, InterleavedBufferAttribute: jo, Interpolant: eu, InterpolateDiscrete: Dc, InterpolateLinear: il, InterpolateSmooth: um, InvertStencilOp: QR, KeepStencilOp: fm, KeyframeTrack: Gr, LOD: tT, LatheBufferGeometry: EO, LatheGeometry: Yc, Layers: Ka, LessDepth: r5, LessEqualDepth: Hm, LessEqualStencilFunc: ZR, LessStencilFunc: YR, Light: ta, LightProbe: z0, Line: Xs, Line3: ZN, LineBasicMaterial: oi, LineCurve: N0, LineCurve3: oT, LineDashedMaterial: AT, LineLoop: pA, LineSegments: zr, LinearEncoding: Js, LinearFilter: tn, LinearInterpolant: CA, LinearMipMapLinearFilter: zR, LinearMipMapNearestFilter: OR, LinearMipmapLinearFilter: ls, LinearMipmapNearestFilter: b0, LinearSRGBColorSpace: Fc, LinearToneMapping: f5, Loader: vi, LoaderUtils: ss, LoadingManager: bA, LoopOnce: P5, LoopPingPong: L5, LoopRepeat: R5, LuminanceAlphaFormat: _5, LuminanceFormat: M5, MOUSE: Ca, Material: En, MaterialLoader: U0, MathUtils: tA, Matrix3: Vn, Matrix4: st, MaxEquation: Hv, Mesh: Pn, MeshBasicMaterial: Gi, MeshDepthMaterial: cA, MeshDistanceMaterial: uA, MeshLambertMaterial: vT, MeshMatcapMaterial: xT, MeshNormalMaterial: yT, MeshPhongMaterial: mT, MeshPhysicalMaterial: qs, MeshStandardMaterial: $c, MeshToonMaterial: gT, MinEquation: Gv, MirroredRepeatWrapping: Lc, MixOperation: c5, MultiplyBlending: Uv, MultiplyOperation: ph, NearestFilter: pn, NearestMipMapLinearFilter: NR, NearestMipMapNearestFilter: kR, NearestMipmapLinearFilter: Mc, NearestMipmapNearestFilter: Wf, NeverDepth: n5, NeverStencilFunc: KR, NoBlending: Os, NoColorSpace: GR, NoToneMapping: Fr, NormalAnimationBlendMode: T0, NormalBlending: ja, NotEqualDepth: l5, NotEqualStencilFunc: eL, NumberKeyframeTrack: Oc, Object3D: bt, ObjectLoader: _N, ObjectSpaceNormalMap: k5, OctahedronBufferGeometry: bO, OctahedronGeometry: qc, OneFactor: Qb, OneMinusDstAlphaFactor: Zb, OneMinusDstColorFactor: e5, OneMinusSrcAlphaFactor: Qx, OneMinusSrcColorFactor: Yb, OrthographicCamera: kr, PCFShadowMap: C0, PCFSoftShadowMap: df, PMREMGenerator: p2, Path: Kf, PerspectiveCamera: Ut, Plane: xo, PlaneBufferGeometry: TO, PlaneGeometry: Qc, PlaneHelper: uO, PointLight: PA, PointLightHelper: tO, Points: mA, PointsMaterial: Ah, PolarGridHelper: sO, PolyhedronBufferGeometry: BO, PolyhedronGeometry: Ys, PositionalAudio: RN, PropertyBinding: Et, PropertyMixer: IT, QuadraticBezierCurve: xA, QuadraticBezierCurve3: AA, Quaternion: jn, QuaternionKeyframeTrack: Jo, QuaternionLinearInterpolant: ST, RED_GREEN_RGTC2_Format: u2, RED_RGTC1_Format: B5, REVISION: S0, RGBADepthPacking: F5, RGBAFormat: Si, RGBAIntegerFormat: b5, RGBA_ASTC_10x10_Format: o2, RGBA_ASTC_10x5_Format: i2, RGBA_ASTC_10x6_Format: r2, RGBA_ASTC_10x8_Format: s2, RGBA_ASTC_12x10_Format: a2, RGBA_ASTC_12x12_Format: l2, RGBA_ASTC_4x4_Format: Kv, RGBA_ASTC_5x4_Format: Yv, RGBA_ASTC_5x5_Format: qv, RGBA_ASTC_6x5_Format: Zv, RGBA_ASTC_6x6_Format: $v, RGBA_ASTC_8x5_Format: e2, RGBA_ASTC_8x6_Format: t2, RGBA_ASTC_8x8_Format: n2, RGBA_BPTC_Format: cm, RGBA_ETC2_EAC_Format: Qv, RGBA_PVRTC_2BPPV1_Format: Jv, RGBA_PVRTC_4BPPV1_Format: jv, RGBA_S3TC_DXT1_Format: om, RGBA_S3TC_DXT3_Format: am, RGBA_S3TC_DXT5_Format: lm, RGB_ETC1_Format: T5, RGB_ETC2_Format: Xv, RGB_PVRTC_2BPPV1_Format: Wv, RGB_PVRTC_4BPPV1_Format: Vv, RGB_S3TC_DXT1_Format: sm, RGFormat: C5, RGIntegerFormat: E5, RawShaderMaterial: pT, Ray: mh, Raycaster: DT, RectAreaLight: bT, RedFormat: w5, RedIntegerFormat: S5, ReinhardToneMapping: h5, RepeatWrapping: Wo, ReplaceStencilOp: VR, ReverseSubtractEquation: Jb, RingBufferGeometry: PO, RingGeometry: bh, SIGNED_RED_GREEN_RGTC2_Format: f2, SIGNED_RED_RGTC1_Format: c2, SRGBColorSpace: Br, Scene: fA, ShaderChunk: dt, ShaderLib: Rr, ShaderMaterial: cs, ShadowMaterial: dT, Shape: Ya, ShapeBufferGeometry: RO, ShapeGeometry: Th, ShapePath: dO, ShapeUtils: rs, ShortType: g5, Skeleton: xh, SkeletonHelper: eO, SkinnedMesh: dA, Source: Ua, Sphere: $o, SphereBufferGeometry: LO, SphereGeometry: Zc, Spherical: M2, SphericalHarmonics3: TT, SplineCurve: MA, SpotLight: BA, SpotLightHelper: $N, Sprite: eT, SpriteMaterial: hA, SrcAlphaFactor: Xx, SrcAlphaSaturateFactor: t5, SrcColorFactor: Kb, StaticCopyUsage: oL, StaticDrawUsage: Jf, StaticReadUsage: iL, StereoCamera: bN, StreamCopyUsage: lL, StreamDrawUsage: nL, StreamReadUsage: sL, StringKeyframeTrack: fl, SubtractEquation: jb, SubtractiveBlending: zv, TOUCH: Ea, TangentSpaceNormalMap: Ks, TetrahedronBufferGeometry: IO, TetrahedronGeometry: Bh, Texture: Zt, TextureLoader: Ih, TorusBufferGeometry: DO, TorusGeometry: Ph, TorusKnotBufferGeometry: FO, TorusKnotGeometry: Rh, Triangle: fr, TriangleFanDrawMode: Zx, TriangleStripDrawMode: I5, TrianglesDrawMode: UR, TubeBufferGeometry: kO, TubeGeometry: Lh, TwoPassDoubleSide: FR, UVMapping: E0, Uint16BufferAttribute: rA, Uint32BufferAttribute: sA, Uint8BufferAttribute: VL, Uint8ClampedBufferAttribute: WL, Uniform: kA, UniformsGroup: XN, UniformsLib: De, UniformsUtils: V5, UnsignedByteType: js, UnsignedInt248Type: Ja, UnsignedIntType: Co, UnsignedShort4444Type: v5, UnsignedShort5551Type: x5, UnsignedShortType: Yx, VSMShadowMap: Na, Vector2: me, Vector3: D, Vector4: Ft, VectorKeyframeTrack: zc, VideoTexture: Lk, WebGL1Renderer: Z5, WebGL3DRenderTarget: LL, WebGLArrayRenderTarget: RL, WebGLCubeRenderTarget: aA, WebGLMultipleRenderTargets: IL, WebGLRenderTarget: Or, WebGLRenderer: L0, WebGLUtils: K5, WireframeGeometry: hT, WrapAroundEnding: jf, ZeroCurvatureEnding: Oa, ZeroFactor: Xb, ZeroSlopeEnding: za, ZeroStencilOp: HR, _SRGBAFormat: Vm, sRGBEncoding: St }, Symbol.toStringTag, { value: "Module" })); var bo = {}, OO = { get exports() { return bo }, set exports(n) { bo = n } }, hl = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */hl.ConcurrentRoot = 1; hl.ContinuousEventPriority = 4; hl.DefaultEventPriority = 16; hl.DiscreteEventPriority = 1; hl.IdleEventPriority = 536870912; hl.LegacyRoot = 0; (function (n) { n.exports = hl })(OO); function zO(n) { let e; const t = new Set, i = (u, h) => { const d = typeof u == "function" ? u(e) : u; if (d !== e) { const p = e; e = h ? d : Object.assign({}, e, d), t.forEach(m => m(e, p)) } }, r = () => e, s = (u, h = r, d = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let p = h(e); function m() { const v = h(e); if (!d(p, v)) { const y = p; u(p = v, y) } } return t.add(m), () => t.delete(m) }, l = { setState: i, getState: r, subscribe: (u, h, d) => h || d ? s(u, h, d) : (t.add(u), () => t.delete(u)), destroy: () => t.clear() }; return e = n(i, r, l), l } const UO = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), NS = UO ? U.useEffect : U.useLayoutEffect; function kT(n) { const e = typeof n == "function" ? zO(n) : n, t = (i = e.getState, r = Object.is) => { const [, s] = U.useReducer(x => x + 1, 0), o = e.getState(), a = U.useRef(o), l = U.useRef(i), u = U.useRef(r), h = U.useRef(!1), d = U.useRef(); d.current === void 0 && (d.current = i(o)); let p, m = !1; (a.current !== o || l.current !== i || u.current !== r || h.current) && (p = i(o), m = !r(d.current, p)), NS(() => { m && (d.current = p), a.current = o, l.current = i, u.current = r, h.current = !1 }); const v = U.useRef(o); NS(() => { const x = () => { try { const _ = e.getState(), M = l.current(_); u.current(d.current, M) || (a.current = _, d.current = M, s()) } catch { h.current = !0, s() } }, A = e.subscribe(x); return e.getState() !== v.current && x(), A }, []); const y = m ? p : d.current; return U.useDebugValue(y), y }; return Object.assign(t, e), t[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const i = [t, e]; return { next() { const r = i.length <= 0; return { value: i.shift(), done: r } } } }, t } var _2 = {}, GO = { get exports() { return _2 }, set exports(n) { _2 = n } }, eh = {}, HO = { get exports() { return eh }, set exports(n) { eh = n } }, NT = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(N, H) { var W = N.length; N.push(H); e: for (; 0 < W;) { var se = W - 1 >>> 1, j = N[se]; if (0 < r(j, H)) N[se] = H, N[W] = j, W = se; else break e } } function t(N) { return N.length === 0 ? null : N[0] } function i(N) { if (N.length === 0) return null; var H = N[0], W = N.pop(); if (W !== H) { N[0] = W; e: for (var se = 0, j = N.length, oe = j >>> 1; se < oe;) { var ve = 2 * (se + 1) - 1, q = N[ve], Te = ve + 1, Se = N[Te]; if (0 > r(q, W)) Te < j && 0 > r(Se, q) ? (N[se] = Se, N[Te] = W, se = Te) : (N[se] = q, N[ve] = W, se = ve); else if (Te < j && 0 > r(Se, W)) N[se] = Se, N[Te] = W, se = Te; else break e } } return H } function r(N, H) { var W = N.sortIndex - H.sortIndex; return W !== 0 ? W : N.id - H.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); n.unstable_now = function () { return o.now() - a } } var l = [], u = [], h = 1, d = null, p = 3, m = !1, v = !1, y = !1, x = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function M(N) { for (var H = t(u); H !== null;) { if (H.callback === null) i(u); else if (H.startTime <= N) i(u), H.sortIndex = H.expirationTime, e(l, H); else break; H = t(u) } } function S(N) { if (y = !1, M(N), !v) if (t(l) !== null) v = !0, ee(b); else { var H = t(u); H !== null && le(S, H.startTime - N) } } function b(N, H) { v = !1, y && (y = !1, A(E), E = -1), m = !0; var W = p; try { for (M(H), d = t(l); d !== null && (!(d.expirationTime > H) || N && !z());) { var se = d.callback; if (typeof se == "function") { d.callback = null, p = d.priorityLevel; var j = se(d.expirationTime <= H); H = n.unstable_now(), typeof j == "function" ? d.callback = j : d === t(l) && i(l), M(H) } else i(l); d = t(l) } if (d !== null) var oe = !0; else { var ve = t(u); ve !== null && le(S, ve.startTime - H), oe = !1 } return oe } finally { d = null, p = W, m = !1 } } var B = !1, R = null, E = -1, P = 5, L = -1; function z() { return !(n.unstable_now() - L < P) } function Z() { if (R !== null) { var N = n.unstable_now(); L = N; var H = !0; try { H = R(!0, N) } finally { H ? J() : (B = !1, R = null) } } else B = !1 } var J; if (typeof _ == "function") J = function () { _(Z) }; else if (typeof MessageChannel < "u") { var V = new MessageChannel, K = V.port2; V.port1.onmessage = Z, J = function () { K.postMessage(null) } } else J = function () { x(Z, 0) }; function ee(N) { R = N, B || (B = !0, J()) } function le(N, H) { E = x(function () { N(n.unstable_now()) }, H) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (N) { N.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, ee(b)) }, n.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < N ? Math.floor(1e3 / N) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (N) { switch (p) { case 1: case 2: case 3: var H = 3; break; default: H = p }var W = p; p = H; try { return N() } finally { p = W } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (N, H) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var W = p; p = N; try { return H() } finally { p = W } }, n.unstable_scheduleCallback = function (N, H, W) { var se = n.unstable_now(); switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? se + W : se) : W = se, N) { case 1: var j = -1; break; case 2: j = 250; break; case 5: j = 1073741823; break; case 4: j = 1e4; break; default: j = 5e3 }return j = W + j, N = { id: h++, callback: H, priorityLevel: N, startTime: W, expirationTime: j, sortIndex: -1 }, W > se ? (N.sortIndex = W, e(u, N), t(l) === null && N === t(u) && (y ? (A(E), E = -1) : y = !0, le(S, W - se))) : (N.sortIndex = j, e(l, N), v || m || (v = !0, ee(b))), N }, n.unstable_shouldYield = z, n.unstable_wrapCallback = function (N) { var H = p; return function () { var W = p; p = H; try { return N.apply(this, arguments) } finally { p = W } } } })(NT); (function (n) { n.exports = NT })(HO);/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var VO = function (e) {
  var t = {}, i = U, r = eh, s = Object.assign; function o(c) { for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, g = 1; g < arguments.length; g++)f += "&args[]=" + encodeURIComponent(arguments[g]); return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), u = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), v = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), _ = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), b = Symbol.iterator; function B(c) { return c === null || typeof c != "object" ? null : (c = b && c[b] || c["@@iterator"], typeof c == "function" ? c : null) } function R(c) { if (c == null) return null; if (typeof c == "function") return c.displayName || c.name || null; if (typeof c == "string") return c; switch (c) { case h: return "Fragment"; case u: return "Portal"; case p: return "Profiler"; case d: return "StrictMode"; case x: return "Suspense"; case A: return "SuspenseList" }if (typeof c == "object") switch (c.$$typeof) { case v: return (c.displayName || "Context") + ".Consumer"; case m: return (c._context.displayName || "Context") + ".Provider"; case y: var f = c.render; return c = c.displayName, c || (c = f.displayName || f.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c; case _: return f = c.displayName || null, f !== null ? f : R(c.type) || "Memo"; case M: f = c._payload, c = c._init; try { return R(c(f)) } catch { } }return null } function E(c) { var f = c.type; switch (c.tag) { case 24: return "Cache"; case 9: return (f.displayName || "Context") + ".Consumer"; case 10: return (f._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return c = f.render, c = c.displayName || c.name || "", f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return f; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return R(f); case 8: return f === d ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof f == "function") return f.displayName || f.name || null; if (typeof f == "string") return f }return null } function P(c) { var f = c, g = c; if (c.alternate) for (; f.return;)f = f.return; else { c = f; do f = c, f.flags & 4098 && (g = f.return), c = f.return; while (c) } return f.tag === 3 ? g : null } function L(c) { if (P(c) !== c) throw Error(o(188)) } function z(c) { var f = c.alternate; if (!f) { if (f = P(c), f === null) throw Error(o(188)); return f !== c ? null : c } for (var g = c, w = f; ;) { var C = g.return; if (C === null) break; var T = C.alternate; if (T === null) { if (w = C.return, w !== null) { g = w; continue } break } if (C.child === T.child) { for (T = C.child; T;) { if (T === g) return L(C), c; if (T === w) return L(C), f; T = T.sibling } throw Error(o(188)) } if (g.return !== w.return) g = C, w = T; else { for (var k = !1, Q = C.child; Q;) { if (Q === g) { k = !0, g = C, w = T; break } if (Q === w) { k = !0, w = C, g = T; break } Q = Q.sibling } if (!k) { for (Q = T.child; Q;) { if (Q === g) { k = !0, g = T, w = C; break } if (Q === w) { k = !0, w = T, g = C; break } Q = Q.sibling } if (!k) throw Error(o(189)) } } if (g.alternate !== w) throw Error(o(190)) } if (g.tag !== 3) throw Error(o(188)); return g.stateNode.current === g ? c : f } function Z(c) { return c = z(c), c !== null ? J(c) : null } function J(c) { if (c.tag === 5 || c.tag === 6) return c; for (c = c.child; c !== null;) { var f = J(c); if (f !== null) return f; c = c.sibling } return null } function V(c) { if (c.tag === 5 || c.tag === 6) return c; for (c = c.child; c !== null;) { if (c.tag !== 4) { var f = V(c); if (f !== null) return f } c = c.sibling } return null } var K = Array.isArray, ee = e.getPublicInstance, le = e.getRootHostContext, N = e.getChildHostContext, H = e.prepareForCommit, W = e.resetAfterCommit, se = e.createInstance, j = e.appendInitialChild, oe = e.finalizeInitialChildren, ve = e.prepareUpdate, q = e.shouldSetTextContent, Te = e.createTextInstance, Se = e.scheduleTimeout, Fe = e.cancelTimeout, ze = e.noTimeout, Le = e.isPrimaryRenderer, be = e.supportsMutation, de = e.supportsPersistence, pe = e.supportsHydration, _e = e.getInstanceFromNode, Ve = e.preparePortalMount, Ie = e.getCurrentEventPriority, Qe = e.detachDeletedInstance, Xe = e.supportsMicrotasks, Ze = e.scheduleMicrotask, gt = e.supportsTestSelectors, wt = e.findFiberRoot, O = e.getBoundingRect, I = e.getTextContent, ie = e.isHiddenSubtree, we = e.matchAccessibilityRole, Ce = e.setFocusIfFocusable, Pe = e.setupIntersectionObserver, Ye = e.appendChild, Oe = e.appendChildToContainer, ye = e.commitTextUpdate, $e = e.commitMount, G = e.commitUpdate, he = e.insertBefore, Ae = e.insertInContainerBefore, Be = e.removeChild, tt = e.removeChildFromContainer, vt = e.resetTextContent, Ht = e.hideInstance, X = e.hideTextInstance, ae = e.unhideInstance, xe = e.unhideTextInstance, Ue = e.clearContainer, Je = e.cloneInstance, Nt = e.createContainerChildSet, mn = e.appendChildToContainerChildSet, zn = e.finalizeContainerChildren, Ri = e.replaceContainerChildren, Jt = e.cloneHiddenInstance, ai = e.cloneHiddenTextInstance, Yi = e.canHydrateInstance, tg = e.canHydrateTextInstance, ng = e.canHydrateSuspenseInstance, Uh = e.isSuspenseInstancePending, F = e.isSuspenseInstanceFallback, ne = e.registerSuspenseInstanceRetry, fe = e.getNextHydratableSibling, $ = e.getFirstHydratableChild, ge = e.getFirstHydratableChildWithinContainer, et = e.getFirstHydratableChildWithinSuspenseInstance, ot = e.hydrateInstance, ft = e.hydrateTextInstance, pt = e.hydrateSuspenseInstance, Ct = e.getNextHydratableInstanceAfterSuspenseInstance, xt = e.commitHydratedContainer, Mt = e.commitHydratedSuspenseInstance, an = e.clearSuspenseBoundary, li = e.clearSuspenseBoundaryFromContainer, vr = e.shouldDeleteUnhydratedTailInstances, fs = e.didNotMatchHydratedContainerTextInstance, ln = e.didNotMatchHydratedTextInstance, yt; function hs(c) {
    if (yt === void 0) try { throw Error() } catch (g) { var f = g.stack.trim().match(/\n( *(at )?)/); yt = f && f[1] || "" } return `
`+ yt + c
  } var cn = !1; function xr(c, f) {
    if (!c || cn) return ""; cn = !0; var g = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (f) if (f = function () { throw Error() }, Object.defineProperty(f.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(f, []) } catch (Ee) { var w = Ee } Reflect.construct(c, [], f) } else { try { f.call() } catch (Ee) { w = Ee } c.call(f.prototype) } else { try { throw Error() } catch (Ee) { w = Ee } c() } } catch (Ee) {
      if (Ee && w && typeof Ee.stack == "string") {
        for (var C = Ee.stack.split(`
`), T = w.stack.split(`
`), k = C.length - 1, Q = T.length - 1; 1 <= k && 0 <= Q && C[k] !== T[Q];)Q--; for (; 1 <= k && 0 <= Q; k--, Q--)if (C[k] !== T[Q]) {
          if (k !== 1 || Q !== 1) do if (k--, Q--, 0 > Q || C[k] !== T[Q]) {
            var ce = `
`+ C[k].replace(" at new ", " at "); return c.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", c.displayName)), ce
          } while (1 <= k && 0 <= Q); break
        }
      }
    } finally { cn = !1, Error.prepareStackTrace = g } return (c = c ? c.displayName || c.name : "") ? hs(c) : ""
  } var Gh = Object.prototype.hasOwnProperty, ds = [], Hr = -1; function Xt(c) { return { current: c } } function Tt(c) { 0 > Hr || (c.current = ds[Hr], ds[Hr] = null, Hr--) } function Dt(c, f) { Hr++, ds[Hr] = c.current, c.current = f } var un = {}, An = Xt(un), Xn = Xt(!1), Vr = un; function ml(c, f) { var g = c.type.contextTypes; if (!g) return un; var w = c.stateNode; if (w && w.__reactInternalMemoizedUnmaskedChildContext === f) return w.__reactInternalMemoizedMaskedChildContext; var C = {}, T; for (T in g) C[T] = f[T]; return w && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = f, c.__reactInternalMemoizedMaskedChildContext = C), C } function xi(c) { return c = c.childContextTypes, c != null } function Hh() { Tt(Xn), Tt(An) } function x3(c, f, g) { if (An.current !== un) throw Error(o(168)); Dt(An, f), Dt(Xn, g) } function A3(c, f, g) { var w = c.stateNode; if (f = f.childContextTypes, typeof w.getChildContext != "function") return g; w = w.getChildContext(); for (var C in w) if (!(C in f)) throw Error(o(108, E(c) || "Unknown", C)); return s({}, g, w) } function Vh(c) { return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || un, Vr = An.current, Dt(An, c), Dt(Xn, Xn.current), !0 } function M3(c, f, g) { var w = c.stateNode; if (!w) throw Error(o(169)); g ? (c = A3(c, f, Vr), w.__reactInternalMemoizedMergedChildContext = c, Tt(Xn), Tt(An), Dt(An, c)) : Tt(Xn), Dt(Xn, g) } var Ar = Math.clz32 ? Math.clz32 : z8, N8 = Math.log, O8 = Math.LN2; function z8(c) { return c >>>= 0, c === 0 ? 32 : 31 - (N8(c) / O8 | 0) | 0 } var Wh = 64, jh = 4194304; function iu(c) { switch (c & -c) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return c & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return c & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return c } } function Jh(c, f) { var g = c.pendingLanes; if (g === 0) return 0; var w = 0, C = c.suspendedLanes, T = c.pingedLanes, k = g & 268435455; if (k !== 0) { var Q = k & ~C; Q !== 0 ? w = iu(Q) : (T &= k, T !== 0 && (w = iu(T))) } else k = g & ~C, k !== 0 ? w = iu(k) : T !== 0 && (w = iu(T)); if (w === 0) return 0; if (f !== 0 && f !== w && !(f & C) && (C = w & -w, T = f & -f, C >= T || C === 16 && (T & 4194240) !== 0)) return f; if (w & 4 && (w |= g & 16), f = c.entangledLanes, f !== 0) for (c = c.entanglements, f &= w; 0 < f;)g = 31 - Ar(f), C = 1 << g, w |= c[g], f &= ~C; return w } function U8(c, f) { switch (c) { case 1: case 2: case 4: return f + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return f + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function G8(c, f) { for (var g = c.suspendedLanes, w = c.pingedLanes, C = c.expirationTimes, T = c.pendingLanes; 0 < T;) { var k = 31 - Ar(T), Q = 1 << k, ce = C[k]; ce === -1 ? (!(Q & g) || Q & w) && (C[k] = U8(Q, f)) : ce <= f && (c.expiredLanes |= Q), T &= ~Q } } function ig(c) { return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0 } function rg(c) { for (var f = [], g = 0; 31 > g; g++)f.push(c); return f } function ru(c, f, g) { c.pendingLanes |= f, f !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, f = 31 - Ar(f), c[f] = g } function H8(c, f) { var g = c.pendingLanes & ~f; c.pendingLanes = f, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= f, c.mutableReadLanes &= f, c.entangledLanes &= f, f = c.entanglements; var w = c.eventTimes; for (c = c.expirationTimes; 0 < g;) { var C = 31 - Ar(g), T = 1 << C; f[C] = 0, w[C] = -1, c[C] = -1, g &= ~T } } function sg(c, f) { var g = c.entangledLanes |= f; for (c = c.entanglements; g;) { var w = 31 - Ar(g), C = 1 << w; C & f | c[w] & f && (c[w] |= f), g &= ~C } } var Pt = 0; function _3(c) { return c &= -c, 1 < c ? 4 < c ? c & 268435455 ? 16 : 536870912 : 4 : 1 } var og = r.unstable_scheduleCallback, w3 = r.unstable_cancelCallback, V8 = r.unstable_shouldYield, W8 = r.unstable_requestPaint, In = r.unstable_now, ag = r.unstable_ImmediatePriority, j8 = r.unstable_UserBlockingPriority, lg = r.unstable_NormalPriority, J8 = r.unstable_IdlePriority, Xh = null, Wr = null; function X8(c) { if (Wr && typeof Wr.onCommitFiberRoot == "function") try { Wr.onCommitFiberRoot(Xh, c, void 0, (c.current.flags & 128) === 128) } catch { } } function Q8(c, f) { return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f } var jr = typeof Object.is == "function" ? Object.is : Q8, ps = null, Qh = !1, cg = !1; function S3(c) { ps === null ? ps = [c] : ps.push(c) } function K8(c) { Qh = !0, S3(c) } function Jr() { if (!cg && ps !== null) { cg = !0; var c = 0, f = Pt; try { var g = ps; for (Pt = 1; c < g.length; c++) { var w = g[c]; do w = w(!0); while (w !== null) } ps = null, Qh = !1 } catch (C) { throw ps !== null && (ps = ps.slice(c + 1)), og(ag, Jr), C } finally { Pt = f, cg = !1 } } return null } var Y8 = a.ReactCurrentBatchConfig; function Kh(c, f) { if (jr(c, f)) return !0; if (typeof c != "object" || c === null || typeof f != "object" || f === null) return !1; var g = Object.keys(c), w = Object.keys(f); if (g.length !== w.length) return !1; for (w = 0; w < g.length; w++) { var C = g[w]; if (!Gh.call(f, C) || !jr(c[C], f[C])) return !1 } return !0 } function q8(c) { switch (c.tag) { case 5: return hs(c.type); case 16: return hs("Lazy"); case 13: return hs("Suspense"); case 19: return hs("SuspenseList"); case 0: case 2: case 15: return c = xr(c.type, !1), c; case 11: return c = xr(c.type.render, !1), c; case 1: return c = xr(c.type, !0), c; default: return "" } } function Mr(c, f) { if (c && c.defaultProps) { f = s({}, f), c = c.defaultProps; for (var g in c) f[g] === void 0 && (f[g] = c[g]); return f } return f } var Yh = Xt(null), qh = null, gl = null, ug = null; function fg() { ug = gl = qh = null } function C3(c, f, g) { Le ? (Dt(Yh, f._currentValue), f._currentValue = g) : (Dt(Yh, f._currentValue2), f._currentValue2 = g) } function hg(c) { var f = Yh.current; Tt(Yh), Le ? c._currentValue = f : c._currentValue2 = f } function dg(c, f, g) { for (; c !== null;) { var w = c.alternate; if ((c.childLanes & f) !== f ? (c.childLanes |= f, w !== null && (w.childLanes |= f)) : w !== null && (w.childLanes & f) !== f && (w.childLanes |= f), c === g) break; c = c.return } } function yl(c, f) { qh = c, ug = gl = null, c = c.dependencies, c !== null && c.firstContext !== null && (c.lanes & f && (Di = !0), c.firstContext = null) } function qi(c) { var f = Le ? c._currentValue : c._currentValue2; if (ug !== c) if (c = { context: c, memoizedValue: f, next: null }, gl === null) { if (qh === null) throw Error(o(308)); gl = c, qh.dependencies = { lanes: 0, firstContext: c } } else gl = gl.next = c; return f } var Xr = null, Zs = !1; function pg(c) { c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function E3(c, f) { c = c.updateQueue, f.updateQueue === c && (f.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects }) } function ms(c, f) { return { eventTime: c, lane: f, tag: 0, payload: null, callback: null, next: null } } function $s(c, f) { var g = c.updateQueue; g !== null && (g = g.shared, Mn !== null && c.mode & 1 && !(mt & 2) ? (c = g.interleaved, c === null ? (f.next = f, Xr === null ? Xr = [g] : Xr.push(g)) : (f.next = c.next, c.next = f), g.interleaved = f) : (c = g.pending, c === null ? f.next = f : (f.next = c.next, c.next = f), g.pending = f)) } function Zh(c, f, g) { if (f = f.updateQueue, f !== null && (f = f.shared, (g & 4194240) !== 0)) { var w = f.lanes; w &= c.pendingLanes, g |= w, f.lanes = g, sg(c, g) } } function b3(c, f) { var g = c.updateQueue, w = c.alternate; if (w !== null && (w = w.updateQueue, g === w)) { var C = null, T = null; if (g = g.firstBaseUpdate, g !== null) { do { var k = { eventTime: g.eventTime, lane: g.lane, tag: g.tag, payload: g.payload, callback: g.callback, next: null }; T === null ? C = T = k : T = T.next = k, g = g.next } while (g !== null); T === null ? C = T = f : T = T.next = f } else C = T = f; g = { baseState: w.baseState, firstBaseUpdate: C, lastBaseUpdate: T, shared: w.shared, effects: w.effects }, c.updateQueue = g; return } c = g.lastBaseUpdate, c === null ? g.firstBaseUpdate = f : c.next = f, g.lastBaseUpdate = f } function $h(c, f, g, w) { var C = c.updateQueue; Zs = !1; var T = C.firstBaseUpdate, k = C.lastBaseUpdate, Q = C.shared.pending; if (Q !== null) { C.shared.pending = null; var ce = Q, Ee = ce.next; ce.next = null, k === null ? T = Ee : k.next = Ee, k = ce; var We = c.alternate; We !== null && (We = We.updateQueue, Q = We.lastBaseUpdate, Q !== k && (Q === null ? We.firstBaseUpdate = Ee : Q.next = Ee, We.lastBaseUpdate = ce)) } if (T !== null) { var at = C.baseState; k = 0, We = Ee = ce = null, Q = T; do { var nt = Q.lane, Ot = Q.eventTime; if ((w & nt) === nt) { We !== null && (We = We.next = { eventTime: Ot, lane: 0, tag: Q.tag, payload: Q.payload, callback: Q.callback, next: null }); e: { var qe = c, qn = Q; switch (nt = f, Ot = g, qn.tag) { case 1: if (qe = qn.payload, typeof qe == "function") { at = qe.call(Ot, at, nt); break e } at = qe; break e; case 3: qe.flags = qe.flags & -65537 | 128; case 0: if (qe = qn.payload, nt = typeof qe == "function" ? qe.call(Ot, at, nt) : qe, nt == null) break e; at = s({}, at, nt); break e; case 2: Zs = !0 } } Q.callback !== null && Q.lane !== 0 && (c.flags |= 64, nt = C.effects, nt === null ? C.effects = [Q] : nt.push(Q)) } else Ot = { eventTime: Ot, lane: nt, tag: Q.tag, payload: Q.payload, callback: Q.callback, next: null }, We === null ? (Ee = We = Ot, ce = at) : We = We.next = Ot, k |= nt; if (Q = Q.next, Q === null) { if (Q = C.shared.pending, Q === null) break; nt = Q, Q = nt.next, nt.next = null, C.lastBaseUpdate = nt, C.shared.pending = null } } while (1); if (We === null && (ce = at), C.baseState = ce, C.firstBaseUpdate = Ee, C.lastBaseUpdate = We, f = C.shared.interleaved, f !== null) { C = f; do k |= C.lane, C = C.next; while (C !== f) } else T === null && (C.shared.lanes = 0); El |= k, c.lanes = k, c.memoizedState = at } } function T3(c, f, g) { if (c = f.effects, f.effects = null, c !== null) for (f = 0; f < c.length; f++) { var w = c[f], C = w.callback; if (C !== null) { if (w.callback = null, w = g, typeof C != "function") throw Error(o(191, C)); C.call(w) } } } var B3 = new i.Component().refs; function mg(c, f, g, w) { f = c.memoizedState, g = g(w, f), g = g == null ? f : s({}, f, g), c.memoizedState = g, c.lanes === 0 && (c.updateQueue.baseState = g) } var ed = { isMounted: function (c) { return (c = c._reactInternals) ? P(c) === c : !1 }, enqueueSetState: function (c, f, g) { c = c._reactInternals; var w = ui(), C = no(c), T = ms(w, C); T.payload = f, g != null && (T.callback = g), $s(c, T), f = nr(c, C, w), f !== null && Zh(f, c, C) }, enqueueReplaceState: function (c, f, g) { c = c._reactInternals; var w = ui(), C = no(c), T = ms(w, C); T.tag = 1, T.payload = f, g != null && (T.callback = g), $s(c, T), f = nr(c, C, w), f !== null && Zh(f, c, C) }, enqueueForceUpdate: function (c, f) { c = c._reactInternals; var g = ui(), w = no(c), C = ms(g, w); C.tag = 2, f != null && (C.callback = f), $s(c, C), f = nr(c, w, g), f !== null && Zh(f, c, w) } }; function P3(c, f, g, w, C, T, k) { return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(w, T, k) : f.prototype && f.prototype.isPureReactComponent ? !Kh(g, w) || !Kh(C, T) : !0 } function R3(c, f, g) { var w = !1, C = un, T = f.contextType; return typeof T == "object" && T !== null ? T = qi(T) : (C = xi(f) ? Vr : An.current, w = f.contextTypes, T = (w = w != null) ? ml(c, C) : un), f = new f(g, T), c.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, f.updater = ed, c.stateNode = f, f._reactInternals = c, w && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = C, c.__reactInternalMemoizedMaskedChildContext = T), f } function L3(c, f, g, w) { c = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(g, w), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(g, w), f.state !== c && ed.enqueueReplaceState(f, f.state, null) } function gg(c, f, g, w) { var C = c.stateNode; C.props = g, C.state = c.memoizedState, C.refs = B3, pg(c); var T = f.contextType; typeof T == "object" && T !== null ? C.context = qi(T) : (T = xi(f) ? Vr : An.current, C.context = ml(c, T)), C.state = c.memoizedState, T = f.getDerivedStateFromProps, typeof T == "function" && (mg(c, f, T, g), C.state = c.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (f = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), f !== C.state && ed.enqueueReplaceState(C, C.state, null), $h(c, g, C, w), C.state = c.memoizedState), typeof C.componentDidMount == "function" && (c.flags |= 4194308) } var vl = [], xl = 0, td = null, nd = 0, Zi = [], $i = 0, ra = null, gs = 1, ys = ""; function sa(c, f) { vl[xl++] = nd, vl[xl++] = td, td = c, nd = f } function I3(c, f, g) { Zi[$i++] = gs, Zi[$i++] = ys, Zi[$i++] = ra, ra = c; var w = gs; c = ys; var C = 32 - Ar(w) - 1; w &= ~(1 << C), g += 1; var T = 32 - Ar(f) + C; if (30 < T) { var k = C - C % 5; T = (w & (1 << k) - 1).toString(32), w >>= k, C -= k, gs = 1 << 32 - Ar(f) + C | g << C | w, ys = T + c } else gs = 1 << T | g << C | w, ys = c } function yg(c) { c.return !== null && (sa(c, 1), I3(c, 1, 0)) } function vg(c) { for (; c === td;)td = vl[--xl], vl[xl] = null, nd = vl[--xl], vl[xl] = null; for (; c === ra;)ra = Zi[--$i], Zi[$i] = null, ys = Zi[--$i], Zi[$i] = null, gs = Zi[--$i], Zi[$i] = null } var Li = null, Ii = null, Qt = !1, su = !1, _r = null; function D3(c, f) { var g = ir(5, null, null, 0); g.elementType = "DELETED", g.stateNode = f, g.return = c, f = c.deletions, f === null ? (c.deletions = [g], c.flags |= 16) : f.push(g) } function F3(c, f) { switch (c.tag) { case 5: return f = Yi(f, c.type, c.pendingProps), f !== null ? (c.stateNode = f, Li = c, Ii = $(f), !0) : !1; case 6: return f = tg(f, c.pendingProps), f !== null ? (c.stateNode = f, Li = c, Ii = null, !0) : !1; case 13: if (f = ng(f), f !== null) { var g = ra !== null ? { id: gs, overflow: ys } : null; return c.memoizedState = { dehydrated: f, treeContext: g, retryLane: 1073741824 }, g = ir(18, null, null, 0), g.stateNode = f, g.return = c, c.child = g, Li = c, Ii = null, !0 } return !1; default: return !1 } } function xg(c) { return (c.mode & 1) !== 0 && (c.flags & 128) === 0 } function Ag(c) { if (Qt) { var f = Ii; if (f) { var g = f; if (!F3(c, f)) { if (xg(c)) throw Error(o(418)); f = fe(g); var w = Li; f && F3(c, f) ? D3(w, g) : (c.flags = c.flags & -4097 | 2, Qt = !1, Li = c) } } else { if (xg(c)) throw Error(o(418)); c.flags = c.flags & -4097 | 2, Qt = !1, Li = c } } } function k3(c) { for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;)c = c.return; Li = c } function ou(c) { if (!pe || c !== Li) return !1; if (!Qt) return k3(c), Qt = !0, !1; if (c.tag !== 3 && (c.tag !== 5 || vr(c.type) && !q(c.type, c.memoizedProps))) { var f = Ii; if (f) { if (xg(c)) { for (c = Ii; c;)c = fe(c); throw Error(o(418)) } for (; f;)D3(c, f), f = fe(f) } } if (k3(c), c.tag === 13) { if (!pe) throw Error(o(316)); if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317)); Ii = Ct(c) } else Ii = Li ? fe(c.stateNode) : null; return !0 } function Al() { pe && (Ii = Li = null, su = Qt = !1) } function Mg(c) { _r === null ? _r = [c] : _r.push(c) } function au(c, f, g) { if (c = g.ref, c !== null && typeof c != "function" && typeof c != "object") { if (g._owner) { if (g = g._owner, g) { if (g.tag !== 1) throw Error(o(309)); var w = g.stateNode } if (!w) throw Error(o(147, c)); var C = w, T = "" + c; return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === T ? f.ref : (f = function (k) { var Q = C.refs; Q === B3 && (Q = C.refs = {}), k === null ? delete Q[T] : Q[T] = k }, f._stringRef = T, f) } if (typeof c != "string") throw Error(o(284)); if (!g._owner) throw Error(o(290, c)) } return c } function id(c, f) { throw c = Object.prototype.toString.call(f), Error(o(31, c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c)) } function N3(c) { var f = c._init; return f(c._payload) } function O3(c) { function f(te, Y) { if (c) { var re = te.deletions; re === null ? (te.deletions = [Y], te.flags |= 16) : re.push(Y) } } function g(te, Y) { if (!c) return null; for (; Y !== null;)f(te, Y), Y = Y.sibling; return null } function w(te, Y) { for (te = new Map; Y !== null;)Y.key !== null ? te.set(Y.key, Y) : te.set(Y.index, Y), Y = Y.sibling; return te } function C(te, Y) { return te = ro(te, Y), te.index = 0, te.sibling = null, te } function T(te, Y, re) { return te.index = re, c ? (re = te.alternate, re !== null ? (re = re.index, re < Y ? (te.flags |= 2, Y) : re) : (te.flags |= 2, Y)) : (te.flags |= 1048576, Y) } function k(te) { return c && te.alternate === null && (te.flags |= 2), te } function Q(te, Y, re, Ne) { return Y === null || Y.tag !== 6 ? (Y = r1(re, te.mode, Ne), Y.return = te, Y) : (Y = C(Y, re), Y.return = te, Y) } function ce(te, Y, re, Ne) { var Ke = re.type; return Ke === h ? We(te, Y, re.props.children, Ne, re.key) : Y !== null && (Y.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === M && N3(Ke) === Y.type) ? (Ne = C(Y, re.props), Ne.ref = au(te, Y, re), Ne.return = te, Ne) : (Ne = Dd(re.type, re.key, re.props, null, te.mode, Ne), Ne.ref = au(te, Y, re), Ne.return = te, Ne) } function Ee(te, Y, re, Ne) { return Y === null || Y.tag !== 4 || Y.stateNode.containerInfo !== re.containerInfo || Y.stateNode.implementation !== re.implementation ? (Y = s1(re, te.mode, Ne), Y.return = te, Y) : (Y = C(Y, re.children || []), Y.return = te, Y) } function We(te, Y, re, Ne, Ke) { return Y === null || Y.tag !== 7 ? (Y = ha(re, te.mode, Ne, Ke), Y.return = te, Y) : (Y = C(Y, re), Y.return = te, Y) } function at(te, Y, re) { if (typeof Y == "string" && Y !== "" || typeof Y == "number") return Y = r1("" + Y, te.mode, re), Y.return = te, Y; if (typeof Y == "object" && Y !== null) { switch (Y.$$typeof) { case l: return re = Dd(Y.type, Y.key, Y.props, null, te.mode, re), re.ref = au(te, null, Y), re.return = te, re; case u: return Y = s1(Y, te.mode, re), Y.return = te, Y; case M: var Ne = Y._init; return at(te, Ne(Y._payload), re) }if (K(Y) || B(Y)) return Y = ha(Y, te.mode, re, null), Y.return = te, Y; id(te, Y) } return null } function nt(te, Y, re, Ne) { var Ke = Y !== null ? Y.key : null; if (typeof re == "string" && re !== "" || typeof re == "number") return Ke !== null ? null : Q(te, Y, "" + re, Ne); if (typeof re == "object" && re !== null) { switch (re.$$typeof) { case l: return re.key === Ke ? ce(te, Y, re, Ne) : null; case u: return re.key === Ke ? Ee(te, Y, re, Ne) : null; case M: return Ke = re._init, nt(te, Y, Ke(re._payload), Ne) }if (K(re) || B(re)) return Ke !== null ? null : We(te, Y, re, Ne, null); id(te, re) } return null } function Ot(te, Y, re, Ne, Ke) { if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number") return te = te.get(re) || null, Q(Y, te, "" + Ne, Ke); if (typeof Ne == "object" && Ne !== null) { switch (Ne.$$typeof) { case l: return te = te.get(Ne.key === null ? re : Ne.key) || null, ce(Y, te, Ne, Ke); case u: return te = te.get(Ne.key === null ? re : Ne.key) || null, Ee(Y, te, Ne, Ke); case M: var ht = Ne._init; return Ot(te, Y, re, ht(Ne._payload), Ke) }if (K(Ne) || B(Ne)) return te = te.get(re) || null, We(Y, te, Ne, Ke, null); id(Y, Ne) } return null } function qe(te, Y, re, Ne) { for (var Ke = null, ht = null, lt = Y, Rt = Y = 0, Fn = null; lt !== null && Rt < re.length; Rt++) { lt.index > Rt ? (Fn = lt, lt = null) : Fn = lt.sibling; var Lt = nt(te, lt, re[Rt], Ne); if (Lt === null) { lt === null && (lt = Fn); break } c && lt && Lt.alternate === null && f(te, lt), Y = T(Lt, Y, Rt), ht === null ? Ke = Lt : ht.sibling = Lt, ht = Lt, lt = Fn } if (Rt === re.length) return g(te, lt), Qt && sa(te, Rt), Ke; if (lt === null) { for (; Rt < re.length; Rt++)lt = at(te, re[Rt], Ne), lt !== null && (Y = T(lt, Y, Rt), ht === null ? Ke = lt : ht.sibling = lt, ht = lt); return Qt && sa(te, Rt), Ke } for (lt = w(te, lt); Rt < re.length; Rt++)Fn = Ot(lt, te, Rt, re[Rt], Ne), Fn !== null && (c && Fn.alternate !== null && lt.delete(Fn.key === null ? Rt : Fn.key), Y = T(Fn, Y, Rt), ht === null ? Ke = Fn : ht.sibling = Fn, ht = Fn); return c && lt.forEach(function (so) { return f(te, so) }), Qt && sa(te, Rt), Ke } function qn(te, Y, re, Ne) { var Ke = B(re); if (typeof Ke != "function") throw Error(o(150)); if (re = Ke.call(re), re == null) throw Error(o(151)); for (var ht = Ke = null, lt = Y, Rt = Y = 0, Fn = null, Lt = re.next(); lt !== null && !Lt.done; Rt++, Lt = re.next()) { lt.index > Rt ? (Fn = lt, lt = null) : Fn = lt.sibling; var so = nt(te, lt, Lt.value, Ne); if (so === null) { lt === null && (lt = Fn); break } c && lt && so.alternate === null && f(te, lt), Y = T(so, Y, Rt), ht === null ? Ke = so : ht.sibling = so, ht = so, lt = Fn } if (Lt.done) return g(te, lt), Qt && sa(te, Rt), Ke; if (lt === null) { for (; !Lt.done; Rt++, Lt = re.next())Lt = at(te, Lt.value, Ne), Lt !== null && (Y = T(Lt, Y, Rt), ht === null ? Ke = Lt : ht.sibling = Lt, ht = Lt); return Qt && sa(te, Rt), Ke } for (lt = w(te, lt); !Lt.done; Rt++, Lt = re.next())Lt = Ot(lt, te, Rt, Lt.value, Ne), Lt !== null && (c && Lt.alternate !== null && lt.delete(Lt.key === null ? Rt : Lt.key), Y = T(Lt, Y, Rt), ht === null ? Ke = Lt : ht.sibling = Lt, ht = Lt); return c && lt.forEach(function (bB) { return f(te, bB) }), Qt && sa(te, Rt), Ke } function rr(te, Y, re, Ne) { if (typeof re == "object" && re !== null && re.type === h && re.key === null && (re = re.props.children), typeof re == "object" && re !== null) { switch (re.$$typeof) { case l: e: { for (var Ke = re.key, ht = Y; ht !== null;) { if (ht.key === Ke) { if (Ke = re.type, Ke === h) { if (ht.tag === 7) { g(te, ht.sibling), Y = C(ht, re.props.children), Y.return = te, te = Y; break e } } else if (ht.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === M && N3(Ke) === ht.type) { g(te, ht.sibling), Y = C(ht, re.props), Y.ref = au(te, ht, re), Y.return = te, te = Y; break e } g(te, ht); break } else f(te, ht); ht = ht.sibling } re.type === h ? (Y = ha(re.props.children, te.mode, Ne, re.key), Y.return = te, te = Y) : (Ne = Dd(re.type, re.key, re.props, null, te.mode, Ne), Ne.ref = au(te, Y, re), Ne.return = te, te = Ne) } return k(te); case u: e: { for (ht = re.key; Y !== null;) { if (Y.key === ht) if (Y.tag === 4 && Y.stateNode.containerInfo === re.containerInfo && Y.stateNode.implementation === re.implementation) { g(te, Y.sibling), Y = C(Y, re.children || []), Y.return = te, te = Y; break e } else { g(te, Y); break } else f(te, Y); Y = Y.sibling } Y = s1(re, te.mode, Ne), Y.return = te, te = Y } return k(te); case M: return ht = re._init, rr(te, Y, ht(re._payload), Ne) }if (K(re)) return qe(te, Y, re, Ne); if (B(re)) return qn(te, Y, re, Ne); id(te, re) } return typeof re == "string" && re !== "" || typeof re == "number" ? (re = "" + re, Y !== null && Y.tag === 6 ? (g(te, Y.sibling), Y = C(Y, re), Y.return = te, te = Y) : (g(te, Y), Y = r1(re, te.mode, Ne), Y.return = te, te = Y), k(te)) : g(te, Y) } return rr } var Ml = O3(!0), z3 = O3(!1), lu = {}, er = Xt(lu), cu = Xt(lu), _l = Xt(lu); function Qr(c) { if (c === lu) throw Error(o(174)); return c } function _g(c, f) { Dt(_l, f), Dt(cu, c), Dt(er, lu), c = le(f), Tt(er), Dt(er, c) } function wl() { Tt(er), Tt(cu), Tt(_l) } function U3(c) { var f = Qr(_l.current), g = Qr(er.current); f = N(g, c.type, f), g !== f && (Dt(cu, c), Dt(er, f)) } function wg(c) { cu.current === c && (Tt(er), Tt(cu)) } var $t = Xt(0); function rd(c) { for (var f = c; f !== null;) { if (f.tag === 13) { var g = f.memoizedState; if (g !== null && (g = g.dehydrated, g === null || Uh(g) || F(g))) return f } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) { if (f.flags & 128) return f } else if (f.child !== null) { f.child.return = f, f = f.child; continue } if (f === c) break; for (; f.sibling === null;) { if (f.return === null || f.return === c) return null; f = f.return } f.sibling.return = f.return, f = f.sibling } return null } var Sg = []; function Cg() { for (var c = 0; c < Sg.length; c++) { var f = Sg[c]; Le ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null } Sg.length = 0 } var sd = a.ReactCurrentDispatcher, tr = a.ReactCurrentBatchConfig, Sl = 0, fn = null, Qn = null, Dn = null, od = !1, uu = !1, fu = 0, Z8 = 0; function Kn() { throw Error(o(321)) } function Eg(c, f) { if (f === null) return !1; for (var g = 0; g < f.length && g < c.length; g++)if (!jr(c[g], f[g])) return !1; return !0 } function bg(c, f, g, w, C, T) { if (Sl = T, fn = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, sd.current = c === null || c.memoizedState === null ? nB : iB, c = g(w, C), uu) { T = 0; do { if (uu = !1, fu = 0, 25 <= T) throw Error(o(301)); T += 1, Dn = Qn = null, f.updateQueue = null, sd.current = rB, c = g(w, C) } while (uu) } if (sd.current = fd, f = Qn !== null && Qn.next !== null, Sl = 0, Dn = Qn = fn = null, od = !1, f) throw Error(o(300)); return c } function Tg() { var c = fu !== 0; return fu = 0, c } function vs() { var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Dn === null ? fn.memoizedState = Dn = c : Dn = Dn.next = c, Dn } function Kr() { if (Qn === null) { var c = fn.alternate; c = c !== null ? c.memoizedState : null } else c = Qn.next; var f = Dn === null ? fn.memoizedState : Dn.next; if (f !== null) Dn = f, Qn = c; else { if (c === null) throw Error(o(310)); Qn = c, c = { memoizedState: Qn.memoizedState, baseState: Qn.baseState, baseQueue: Qn.baseQueue, queue: Qn.queue, next: null }, Dn === null ? fn.memoizedState = Dn = c : Dn = Dn.next = c } return Dn } function oa(c, f) { return typeof f == "function" ? f(c) : f } function ad(c) { var f = Kr(), g = f.queue; if (g === null) throw Error(o(311)); g.lastRenderedReducer = c; var w = Qn, C = w.baseQueue, T = g.pending; if (T !== null) { if (C !== null) { var k = C.next; C.next = T.next, T.next = k } w.baseQueue = C = T, g.pending = null } if (C !== null) { T = C.next, w = w.baseState; var Q = k = null, ce = null, Ee = T; do { var We = Ee.lane; if ((Sl & We) === We) ce !== null && (ce = ce.next = { lane: 0, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }), w = Ee.hasEagerState ? Ee.eagerState : c(w, Ee.action); else { var at = { lane: We, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }; ce === null ? (Q = ce = at, k = w) : ce = ce.next = at, fn.lanes |= We, El |= We } Ee = Ee.next } while (Ee !== null && Ee !== T); ce === null ? k = w : ce.next = Q, jr(w, f.memoizedState) || (Di = !0), f.memoizedState = w, f.baseState = k, f.baseQueue = ce, g.lastRenderedState = w } if (c = g.interleaved, c !== null) { C = c; do T = C.lane, fn.lanes |= T, El |= T, C = C.next; while (C !== c) } else C === null && (g.lanes = 0); return [f.memoizedState, g.dispatch] } function ld(c) { var f = Kr(), g = f.queue; if (g === null) throw Error(o(311)); g.lastRenderedReducer = c; var w = g.dispatch, C = g.pending, T = f.memoizedState; if (C !== null) { g.pending = null; var k = C = C.next; do T = c(T, k.action), k = k.next; while (k !== C); jr(T, f.memoizedState) || (Di = !0), f.memoizedState = T, f.baseQueue === null && (f.baseState = T), g.lastRenderedState = T } return [T, w] } function G3() { } function H3(c, f) { var g = fn, w = Kr(), C = f(), T = !jr(w.memoizedState, C); if (T && (w.memoizedState = C, Di = !0), w = w.queue, du(j3.bind(null, g, w, c), [c]), w.getSnapshot !== f || T || Dn !== null && Dn.memoizedState.tag & 1) { if (g.flags |= 2048, hu(9, W3.bind(null, g, w, C, f), void 0, null), Mn === null) throw Error(o(349)); Sl & 30 || V3(g, f, C) } return C } function V3(c, f, g) { c.flags |= 16384, c = { getSnapshot: f, value: g }, f = fn.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, fn.updateQueue = f, f.stores = [c]) : (g = f.stores, g === null ? f.stores = [c] : g.push(c)) } function W3(c, f, g, w) { f.value = g, f.getSnapshot = w, J3(f) && nr(c, 1, -1) } function j3(c, f, g) { return g(function () { J3(f) && nr(c, 1, -1) }) } function J3(c) { var f = c.getSnapshot; c = c.value; try { var g = f(); return !jr(c, g) } catch { return !0 } } function Bg(c) { var f = vs(); return typeof c == "function" && (c = c()), f.memoizedState = f.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: oa, lastRenderedState: c }, f.queue = c, c = c.dispatch = tB.bind(null, fn, c), [f.memoizedState, c] } function hu(c, f, g, w) { return c = { tag: c, create: f, destroy: g, deps: w, next: null }, f = fn.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, fn.updateQueue = f, f.lastEffect = c.next = c) : (g = f.lastEffect, g === null ? f.lastEffect = c.next = c : (w = g.next, g.next = c, c.next = w, f.lastEffect = c)), c } function X3() { return Kr().memoizedState } function cd(c, f, g, w) { var C = vs(); fn.flags |= c, C.memoizedState = hu(1 | f, g, void 0, w === void 0 ? null : w) } function ud(c, f, g, w) { var C = Kr(); w = w === void 0 ? null : w; var T = void 0; if (Qn !== null) { var k = Qn.memoizedState; if (T = k.destroy, w !== null && Eg(w, k.deps)) { C.memoizedState = hu(f, g, T, w); return } } fn.flags |= c, C.memoizedState = hu(1 | f, g, T, w) } function Pg(c, f) { return cd(8390656, 8, c, f) } function du(c, f) { return ud(2048, 8, c, f) } function Q3(c, f) { return ud(4, 2, c, f) } function K3(c, f) { return ud(4, 4, c, f) } function Y3(c, f) { if (typeof f == "function") return c = c(), f(c), function () { f(null) }; if (f != null) return c = c(), f.current = c, function () { f.current = null } } function q3(c, f, g) { return g = g != null ? g.concat([c]) : null, ud(4, 4, Y3.bind(null, f, c), g) } function Rg() { } function Z3(c, f) { var g = Kr(); f = f === void 0 ? null : f; var w = g.memoizedState; return w !== null && f !== null && Eg(f, w[1]) ? w[0] : (g.memoizedState = [c, f], c) } function $3(c, f) { var g = Kr(); f = f === void 0 ? null : f; var w = g.memoizedState; return w !== null && f !== null && Eg(f, w[1]) ? w[0] : (c = c(), g.memoizedState = [c, f], c) } function $8(c, f) { var g = Pt; Pt = g !== 0 && 4 > g ? g : 4, c(!0); var w = tr.transition; tr.transition = {}; try { c(!1), f() } finally { Pt = g, tr.transition = w } } function eM() { return Kr().memoizedState } function eB(c, f, g) { var w = no(c); g = { lane: w, action: g, hasEagerState: !1, eagerState: null, next: null }, tM(c) ? nM(f, g) : (iM(c, f, g), g = ui(), c = nr(c, w, g), c !== null && rM(c, f, w)) } function tB(c, f, g) { var w = no(c), C = { lane: w, action: g, hasEagerState: !1, eagerState: null, next: null }; if (tM(c)) nM(f, C); else { iM(c, f, C); var T = c.alternate; if (c.lanes === 0 && (T === null || T.lanes === 0) && (T = f.lastRenderedReducer, T !== null)) try { var k = f.lastRenderedState, Q = T(k, g); if (C.hasEagerState = !0, C.eagerState = Q, jr(Q, k)) return } catch { } finally { } g = ui(), c = nr(c, w, g), c !== null && rM(c, f, w) } } function tM(c) { var f = c.alternate; return c === fn || f !== null && f === fn } function nM(c, f) { uu = od = !0; var g = c.pending; g === null ? f.next = f : (f.next = g.next, g.next = f), c.pending = f } function iM(c, f, g) { Mn !== null && c.mode & 1 && !(mt & 2) ? (c = f.interleaved, c === null ? (g.next = g, Xr === null ? Xr = [f] : Xr.push(f)) : (g.next = c.next, c.next = g), f.interleaved = g) : (c = f.pending, c === null ? g.next = g : (g.next = c.next, c.next = g), f.pending = g) } function rM(c, f, g) { if (g & 4194240) { var w = f.lanes; w &= c.pendingLanes, g |= w, f.lanes = g, sg(c, g) } } var fd = { readContext: qi, useCallback: Kn, useContext: Kn, useEffect: Kn, useImperativeHandle: Kn, useInsertionEffect: Kn, useLayoutEffect: Kn, useMemo: Kn, useReducer: Kn, useRef: Kn, useState: Kn, useDebugValue: Kn, useDeferredValue: Kn, useTransition: Kn, useMutableSource: Kn, useSyncExternalStore: Kn, useId: Kn, unstable_isNewReconciler: !1 }, nB = { readContext: qi, useCallback: function (c, f) { return vs().memoizedState = [c, f === void 0 ? null : f], c }, useContext: qi, useEffect: Pg, useImperativeHandle: function (c, f, g) { return g = g != null ? g.concat([c]) : null, cd(4194308, 4, Y3.bind(null, f, c), g) }, useLayoutEffect: function (c, f) { return cd(4194308, 4, c, f) }, useInsertionEffect: function (c, f) { return cd(4, 2, c, f) }, useMemo: function (c, f) { var g = vs(); return f = f === void 0 ? null : f, c = c(), g.memoizedState = [c, f], c }, useReducer: function (c, f, g) { var w = vs(); return f = g !== void 0 ? g(f) : f, w.memoizedState = w.baseState = f, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: f }, w.queue = c, c = c.dispatch = eB.bind(null, fn, c), [w.memoizedState, c] }, useRef: function (c) { var f = vs(); return c = { current: c }, f.memoizedState = c }, useState: Bg, useDebugValue: Rg, useDeferredValue: function (c) { var f = Bg(c), g = f[0], w = f[1]; return Pg(function () { var C = tr.transition; tr.transition = {}; try { w(c) } finally { tr.transition = C } }, [c]), g }, useTransition: function () { var c = Bg(!1), f = c[0]; return c = $8.bind(null, c[1]), vs().memoizedState = c, [f, c] }, useMutableSource: function () { }, useSyncExternalStore: function (c, f, g) { var w = fn, C = vs(); if (Qt) { if (g === void 0) throw Error(o(407)); g = g() } else { if (g = f(), Mn === null) throw Error(o(349)); Sl & 30 || V3(w, f, g) } C.memoizedState = g; var T = { value: g, getSnapshot: f }; return C.queue = T, Pg(j3.bind(null, w, T, c), [c]), w.flags |= 2048, hu(9, W3.bind(null, w, T, g, f), void 0, null), g }, useId: function () { var c = vs(), f = Mn.identifierPrefix; if (Qt) { var g = ys, w = gs; g = (w & ~(1 << 32 - Ar(w) - 1)).toString(32) + g, f = ":" + f + "R" + g, g = fu++, 0 < g && (f += "H" + g.toString(32)), f += ":" } else g = Z8++, f = ":" + f + "r" + g.toString(32) + ":"; return c.memoizedState = f }, unstable_isNewReconciler: !1 }, iB = { readContext: qi, useCallback: Z3, useContext: qi, useEffect: du, useImperativeHandle: q3, useInsertionEffect: Q3, useLayoutEffect: K3, useMemo: $3, useReducer: ad, useRef: X3, useState: function () { return ad(oa) }, useDebugValue: Rg, useDeferredValue: function (c) { var f = ad(oa), g = f[0], w = f[1]; return du(function () { var C = tr.transition; tr.transition = {}; try { w(c) } finally { tr.transition = C } }, [c]), g }, useTransition: function () { var c = ad(oa)[0], f = Kr().memoizedState; return [c, f] }, useMutableSource: G3, useSyncExternalStore: H3, useId: eM, unstable_isNewReconciler: !1 }, rB = { readContext: qi, useCallback: Z3, useContext: qi, useEffect: du, useImperativeHandle: q3, useInsertionEffect: Q3, useLayoutEffect: K3, useMemo: $3, useReducer: ld, useRef: X3, useState: function () { return ld(oa) }, useDebugValue: Rg, useDeferredValue: function (c) { var f = ld(oa), g = f[0], w = f[1]; return du(function () { var C = tr.transition; tr.transition = {}; try { w(c) } finally { tr.transition = C } }, [c]), g }, useTransition: function () { var c = ld(oa)[0], f = Kr().memoizedState; return [c, f] }, useMutableSource: G3, useSyncExternalStore: H3, useId: eM, unstable_isNewReconciler: !1 }; function Lg(c, f) {
    try { var g = "", w = f; do g += q8(w), w = w.return; while (w); var C = g } catch (T) {
      C = `
Error generating stack: `+ T.message + `
`+ T.stack
    } return { value: c, source: f, stack: C }
  } function Ig(c, f) { try { console.error(f.value) } catch (g) { setTimeout(function () { throw g }) } } var sB = typeof WeakMap == "function" ? WeakMap : Map; function sM(c, f, g) { g = ms(-1, g), g.tag = 3, g.payload = { element: null }; var w = f.value; return g.callback = function () { bd || (bd = !0, qg = w), Ig(c, f) }, g } function oM(c, f, g) { g = ms(-1, g), g.tag = 3; var w = c.type.getDerivedStateFromError; if (typeof w == "function") { var C = f.value; g.payload = function () { return w(C) }, g.callback = function () { Ig(c, f) } } var T = c.stateNode; return T !== null && typeof T.componentDidCatch == "function" && (g.callback = function () { Ig(c, f), typeof w != "function" && (eo === null ? eo = new Set([this]) : eo.add(this)); var k = f.stack; this.componentDidCatch(f.value, { componentStack: k !== null ? k : "" }) }), g } function aM(c, f, g) { var w = c.pingCache; if (w === null) { w = c.pingCache = new sB; var C = new Set; w.set(f, C) } else C = w.get(f), C === void 0 && (C = new Set, w.set(f, C)); C.has(g) || (C.add(g), c = xB.bind(null, c, f, g), f.then(c, c)) } function lM(c) { do { var f; if ((f = c.tag === 13) && (f = c.memoizedState, f = f !== null ? f.dehydrated !== null : !0), f) return c; c = c.return } while (c !== null); return null } function cM(c, f, g, w, C) { return c.mode & 1 ? (c.flags |= 65536, c.lanes = C, c) : (c === f ? c.flags |= 65536 : (c.flags |= 128, g.flags |= 131072, g.flags &= -52805, g.tag === 1 && (g.alternate === null ? g.tag = 17 : (f = ms(-1, 1), f.tag = 2, $s(g, f))), g.lanes |= 1), c) } function Yr(c) { c.flags |= 4 } function uM(c, f) { if (c !== null && c.child === f.child) return !0; if (f.flags & 16) return !1; for (c = f.child; c !== null;) { if (c.flags & 12854 || c.subtreeFlags & 12854) return !1; c = c.sibling } return !0 } var pu, mu, hd, dd; if (be) pu = function (c, f) { for (var g = f.child; g !== null;) { if (g.tag === 5 || g.tag === 6) j(c, g.stateNode); else if (g.tag !== 4 && g.child !== null) { g.child.return = g, g = g.child; continue } if (g === f) break; for (; g.sibling === null;) { if (g.return === null || g.return === f) return; g = g.return } g.sibling.return = g.return, g = g.sibling } }, mu = function () { }, hd = function (c, f, g, w, C) { if (c = c.memoizedProps, c !== w) { var T = f.stateNode, k = Qr(er.current); g = ve(T, g, c, w, C, k), (f.updateQueue = g) && Yr(f) } }, dd = function (c, f, g, w) { g !== w && Yr(f) }; else if (de) { pu = function (c, f, g, w) { for (var C = f.child; C !== null;) { if (C.tag === 5) { var T = C.stateNode; g && w && (T = Jt(T, C.type, C.memoizedProps, C)), j(c, T) } else if (C.tag === 6) T = C.stateNode, g && w && (T = ai(T, C.memoizedProps, C)), j(c, T); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) T = C.child, T !== null && (T.return = C), pu(c, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === f) break; for (; C.sibling === null;) { if (C.return === null || C.return === f) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; var fM = function (c, f, g, w) { for (var C = f.child; C !== null;) { if (C.tag === 5) { var T = C.stateNode; g && w && (T = Jt(T, C.type, C.memoizedProps, C)), mn(c, T) } else if (C.tag === 6) T = C.stateNode, g && w && (T = ai(T, C.memoizedProps, C)), mn(c, T); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) T = C.child, T !== null && (T.return = C), fM(c, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === f) break; for (; C.sibling === null;) { if (C.return === null || C.return === f) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; mu = function (c, f) { var g = f.stateNode; if (!uM(c, f)) { c = g.containerInfo; var w = Nt(c); fM(w, f, !1, !1), g.pendingChildren = w, Yr(f), zn(c, w) } }, hd = function (c, f, g, w, C) { var T = c.stateNode, k = c.memoizedProps; if ((c = uM(c, f)) && k === w) f.stateNode = T; else { var Q = f.stateNode, ce = Qr(er.current), Ee = null; k !== w && (Ee = ve(Q, g, k, w, C, ce)), c && Ee === null ? f.stateNode = T : (T = Je(T, Ee, g, k, w, f, c, Q), oe(T, g, w, C, ce) && Yr(f), f.stateNode = T, c ? Yr(f) : pu(T, f, !1, !1)) } }, dd = function (c, f, g, w) { g !== w ? (c = Qr(_l.current), g = Qr(er.current), f.stateNode = Te(w, c, g, f), Yr(f)) : f.stateNode = c.stateNode } } else mu = function () { }, hd = function () { }, dd = function () { }; function gu(c, f) { if (!Qt) switch (c.tailMode) { case "hidden": f = c.tail; for (var g = null; f !== null;)f.alternate !== null && (g = f), f = f.sibling; g === null ? c.tail = null : g.sibling = null; break; case "collapsed": g = c.tail; for (var w = null; g !== null;)g.alternate !== null && (w = g), g = g.sibling; w === null ? f || c.tail === null ? c.tail = null : c.tail.sibling = null : w.sibling = null } } function Yn(c) { var f = c.alternate !== null && c.alternate.child === c.child, g = 0, w = 0; if (f) for (var C = c.child; C !== null;)g |= C.lanes | C.childLanes, w |= C.subtreeFlags & 14680064, w |= C.flags & 14680064, C.return = c, C = C.sibling; else for (C = c.child; C !== null;)g |= C.lanes | C.childLanes, w |= C.subtreeFlags, w |= C.flags, C.return = c, C = C.sibling; return c.subtreeFlags |= w, c.childLanes = g, f } function oB(c, f, g) { var w = f.pendingProps; switch (vg(f), f.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Yn(f), null; case 1: return xi(f.type) && Hh(), Yn(f), null; case 3: return w = f.stateNode, wl(), Tt(Xn), Tt(An), Cg(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (c === null || c.child === null) && (ou(f) ? Yr(f) : c === null || c.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024, _r !== null && (e1(_r), _r = null))), mu(c, f), Yn(f), null; case 5: wg(f), g = Qr(_l.current); var C = f.type; if (c !== null && f.stateNode != null) hd(c, f, C, w, g), c.ref !== f.ref && (f.flags |= 512, f.flags |= 2097152); else { if (!w) { if (f.stateNode === null) throw Error(o(166)); return Yn(f), null } if (c = Qr(er.current), ou(f)) { if (!pe) throw Error(o(175)); c = ot(f.stateNode, f.type, f.memoizedProps, g, c, f, !su), f.updateQueue = c, c !== null && Yr(f) } else { var T = se(C, w, g, c, f); pu(T, f, !1, !1), f.stateNode = T, oe(T, C, w, g, c) && Yr(f) } f.ref !== null && (f.flags |= 512, f.flags |= 2097152) } return Yn(f), null; case 6: if (c && f.stateNode != null) dd(c, f, c.memoizedProps, w); else { if (typeof w != "string" && f.stateNode === null) throw Error(o(166)); if (c = Qr(_l.current), g = Qr(er.current), ou(f)) { if (!pe) throw Error(o(176)); if (c = f.stateNode, w = f.memoizedProps, (g = ft(c, w, f, !su)) && (C = Li, C !== null)) switch (T = (C.mode & 1) !== 0, C.tag) { case 3: fs(C.stateNode.containerInfo, c, w, T); break; case 5: ln(C.type, C.memoizedProps, C.stateNode, c, w, T) }g && Yr(f) } else f.stateNode = Te(w, c, g, f) } return Yn(f), null; case 13: if (Tt($t), w = f.memoizedState, Qt && Ii !== null && f.mode & 1 && !(f.flags & 128)) { for (c = Ii; c;)c = fe(c); return Al(), f.flags |= 98560, f } if (w !== null && w.dehydrated !== null) { if (w = ou(f), c === null) { if (!w) throw Error(o(318)); if (!pe) throw Error(o(344)); if (c = f.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317)); pt(c, f) } else Al(), !(f.flags & 128) && (f.memoizedState = null), f.flags |= 4; return Yn(f), null } return _r !== null && (e1(_r), _r = null), f.flags & 128 ? (f.lanes = g, f) : (w = w !== null, g = !1, c === null ? ou(f) : g = c.memoizedState !== null, w && !g && (f.child.flags |= 8192, f.mode & 1 && (c === null || $t.current & 1 ? bn === 0 && (bn = 3) : n1())), f.updateQueue !== null && (f.flags |= 4), Yn(f), null); case 4: return wl(), mu(c, f), c === null && Ve(f.stateNode.containerInfo), Yn(f), null; case 10: return hg(f.type._context), Yn(f), null; case 17: return xi(f.type) && Hh(), Yn(f), null; case 19: if (Tt($t), C = f.memoizedState, C === null) return Yn(f), null; if (w = (f.flags & 128) !== 0, T = C.rendering, T === null) if (w) gu(C, !1); else { if (bn !== 0 || c !== null && c.flags & 128) for (c = f.child; c !== null;) { if (T = rd(c), T !== null) { for (f.flags |= 128, gu(C, !1), c = T.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), f.subtreeFlags = 0, c = g, w = f.child; w !== null;)g = w, C = c, g.flags &= 14680066, T = g.alternate, T === null ? (g.childLanes = 0, g.lanes = C, g.child = null, g.subtreeFlags = 0, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null) : (g.childLanes = T.childLanes, g.lanes = T.lanes, g.child = T.child, g.subtreeFlags = 0, g.deletions = null, g.memoizedProps = T.memoizedProps, g.memoizedState = T.memoizedState, g.updateQueue = T.updateQueue, g.type = T.type, C = T.dependencies, g.dependencies = C === null ? null : { lanes: C.lanes, firstContext: C.firstContext }), w = w.sibling; return Dt($t, $t.current & 1 | 2), f.child } c = c.sibling } C.tail !== null && In() > Yg && (f.flags |= 128, w = !0, gu(C, !1), f.lanes = 4194304) } else { if (!w) if (c = rd(T), c !== null) { if (f.flags |= 128, w = !0, c = c.updateQueue, c !== null && (f.updateQueue = c, f.flags |= 4), gu(C, !0), C.tail === null && C.tailMode === "hidden" && !T.alternate && !Qt) return Yn(f), null } else 2 * In() - C.renderingStartTime > Yg && g !== 1073741824 && (f.flags |= 128, w = !0, gu(C, !1), f.lanes = 4194304); C.isBackwards ? (T.sibling = f.child, f.child = T) : (c = C.last, c !== null ? c.sibling = T : f.child = T, C.last = T) } return C.tail !== null ? (f = C.tail, C.rendering = f, C.tail = f.sibling, C.renderingStartTime = In(), f.sibling = null, c = $t.current, Dt($t, w ? c & 1 | 2 : c & 1), f) : (Yn(f), null); case 22: case 23: return t1(), w = f.memoizedState !== null, c !== null && c.memoizedState !== null !== w && (f.flags |= 8192), w && f.mode & 1 ? Fi & 1073741824 && (Yn(f), be && f.subtreeFlags & 6 && (f.flags |= 8192)) : Yn(f), null; case 24: return null; case 25: return null }throw Error(o(156, f.tag)) } var aB = a.ReactCurrentOwner, Di = !1; function ci(c, f, g, w) { f.child = c === null ? z3(f, null, g, w) : Ml(f, c.child, g, w) } function hM(c, f, g, w, C) { g = g.render; var T = f.ref; return yl(f, C), w = bg(c, f, g, w, T, C), g = Tg(), c !== null && !Di ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~C, xs(c, f, C)) : (Qt && g && yg(f), f.flags |= 1, ci(c, f, w, C), f.child) } function dM(c, f, g, w, C) { if (c === null) { var T = g.type; return typeof T == "function" && !i1(T) && T.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (f.tag = 15, f.type = T, pM(c, f, T, w, C)) : (c = Dd(g.type, null, w, f, f.mode, C), c.ref = f.ref, c.return = f, f.child = c) } if (T = c.child, !(c.lanes & C)) { var k = T.memoizedProps; if (g = g.compare, g = g !== null ? g : Kh, g(k, w) && c.ref === f.ref) return xs(c, f, C) } return f.flags |= 1, c = ro(T, w), c.ref = f.ref, c.return = f, f.child = c } function pM(c, f, g, w, C) { if (c !== null && Kh(c.memoizedProps, w) && c.ref === f.ref) if (Di = !1, (c.lanes & C) !== 0) c.flags & 131072 && (Di = !0); else return f.lanes = c.lanes, xs(c, f, C); return Dg(c, f, g, w, C) } function mM(c, f, g) { var w = f.pendingProps, C = w.children, T = c !== null ? c.memoizedState : null; if (w.mode === "hidden") if (!(f.mode & 1)) f.memoizedState = { baseLanes: 0, cachePool: null }, Dt(Cl, Fi), Fi |= g; else if (g & 1073741824) f.memoizedState = { baseLanes: 0, cachePool: null }, w = T !== null ? T.baseLanes : g, Dt(Cl, Fi), Fi |= w; else return c = T !== null ? T.baseLanes | g : g, f.lanes = f.childLanes = 1073741824, f.memoizedState = { baseLanes: c, cachePool: null }, f.updateQueue = null, Dt(Cl, Fi), Fi |= c, null; else T !== null ? (w = T.baseLanes | g, f.memoizedState = null) : w = g, Dt(Cl, Fi), Fi |= w; return ci(c, f, C, g), f.child } function gM(c, f) { var g = f.ref; (c === null && g !== null || c !== null && c.ref !== g) && (f.flags |= 512, f.flags |= 2097152) } function Dg(c, f, g, w, C) { var T = xi(g) ? Vr : An.current; return T = ml(f, T), yl(f, C), g = bg(c, f, g, w, T, C), w = Tg(), c !== null && !Di ? (f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~C, xs(c, f, C)) : (Qt && w && yg(f), f.flags |= 1, ci(c, f, g, C), f.child) } function yM(c, f, g, w, C) { if (xi(g)) { var T = !0; Vh(f) } else T = !1; if (yl(f, C), f.stateNode === null) c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), R3(f, g, w), gg(f, g, w, C), w = !0; else if (c === null) { var k = f.stateNode, Q = f.memoizedProps; k.props = Q; var ce = k.context, Ee = g.contextType; typeof Ee == "object" && Ee !== null ? Ee = qi(Ee) : (Ee = xi(g) ? Vr : An.current, Ee = ml(f, Ee)); var We = g.getDerivedStateFromProps, at = typeof We == "function" || typeof k.getSnapshotBeforeUpdate == "function"; at || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (Q !== w || ce !== Ee) && L3(f, k, w, Ee), Zs = !1; var nt = f.memoizedState; k.state = nt, $h(f, w, k, C), ce = f.memoizedState, Q !== w || nt !== ce || Xn.current || Zs ? (typeof We == "function" && (mg(f, g, We, w), ce = f.memoizedState), (Q = Zs || P3(f, g, Q, w, nt, ce, Ee)) ? (at || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = w, f.memoizedState = ce), k.props = w, k.state = ce, k.context = Ee, w = Q) : (typeof k.componentDidMount == "function" && (f.flags |= 4194308), w = !1) } else { k = f.stateNode, E3(c, f), Q = f.memoizedProps, Ee = f.type === f.elementType ? Q : Mr(f.type, Q), k.props = Ee, at = f.pendingProps, nt = k.context, ce = g.contextType, typeof ce == "object" && ce !== null ? ce = qi(ce) : (ce = xi(g) ? Vr : An.current, ce = ml(f, ce)); var Ot = g.getDerivedStateFromProps; (We = typeof Ot == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (Q !== at || nt !== ce) && L3(f, k, w, ce), Zs = !1, nt = f.memoizedState, k.state = nt, $h(f, w, k, C); var qe = f.memoizedState; Q !== at || nt !== qe || Xn.current || Zs ? (typeof Ot == "function" && (mg(f, g, Ot, w), qe = f.memoizedState), (Ee = Zs || P3(f, g, Ee, w, nt, qe, ce) || !1) ? (We || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(w, qe, ce), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(w, qe, ce)), typeof k.componentDidUpdate == "function" && (f.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || Q === c.memoizedProps && nt === c.memoizedState || (f.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || Q === c.memoizedProps && nt === c.memoizedState || (f.flags |= 1024), f.memoizedProps = w, f.memoizedState = qe), k.props = w, k.state = qe, k.context = ce, w = Ee) : (typeof k.componentDidUpdate != "function" || Q === c.memoizedProps && nt === c.memoizedState || (f.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || Q === c.memoizedProps && nt === c.memoizedState || (f.flags |= 1024), w = !1) } return Fg(c, f, g, w, T, C) } function Fg(c, f, g, w, C, T) { gM(c, f); var k = (f.flags & 128) !== 0; if (!w && !k) return C && M3(f, g, !1), xs(c, f, T); w = f.stateNode, aB.current = f; var Q = k && typeof g.getDerivedStateFromError != "function" ? null : w.render(); return f.flags |= 1, c !== null && k ? (f.child = Ml(f, c.child, null, T), f.child = Ml(f, null, Q, T)) : ci(c, f, Q, T), f.memoizedState = w.state, C && M3(f, g, !0), f.child } function vM(c) { var f = c.stateNode; f.pendingContext ? x3(c, f.pendingContext, f.pendingContext !== f.context) : f.context && x3(c, f.context, !1), _g(c, f.containerInfo) } function xM(c, f, g, w, C) { return Al(), Mg(C), f.flags |= 256, ci(c, f, g, w), f.child } var pd = { dehydrated: null, treeContext: null, retryLane: 0 }; function md(c) { return { baseLanes: c, cachePool: null } } function AM(c, f, g) { var w = f.pendingProps, C = $t.current, T = !1, k = (f.flags & 128) !== 0, Q; if ((Q = k) || (Q = c !== null && c.memoizedState === null ? !1 : (C & 2) !== 0), Q ? (T = !0, f.flags &= -129) : (c === null || c.memoizedState !== null) && (C |= 1), Dt($t, C & 1), c === null) return Ag(f), c = f.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? (f.mode & 1 ? F(c) ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1, null) : (C = w.children, c = w.fallback, T ? (w = f.mode, T = f.child, C = { mode: "hidden", children: C }, !(w & 1) && T !== null ? (T.childLanes = 0, T.pendingProps = C) : T = Fd(C, w, 0, null), c = ha(c, w, g, null), T.return = f, c.return = f, T.sibling = c, f.child = T, f.child.memoizedState = md(g), f.memoizedState = pd, c) : kg(f, C)); if (C = c.memoizedState, C !== null) { if (Q = C.dehydrated, Q !== null) { if (k) return f.flags & 256 ? (f.flags &= -257, gd(c, f, g, Error(o(422)))) : f.memoizedState !== null ? (f.child = c.child, f.flags |= 128, null) : (T = w.fallback, C = f.mode, w = Fd({ mode: "visible", children: w.children }, C, 0, null), T = ha(T, C, g, null), T.flags |= 2, w.return = f, T.return = f, w.sibling = T, f.child = w, f.mode & 1 && Ml(f, c.child, null, g), f.child.memoizedState = md(g), f.memoizedState = pd, T); if (!(f.mode & 1)) f = gd(c, f, g, null); else if (F(Q)) f = gd(c, f, g, Error(o(419))); else if (w = (g & c.childLanes) !== 0, Di || w) { if (w = Mn, w !== null) { switch (g & -g) { case 4: T = 2; break; case 16: T = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: T = 32; break; case 536870912: T = 268435456; break; default: T = 0 }w = T & (w.suspendedLanes | g) ? 0 : T, w !== 0 && w !== C.retryLane && (C.retryLane = w, nr(c, w, -1)) } n1(), f = gd(c, f, g, Error(o(421))) } else Uh(Q) ? (f.flags |= 128, f.child = c.child, f = AB.bind(null, c), ne(Q, f), f = null) : (g = C.treeContext, pe && (Ii = et(Q), Li = f, Qt = !0, _r = null, su = !1, g !== null && (Zi[$i++] = gs, Zi[$i++] = ys, Zi[$i++] = ra, gs = g.id, ys = g.overflow, ra = f)), f = kg(f, f.pendingProps.children), f.flags |= 4096); return f } return T ? (w = _M(c, f, w.children, w.fallback, g), T = f.child, C = c.child.memoizedState, T.memoizedState = C === null ? md(g) : { baseLanes: C.baseLanes | g, cachePool: null }, T.childLanes = c.childLanes & ~g, f.memoizedState = pd, w) : (g = MM(c, f, w.children, g), f.memoizedState = null, g) } return T ? (w = _M(c, f, w.children, w.fallback, g), T = f.child, C = c.child.memoizedState, T.memoizedState = C === null ? md(g) : { baseLanes: C.baseLanes | g, cachePool: null }, T.childLanes = c.childLanes & ~g, f.memoizedState = pd, w) : (g = MM(c, f, w.children, g), f.memoizedState = null, g) } function kg(c, f) { return f = Fd({ mode: "visible", children: f }, c.mode, 0, null), f.return = c, c.child = f } function MM(c, f, g, w) { var C = c.child; return c = C.sibling, g = ro(C, { mode: "visible", children: g }), !(f.mode & 1) && (g.lanes = w), g.return = f, g.sibling = null, c !== null && (w = f.deletions, w === null ? (f.deletions = [c], f.flags |= 16) : w.push(c)), f.child = g } function _M(c, f, g, w, C) { var T = f.mode; c = c.child; var k = c.sibling, Q = { mode: "hidden", children: g }; return !(T & 1) && f.child !== c ? (g = f.child, g.childLanes = 0, g.pendingProps = Q, f.deletions = null) : (g = ro(c, Q), g.subtreeFlags = c.subtreeFlags & 14680064), k !== null ? w = ro(k, w) : (w = ha(w, T, C, null), w.flags |= 2), w.return = f, g.return = f, g.sibling = w, f.child = g, w } function gd(c, f, g, w) { return w !== null && Mg(w), Ml(f, c.child, null, g), c = kg(f, f.pendingProps.children), c.flags |= 2, f.memoizedState = null, c } function wM(c, f, g) { c.lanes |= f; var w = c.alternate; w !== null && (w.lanes |= f), dg(c.return, f, g) } function Ng(c, f, g, w, C) { var T = c.memoizedState; T === null ? c.memoizedState = { isBackwards: f, rendering: null, renderingStartTime: 0, last: w, tail: g, tailMode: C } : (T.isBackwards = f, T.rendering = null, T.renderingStartTime = 0, T.last = w, T.tail = g, T.tailMode = C) } function SM(c, f, g) { var w = f.pendingProps, C = w.revealOrder, T = w.tail; if (ci(c, f, w.children, g), w = $t.current, w & 2) w = w & 1 | 2, f.flags |= 128; else { if (c !== null && c.flags & 128) e: for (c = f.child; c !== null;) { if (c.tag === 13) c.memoizedState !== null && wM(c, g, f); else if (c.tag === 19) wM(c, g, f); else if (c.child !== null) { c.child.return = c, c = c.child; continue } if (c === f) break e; for (; c.sibling === null;) { if (c.return === null || c.return === f) break e; c = c.return } c.sibling.return = c.return, c = c.sibling } w &= 1 } if (Dt($t, w), !(f.mode & 1)) f.memoizedState = null; else switch (C) { case "forwards": for (g = f.child, C = null; g !== null;)c = g.alternate, c !== null && rd(c) === null && (C = g), g = g.sibling; g = C, g === null ? (C = f.child, f.child = null) : (C = g.sibling, g.sibling = null), Ng(f, !1, C, g, T); break; case "backwards": for (g = null, C = f.child, f.child = null; C !== null;) { if (c = C.alternate, c !== null && rd(c) === null) { f.child = C; break } c = C.sibling, C.sibling = g, g = C, C = c } Ng(f, !0, g, null, T); break; case "together": Ng(f, !1, null, null, void 0); break; default: f.memoizedState = null }return f.child } function xs(c, f, g) { if (c !== null && (f.dependencies = c.dependencies), El |= f.lanes, !(g & f.childLanes)) return null; if (c !== null && f.child !== c.child) throw Error(o(153)); if (f.child !== null) { for (c = f.child, g = ro(c, c.pendingProps), f.child = g, g.return = f; c.sibling !== null;)c = c.sibling, g = g.sibling = ro(c, c.pendingProps), g.return = f; g.sibling = null } return f.child } function lB(c, f, g) { switch (f.tag) { case 3: vM(f), Al(); break; case 5: U3(f); break; case 1: xi(f.type) && Vh(f); break; case 4: _g(f, f.stateNode.containerInfo); break; case 10: C3(f, f.type._context, f.memoizedProps.value); break; case 13: var w = f.memoizedState; if (w !== null) return w.dehydrated !== null ? (Dt($t, $t.current & 1), f.flags |= 128, null) : g & f.child.childLanes ? AM(c, f, g) : (Dt($t, $t.current & 1), c = xs(c, f, g), c !== null ? c.sibling : null); Dt($t, $t.current & 1); break; case 19: if (w = (g & f.childLanes) !== 0, c.flags & 128) { if (w) return SM(c, f, g); f.flags |= 128 } var C = f.memoizedState; if (C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), Dt($t, $t.current), w) break; return null; case 22: case 23: return f.lanes = 0, mM(c, f, g) }return xs(c, f, g) } function cB(c, f) { switch (vg(f), f.tag) { case 1: return xi(f.type) && Hh(), c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null; case 3: return wl(), Tt(Xn), Tt(An), Cg(), c = f.flags, c & 65536 && !(c & 128) ? (f.flags = c & -65537 | 128, f) : null; case 5: return wg(f), null; case 13: if (Tt($t), c = f.memoizedState, c !== null && c.dehydrated !== null) { if (f.alternate === null) throw Error(o(340)); Al() } return c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null; case 19: return Tt($t), null; case 4: return wl(), null; case 10: return hg(f.type._context), null; case 22: case 23: return t1(), null; case 24: return null; default: return null } } var yd = !1, aa = !1, uB = typeof WeakSet == "function" ? WeakSet : Set, ke = null; function vd(c, f) { var g = c.ref; if (g !== null) if (typeof g == "function") try { g(null) } catch (w) { _i(c, f, w) } else g.current = null } function Og(c, f, g) { try { g() } catch (w) { _i(c, f, w) } } var CM = !1; function fB(c, f) { for (H(c.containerInfo), ke = f; ke !== null;)if (c = ke, f = c.child, (c.subtreeFlags & 1028) !== 0 && f !== null) f.return = c, ke = f; else for (; ke !== null;) { c = ke; try { var g = c.alternate; if (c.flags & 1024) switch (c.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var w = g.memoizedProps, C = g.memoizedState, T = c.stateNode, k = T.getSnapshotBeforeUpdate(c.elementType === c.type ? w : Mr(c.type, w), C); T.__reactInternalSnapshotBeforeUpdate = k } break; case 3: be && Ue(c.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch (Q) { _i(c, c.return, Q) } if (f = c.sibling, f !== null) { f.return = c.return, ke = f; break } ke = c.return } return g = CM, CM = !1, g } function la(c, f, g) { var w = f.updateQueue; if (w = w !== null ? w.lastEffect : null, w !== null) { var C = w = w.next; do { if ((C.tag & c) === c) { var T = C.destroy; C.destroy = void 0, T !== void 0 && Og(f, g, T) } C = C.next } while (C !== w) } } function yu(c, f) { if (f = f.updateQueue, f = f !== null ? f.lastEffect : null, f !== null) { var g = f = f.next; do { if ((g.tag & c) === c) { var w = g.create; g.destroy = w() } g = g.next } while (g !== f) } } function zg(c) { var f = c.ref; if (f !== null) { var g = c.stateNode; switch (c.tag) { case 5: c = ee(g); break; default: c = g }typeof f == "function" ? f(c) : f.current = c } } function EM(c, f, g) { if (Wr && typeof Wr.onCommitFiberUnmount == "function") try { Wr.onCommitFiberUnmount(Xh, f) } catch { } switch (f.tag) { case 0: case 11: case 14: case 15: if (c = f.updateQueue, c !== null && (c = c.lastEffect, c !== null)) { var w = c = c.next; do { var C = w, T = C.destroy; C = C.tag, T !== void 0 && (C & 2 || C & 4) && Og(f, g, T), w = w.next } while (w !== c) } break; case 1: if (vd(f, g), c = f.stateNode, typeof c.componentWillUnmount == "function") try { c.props = f.memoizedProps, c.state = f.memoizedState, c.componentWillUnmount() } catch (k) { _i(f, g, k) } break; case 5: vd(f, g); break; case 4: be ? LM(c, f, g) : de && de && (f = f.stateNode.containerInfo, g = Nt(f), Ri(f, g)) } } function bM(c, f, g) { for (var w = f; ;)if (EM(c, w, g), w.child === null || be && w.tag === 4) { if (w === f) break; for (; w.sibling === null;) { if (w.return === null || w.return === f) return; w = w.return } w.sibling.return = w.return, w = w.sibling } else w.child.return = w, w = w.child } function TM(c) { var f = c.alternate; f !== null && (c.alternate = null, TM(f)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (f = c.stateNode, f !== null && Qe(f)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null } function BM(c) { return c.tag === 5 || c.tag === 3 || c.tag === 4 } function PM(c) { e: for (; ;) { for (; c.sibling === null;) { if (c.return === null || BM(c.return)) return null; c = c.return } for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18;) { if (c.flags & 2 || c.child === null || c.tag === 4) continue e; c.child.return = c, c = c.child } if (!(c.flags & 2)) return c.stateNode } } function RM(c) { if (be) { e: { for (var f = c.return; f !== null;) { if (BM(f)) break e; f = f.return } throw Error(o(160)) } var g = f; switch (g.tag) { case 5: f = g.stateNode, g.flags & 32 && (vt(f), g.flags &= -33), g = PM(c), Gg(c, g, f); break; case 3: case 4: f = g.stateNode.containerInfo, g = PM(c), Ug(c, g, f); break; default: throw Error(o(161)) } } } function Ug(c, f, g) { var w = c.tag; if (w === 5 || w === 6) c = c.stateNode, f ? Ae(g, c, f) : Oe(g, c); else if (w !== 4 && (c = c.child, c !== null)) for (Ug(c, f, g), c = c.sibling; c !== null;)Ug(c, f, g), c = c.sibling } function Gg(c, f, g) { var w = c.tag; if (w === 5 || w === 6) c = c.stateNode, f ? he(g, c, f) : Ye(g, c); else if (w !== 4 && (c = c.child, c !== null)) for (Gg(c, f, g), c = c.sibling; c !== null;)Gg(c, f, g), c = c.sibling } function LM(c, f, g) { for (var w = f, C = !1, T, k; ;) { if (!C) { C = w.return; e: for (; ;) { if (C === null) throw Error(o(160)); switch (T = C.stateNode, C.tag) { case 5: k = !1; break e; case 3: T = T.containerInfo, k = !0; break e; case 4: T = T.containerInfo, k = !0; break e }C = C.return } C = !0 } if (w.tag === 5 || w.tag === 6) bM(c, w, g), k ? tt(T, w.stateNode) : Be(T, w.stateNode); else if (w.tag === 18) k ? li(T, w.stateNode) : an(T, w.stateNode); else if (w.tag === 4) { if (w.child !== null) { T = w.stateNode.containerInfo, k = !0, w.child.return = w, w = w.child; continue } } else if (EM(c, w, g), w.child !== null) { w.child.return = w, w = w.child; continue } if (w === f) break; for (; w.sibling === null;) { if (w.return === null || w.return === f) return; w = w.return, w.tag === 4 && (C = !1) } w.sibling.return = w.return, w = w.sibling } } function Hg(c, f) { if (be) { switch (f.tag) { case 0: case 11: case 14: case 15: la(3, f, f.return), yu(3, f), la(5, f, f.return); return; case 1: return; case 5: var g = f.stateNode; if (g != null) { var w = f.memoizedProps; c = c !== null ? c.memoizedProps : w; var C = f.type, T = f.updateQueue; f.updateQueue = null, T !== null && G(g, T, C, c, w, f) } return; case 6: if (f.stateNode === null) throw Error(o(162)); g = f.memoizedProps, ye(f.stateNode, c !== null ? c.memoizedProps : g, g); return; case 3: pe && c !== null && c.memoizedState.isDehydrated && xt(f.stateNode.containerInfo); return; case 12: return; case 13: xd(f); return; case 19: xd(f); return; case 17: return }throw Error(o(163)) } switch (f.tag) { case 0: case 11: case 14: case 15: la(3, f, f.return), yu(3, f), la(5, f, f.return); return; case 12: return; case 13: xd(f); return; case 19: xd(f); return; case 3: pe && c !== null && c.memoizedState.isDehydrated && xt(f.stateNode.containerInfo); break; case 22: case 23: return }e: if (de) { switch (f.tag) { case 1: case 5: case 6: break e; case 3: case 4: f = f.stateNode, Ri(f.containerInfo, f.pendingChildren); break e }throw Error(o(163)) } } function xd(c) { var f = c.updateQueue; if (f !== null) { c.updateQueue = null; var g = c.stateNode; g === null && (g = c.stateNode = new uB), f.forEach(function (w) { var C = MB.bind(null, c, w); g.has(w) || (g.add(w), w.then(C, C)) }) } } function hB(c, f) { for (ke = f; ke !== null;) { f = ke; var g = f.deletions; if (g !== null) for (var w = 0; w < g.length; w++) { var C = g[w]; try { var T = c; be ? LM(T, C, f) : bM(T, C, f); var k = C.alternate; k !== null && (k.return = null), C.return = null } catch (Ke) { _i(C, f, Ke) } } if (g = f.child, f.subtreeFlags & 12854 && g !== null) g.return = f, ke = g; else for (; ke !== null;) { f = ke; try { var Q = f.flags; if (Q & 32 && be && vt(f.stateNode), Q & 512) { var ce = f.alternate; if (ce !== null) { var Ee = ce.ref; Ee !== null && (typeof Ee == "function" ? Ee(null) : Ee.current = null) } } if (Q & 8192) switch (f.tag) { case 13: if (f.memoizedState !== null) { var We = f.alternate; (We === null || We.memoizedState === null) && (Kg = In()) } break; case 22: var at = f.memoizedState !== null, nt = f.alternate, Ot = nt !== null && nt.memoizedState !== null; if (g = f, be) { e: if (w = g, C = at, T = null, be) for (var qe = w; ;) { if (qe.tag === 5) { if (T === null) { T = qe; var qn = qe.stateNode; C ? Ht(qn) : ae(qe.stateNode, qe.memoizedProps) } } else if (qe.tag === 6) { if (T === null) { var rr = qe.stateNode; C ? X(rr) : xe(rr, qe.memoizedProps) } } else if ((qe.tag !== 22 && qe.tag !== 23 || qe.memoizedState === null || qe === w) && qe.child !== null) { qe.child.return = qe, qe = qe.child; continue } if (qe === w) break; for (; qe.sibling === null;) { if (qe.return === null || qe.return === w) break e; T === qe && (T = null), qe = qe.return } T === qe && (T = null), qe.sibling.return = qe.return, qe = qe.sibling } } if (at && !Ot && g.mode & 1) { ke = g; for (var te = g.child; te !== null;) { for (g = ke = te; ke !== null;) { w = ke; var Y = w.child; switch (w.tag) { case 0: case 11: case 14: case 15: la(4, w, w.return); break; case 1: vd(w, w.return); var re = w.stateNode; if (typeof re.componentWillUnmount == "function") { var Ne = w.return; try { re.props = w.memoizedProps, re.state = w.memoizedState, re.componentWillUnmount() } catch (Ke) { _i(w, Ne, Ke) } } break; case 5: vd(w, w.return); break; case 22: if (w.memoizedState !== null) { FM(g); continue } }Y !== null ? (Y.return = w, ke = Y) : FM(g) } te = te.sibling } } }switch (Q & 4102) { case 2: RM(f), f.flags &= -3; break; case 6: RM(f), f.flags &= -3, Hg(f.alternate, f); break; case 4096: f.flags &= -4097; break; case 4100: f.flags &= -4097, Hg(f.alternate, f); break; case 4: Hg(f.alternate, f) } } catch (Ke) { _i(f, f.return, Ke) } if (g = f.sibling, g !== null) { g.return = f.return, ke = g; break } ke = f.return } } } function dB(c, f, g) { ke = c, IM(c) } function IM(c, f, g) { for (var w = (c.mode & 1) !== 0; ke !== null;) { var C = ke, T = C.child; if (C.tag === 22 && w) { var k = C.memoizedState !== null || yd; if (!k) { var Q = C.alternate, ce = Q !== null && Q.memoizedState !== null || aa; Q = yd; var Ee = aa; if (yd = k, (aa = ce) && !Ee) for (ke = C; ke !== null;)k = ke, ce = k.child, k.tag === 22 && k.memoizedState !== null ? kM(C) : ce !== null ? (ce.return = k, ke = ce) : kM(C); for (; T !== null;)ke = T, IM(T), T = T.sibling; ke = C, yd = Q, aa = Ee } DM(c) } else C.subtreeFlags & 8772 && T !== null ? (T.return = C, ke = T) : DM(c) } } function DM(c) { for (; ke !== null;) { var f = ke; if (f.flags & 8772) { var g = f.alternate; try { if (f.flags & 8772) switch (f.tag) { case 0: case 11: case 15: aa || yu(5, f); break; case 1: var w = f.stateNode; if (f.flags & 4 && !aa) if (g === null) w.componentDidMount(); else { var C = f.elementType === f.type ? g.memoizedProps : Mr(f.type, g.memoizedProps); w.componentDidUpdate(C, g.memoizedState, w.__reactInternalSnapshotBeforeUpdate) } var T = f.updateQueue; T !== null && T3(f, T, w); break; case 3: var k = f.updateQueue; if (k !== null) { if (g = null, f.child !== null) switch (f.child.tag) { case 5: g = ee(f.child.stateNode); break; case 1: g = f.child.stateNode }T3(f, k, g) } break; case 5: var Q = f.stateNode; g === null && f.flags & 4 && $e(Q, f.type, f.memoizedProps, f); break; case 6: break; case 4: break; case 12: break; case 13: if (pe && f.memoizedState === null) { var ce = f.alternate; if (ce !== null) { var Ee = ce.memoizedState; if (Ee !== null) { var We = Ee.dehydrated; We !== null && Mt(We) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(o(163)) }aa || f.flags & 512 && zg(f) } catch (at) { _i(f, f.return, at) } } if (f === c) { ke = null; break } if (g = f.sibling, g !== null) { g.return = f.return, ke = g; break } ke = f.return } } function FM(c) { for (; ke !== null;) { var f = ke; if (f === c) { ke = null; break } var g = f.sibling; if (g !== null) { g.return = f.return, ke = g; break } ke = f.return } } function kM(c) { for (; ke !== null;) { var f = ke; try { switch (f.tag) { case 0: case 11: case 15: var g = f.return; try { yu(4, f) } catch (ce) { _i(f, g, ce) } break; case 1: var w = f.stateNode; if (typeof w.componentDidMount == "function") { var C = f.return; try { w.componentDidMount() } catch (ce) { _i(f, C, ce) } } var T = f.return; try { zg(f) } catch (ce) { _i(f, T, ce) } break; case 5: var k = f.return; try { zg(f) } catch (ce) { _i(f, k, ce) } } } catch (ce) { _i(f, f.return, ce) } if (f === c) { ke = null; break } var Q = f.sibling; if (Q !== null) { Q.return = f.return, ke = Q; break } ke = f.return } } var Ad = 0, Md = 1, _d = 2, wd = 3, Sd = 4; if (typeof Symbol == "function" && Symbol.for) { var vu = Symbol.for; Ad = vu("selector.component"), Md = vu("selector.has_pseudo_class"), _d = vu("selector.role"), wd = vu("selector.test_id"), Sd = vu("selector.text") } function Vg(c) { var f = _e(c); if (f != null) { if (typeof f.memoizedProps["data-testname"] != "string") throw Error(o(364)); return f } if (c = wt(c), c === null) throw Error(o(362)); return c.stateNode.current } function Wg(c, f) { switch (f.$$typeof) { case Ad: if (c.type === f.value) return !0; break; case Md: e: { f = f.value, c = [c, 0]; for (var g = 0; g < c.length;) { var w = c[g++], C = c[g++], T = f[C]; if (w.tag !== 5 || !ie(w)) { for (; T != null && Wg(w, T);)C++, T = f[C]; if (C === f.length) { f = !0; break e } else for (w = w.child; w !== null;)c.push(w, C), w = w.sibling } } f = !1 } return f; case _d: if (c.tag === 5 && we(c.stateNode, f.value)) return !0; break; case Sd: if ((c.tag === 5 || c.tag === 6) && (c = I(c), c !== null && 0 <= c.indexOf(f.value))) return !0; break; case wd: if (c.tag === 5 && (c = c.memoizedProps["data-testname"], typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())) return !0; break; default: throw Error(o(365)) }return !1 } function jg(c) { switch (c.$$typeof) { case Ad: return "<" + (R(c.value) || "Unknown") + ">"; case Md: return ":has(" + (jg(c) || "") + ")"; case _d: return '[role="' + c.value + '"]'; case Sd: return '"' + c.value + '"'; case wd: return '[data-testname="' + c.value + '"]'; default: throw Error(o(365)) } } function NM(c, f) { var g = []; c = [c, 0]; for (var w = 0; w < c.length;) { var C = c[w++], T = c[w++], k = f[T]; if (C.tag !== 5 || !ie(C)) { for (; k != null && Wg(C, k);)T++, k = f[T]; if (T === f.length) g.push(C); else for (C = C.child; C !== null;)c.push(C, T), C = C.sibling } } return g } function Jg(c, f) { if (!gt) throw Error(o(363)); c = Vg(c), c = NM(c, f), f = [], c = Array.from(c); for (var g = 0; g < c.length;) { var w = c[g++]; if (w.tag === 5) ie(w) || f.push(w.stateNode); else for (w = w.child; w !== null;)c.push(w), w = w.sibling } return f } var pB = Math.ceil, Cd = a.ReactCurrentDispatcher, Xg = a.ReactCurrentOwner, gn = a.ReactCurrentBatchConfig, mt = 0, Mn = null, _n = null, Un = 0, Fi = 0, Cl = Xt(0), bn = 0, xu = null, El = 0, Ed = 0, Qg = 0, Au = null, Ai = null, Kg = 0, Yg = 1 / 0; function bl() { Yg = In() + 500 } var bd = !1, qg = null, eo = null, Td = !1, to = null, Bd = 0, Mu = 0, Zg = null, Pd = -1, Rd = 0; function ui() { return mt & 6 ? In() : Pd !== -1 ? Pd : Pd = In() } function no(c) { return c.mode & 1 ? mt & 2 && Un !== 0 ? Un & -Un : Y8.transition !== null ? (Rd === 0 && (c = Wh, Wh <<= 1, !(Wh & 4194240) && (Wh = 64), Rd = c), Rd) : (c = Pt, c !== 0 ? c : Ie()) : 1 } function nr(c, f, g) { if (50 < Mu) throw Mu = 0, Zg = null, Error(o(185)); var w = Ld(c, f); return w === null ? null : (ru(w, f, g), (!(mt & 2) || w !== Mn) && (w === Mn && (!(mt & 2) && (Ed |= f), bn === 4 && io(w, Un)), Mi(w, g), f === 1 && mt === 0 && !(c.mode & 1) && (bl(), Qh && Jr())), w) } function Ld(c, f) { c.lanes |= f; var g = c.alternate; for (g !== null && (g.lanes |= f), g = c, c = c.return; c !== null;)c.childLanes |= f, g = c.alternate, g !== null && (g.childLanes |= f), g = c, c = c.return; return g.tag === 3 ? g.stateNode : null } function Mi(c, f) { var g = c.callbackNode; G8(c, f); var w = Jh(c, c === Mn ? Un : 0); if (w === 0) g !== null && w3(g), c.callbackNode = null, c.callbackPriority = 0; else if (f = w & -w, c.callbackPriority !== f) { if (g != null && w3(g), f === 1) c.tag === 0 ? K8(zM.bind(null, c)) : S3(zM.bind(null, c)), Xe ? Ze(function () { mt === 0 && Jr() }) : og(ag, Jr), g = null; else { switch (_3(w)) { case 1: g = ag; break; case 4: g = j8; break; case 16: g = lg; break; case 536870912: g = J8; break; default: g = lg }g = QM(g, OM.bind(null, c)) } c.callbackPriority = f, c.callbackNode = g } } function OM(c, f) { if (Pd = -1, Rd = 0, mt & 6) throw Error(o(327)); var g = c.callbackNode; if (fa() && c.callbackNode !== g) return null; var w = Jh(c, c === Mn ? Un : 0); if (w === 0) return null; if (w & 30 || w & c.expiredLanes || f) f = Id(c, w); else { f = w; var C = mt; mt |= 2; var T = HM(); (Mn !== c || Un !== f) && (bl(), ca(c, f)); do try { yB(); break } catch (Q) { GM(c, Q) } while (1); fg(), Cd.current = T, mt = C, _n !== null ? f = 0 : (Mn = null, Un = 0, f = bn) } if (f !== 0) { if (f === 2 && (C = ig(c), C !== 0 && (w = C, f = $g(c, C))), f === 1) throw g = xu, ca(c, 0), io(c, w), Mi(c, In()), g; if (f === 6) io(c, w); else { if (C = c.current.alternate, !(w & 30) && !mB(C) && (f = Id(c, w), f === 2 && (T = ig(c), T !== 0 && (w = T, f = $g(c, T))), f === 1)) throw g = xu, ca(c, 0), io(c, w), Mi(c, In()), g; switch (c.finishedWork = C, c.finishedLanes = w, f) { case 0: case 1: throw Error(o(345)); case 2: ua(c, Ai); break; case 3: if (io(c, w), (w & 130023424) === w && (f = Kg + 500 - In(), 10 < f)) { if (Jh(c, 0) !== 0) break; if (C = c.suspendedLanes, (C & w) !== w) { ui(), c.pingedLanes |= c.suspendedLanes & C; break } c.timeoutHandle = Se(ua.bind(null, c, Ai), f); break } ua(c, Ai); break; case 4: if (io(c, w), (w & 4194240) === w) break; for (f = c.eventTimes, C = -1; 0 < w;) { var k = 31 - Ar(w); T = 1 << k, k = f[k], k > C && (C = k), w &= ~T } if (w = C, w = In() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * pB(w / 1960)) - w, 10 < w) { c.timeoutHandle = Se(ua.bind(null, c, Ai), w); break } ua(c, Ai); break; case 5: ua(c, Ai); break; default: throw Error(o(329)) } } } return Mi(c, In()), c.callbackNode === g ? OM.bind(null, c) : null } function $g(c, f) { var g = Au; return c.current.memoizedState.isDehydrated && (ca(c, f).flags |= 256), c = Id(c, f), c !== 2 && (f = Ai, Ai = g, f !== null && e1(f)), c } function e1(c) { Ai === null ? Ai = c : Ai.push.apply(Ai, c) } function mB(c) { for (var f = c; ;) { if (f.flags & 16384) { var g = f.updateQueue; if (g !== null && (g = g.stores, g !== null)) for (var w = 0; w < g.length; w++) { var C = g[w], T = C.getSnapshot; C = C.value; try { if (!jr(T(), C)) return !1 } catch { return !1 } } } if (g = f.child, f.subtreeFlags & 16384 && g !== null) g.return = f, f = g; else { if (f === c) break; for (; f.sibling === null;) { if (f.return === null || f.return === c) return !0; f = f.return } f.sibling.return = f.return, f = f.sibling } } return !0 } function io(c, f) { for (f &= ~Qg, f &= ~Ed, c.suspendedLanes |= f, c.pingedLanes &= ~f, c = c.expirationTimes; 0 < f;) { var g = 31 - Ar(f), w = 1 << g; c[g] = -1, f &= ~w } } function zM(c) { if (mt & 6) throw Error(o(327)); fa(); var f = Jh(c, 0); if (!(f & 1)) return Mi(c, In()), null; var g = Id(c, f); if (c.tag !== 0 && g === 2) { var w = ig(c); w !== 0 && (f = w, g = $g(c, w)) } if (g === 1) throw g = xu, ca(c, 0), io(c, f), Mi(c, In()), g; if (g === 6) throw Error(o(345)); return c.finishedWork = c.current.alternate, c.finishedLanes = f, ua(c, Ai), Mi(c, In()), null } function UM(c) { to !== null && to.tag === 0 && !(mt & 6) && fa(); var f = mt; mt |= 1; var g = gn.transition, w = Pt; try { if (gn.transition = null, Pt = 1, c) return c() } finally { Pt = w, gn.transition = g, mt = f, !(mt & 6) && Jr() } } function t1() { Fi = Cl.current, Tt(Cl) } function ca(c, f) { c.finishedWork = null, c.finishedLanes = 0; var g = c.timeoutHandle; if (g !== ze && (c.timeoutHandle = ze, Fe(g)), _n !== null) for (g = _n.return; g !== null;) { var w = g; switch (vg(w), w.tag) { case 1: w = w.type.childContextTypes, w != null && Hh(); break; case 3: wl(), Tt(Xn), Tt(An), Cg(); break; case 5: wg(w); break; case 4: wl(); break; case 13: Tt($t); break; case 19: Tt($t); break; case 10: hg(w.type._context); break; case 22: case 23: t1() }g = g.return } if (Mn = c, _n = c = ro(c.current, null), Un = Fi = f, bn = 0, xu = null, Qg = Ed = El = 0, Ai = Au = null, Xr !== null) { for (f = 0; f < Xr.length; f++)if (g = Xr[f], w = g.interleaved, w !== null) { g.interleaved = null; var C = w.next, T = g.pending; if (T !== null) { var k = T.next; T.next = C, w.next = k } g.pending = w } Xr = null } return c } function GM(c, f) { do { var g = _n; try { if (fg(), sd.current = fd, od) { for (var w = fn.memoizedState; w !== null;) { var C = w.queue; C !== null && (C.pending = null), w = w.next } od = !1 } if (Sl = 0, Dn = Qn = fn = null, uu = !1, fu = 0, Xg.current = null, g === null || g.return === null) { bn = 1, xu = f, _n = null; break } e: { var T = c, k = g.return, Q = g, ce = f; if (f = Un, Q.flags |= 32768, ce !== null && typeof ce == "object" && typeof ce.then == "function") { var Ee = ce, We = Q, at = We.tag; if (!(We.mode & 1) && (at === 0 || at === 11 || at === 15)) { var nt = We.alternate; nt ? (We.updateQueue = nt.updateQueue, We.memoizedState = nt.memoizedState, We.lanes = nt.lanes) : (We.updateQueue = null, We.memoizedState = null) } var Ot = lM(k); if (Ot !== null) { Ot.flags &= -257, cM(Ot, k, Q, T, f), Ot.mode & 1 && aM(T, Ee, f), f = Ot, ce = Ee; var qe = f.updateQueue; if (qe === null) { var qn = new Set; qn.add(ce), f.updateQueue = qn } else qe.add(ce); break e } else { if (!(f & 1)) { aM(T, Ee, f), n1(); break e } ce = Error(o(426)) } } else if (Qt && Q.mode & 1) { var rr = lM(k); if (rr !== null) { !(rr.flags & 65536) && (rr.flags |= 256), cM(rr, k, Q, T, f), Mg(ce); break e } } T = ce, bn !== 4 && (bn = 2), Au === null ? Au = [T] : Au.push(T), ce = Lg(ce, Q), Q = k; do { switch (Q.tag) { case 3: Q.flags |= 65536, f &= -f, Q.lanes |= f; var te = sM(Q, ce, f); b3(Q, te); break e; case 1: T = ce; var Y = Q.type, re = Q.stateNode; if (!(Q.flags & 128) && (typeof Y.getDerivedStateFromError == "function" || re !== null && typeof re.componentDidCatch == "function" && (eo === null || !eo.has(re)))) { Q.flags |= 65536, f &= -f, Q.lanes |= f; var Ne = oM(Q, T, f); b3(Q, Ne); break e } }Q = Q.return } while (Q !== null) } WM(g) } catch (Ke) { f = Ke, _n === g && g !== null && (_n = g = g.return); continue } break } while (1) } function HM() { var c = Cd.current; return Cd.current = fd, c === null ? fd : c } function n1() { (bn === 0 || bn === 3 || bn === 2) && (bn = 4), Mn === null || !(El & 268435455) && !(Ed & 268435455) || io(Mn, Un) } function Id(c, f) { var g = mt; mt |= 2; var w = HM(); Mn === c && Un === f || ca(c, f); do try { gB(); break } catch (C) { GM(c, C) } while (1); if (fg(), mt = g, Cd.current = w, _n !== null) throw Error(o(261)); return Mn = null, Un = 0, bn } function gB() { for (; _n !== null;)VM(_n) } function yB() { for (; _n !== null && !V8();)VM(_n) } function VM(c) { var f = XM(c.alternate, c, Fi); c.memoizedProps = c.pendingProps, f === null ? WM(c) : _n = f, Xg.current = null } function WM(c) { var f = c; do { var g = f.alternate; if (c = f.return, f.flags & 32768) { if (g = cB(g, f), g !== null) { g.flags &= 32767, _n = g; return } if (c !== null) c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null; else { bn = 6, _n = null; return } } else if (g = oB(g, f, Fi), g !== null) { _n = g; return } if (f = f.sibling, f !== null) { _n = f; return } _n = f = c } while (f !== null); bn === 0 && (bn = 5) } function ua(c, f) { var g = Pt, w = gn.transition; try { gn.transition = null, Pt = 1, vB(c, f, g) } finally { gn.transition = w, Pt = g } return null } function vB(c, f, g) { do fa(); while (to !== null); if (mt & 6) throw Error(o(327)); var w = c.finishedWork, C = c.finishedLanes; if (w === null) return null; if (c.finishedWork = null, c.finishedLanes = 0, w === c.current) throw Error(o(177)); c.callbackNode = null, c.callbackPriority = 0; var T = w.lanes | w.childLanes; if (H8(c, T), c === Mn && (_n = Mn = null, Un = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || Td || (Td = !0, QM(lg, function () { return fa(), null })), T = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || T) { T = gn.transition, gn.transition = null; var k = Pt; Pt = 1; var Q = mt; mt |= 4, Xg.current = null, fB(c, w), hB(c, w), W(c.containerInfo), c.current = w, dB(w), W8(), mt = Q, Pt = k, gn.transition = T } else c.current = w; if (Td && (Td = !1, to = c, Bd = C), T = c.pendingLanes, T === 0 && (eo = null), X8(w.stateNode), Mi(c, In()), f !== null) for (g = c.onRecoverableError, w = 0; w < f.length; w++)g(f[w]); if (bd) throw bd = !1, c = qg, qg = null, c; return Bd & 1 && c.tag !== 0 && fa(), T = c.pendingLanes, T & 1 ? c === Zg ? Mu++ : (Mu = 0, Zg = c) : Mu = 0, Jr(), null } function fa() { if (to !== null) { var c = _3(Bd), f = gn.transition, g = Pt; try { if (gn.transition = null, Pt = 16 > c ? 16 : c, to === null) var w = !1; else { if (c = to, to = null, Bd = 0, mt & 6) throw Error(o(331)); var C = mt; for (mt |= 4, ke = c.current; ke !== null;) { var T = ke, k = T.child; if (ke.flags & 16) { var Q = T.deletions; if (Q !== null) { for (var ce = 0; ce < Q.length; ce++) { var Ee = Q[ce]; for (ke = Ee; ke !== null;) { var We = ke; switch (We.tag) { case 0: case 11: case 15: la(8, We, T) }var at = We.child; if (at !== null) at.return = We, ke = at; else for (; ke !== null;) { We = ke; var nt = We.sibling, Ot = We.return; if (TM(We), We === Ee) { ke = null; break } if (nt !== null) { nt.return = Ot, ke = nt; break } ke = Ot } } } var qe = T.alternate; if (qe !== null) { var qn = qe.child; if (qn !== null) { qe.child = null; do { var rr = qn.sibling; qn.sibling = null, qn = rr } while (qn !== null) } } ke = T } } if (T.subtreeFlags & 2064 && k !== null) k.return = T, ke = k; else e: for (; ke !== null;) { if (T = ke, T.flags & 2048) switch (T.tag) { case 0: case 11: case 15: la(9, T, T.return) }var te = T.sibling; if (te !== null) { te.return = T.return, ke = te; break e } ke = T.return } } var Y = c.current; for (ke = Y; ke !== null;) { k = ke; var re = k.child; if (k.subtreeFlags & 2064 && re !== null) re.return = k, ke = re; else e: for (k = Y; ke !== null;) { if (Q = ke, Q.flags & 2048) try { switch (Q.tag) { case 0: case 11: case 15: yu(9, Q) } } catch (Ke) { _i(Q, Q.return, Ke) } if (Q === k) { ke = null; break e } var Ne = Q.sibling; if (Ne !== null) { Ne.return = Q.return, ke = Ne; break e } ke = Q.return } } if (mt = C, Jr(), Wr && typeof Wr.onPostCommitFiberRoot == "function") try { Wr.onPostCommitFiberRoot(Xh, c) } catch { } w = !0 } return w } finally { Pt = g, gn.transition = f } } return !1 } function jM(c, f, g) { f = Lg(g, f), f = sM(c, f, 1), $s(c, f), f = ui(), c = Ld(c, 1), c !== null && (ru(c, 1, f), Mi(c, f)) } function _i(c, f, g) { if (c.tag === 3) jM(c, c, g); else for (; f !== null;) { if (f.tag === 3) { jM(f, c, g); break } else if (f.tag === 1) { var w = f.stateNode; if (typeof f.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (eo === null || !eo.has(w))) { c = Lg(g, c), c = oM(f, c, 1), $s(f, c), c = ui(), f = Ld(f, 1), f !== null && (ru(f, 1, c), Mi(f, c)); break } } f = f.return } } function xB(c, f, g) { var w = c.pingCache; w !== null && w.delete(f), f = ui(), c.pingedLanes |= c.suspendedLanes & g, Mn === c && (Un & g) === g && (bn === 4 || bn === 3 && (Un & 130023424) === Un && 500 > In() - Kg ? ca(c, 0) : Qg |= g), Mi(c, f) } function JM(c, f) { f === 0 && (c.mode & 1 ? (f = jh, jh <<= 1, !(jh & 130023424) && (jh = 4194304)) : f = 1); var g = ui(); c = Ld(c, f), c !== null && (ru(c, f, g), Mi(c, g)) } function AB(c) { var f = c.memoizedState, g = 0; f !== null && (g = f.retryLane), JM(c, g) } function MB(c, f) { var g = 0; switch (c.tag) { case 13: var w = c.stateNode, C = c.memoizedState; C !== null && (g = C.retryLane); break; case 19: w = c.stateNode; break; default: throw Error(o(314)) }w !== null && w.delete(f), JM(c, g) } var XM; XM = function (c, f, g) { if (c !== null) if (c.memoizedProps !== f.pendingProps || Xn.current) Di = !0; else { if (!(c.lanes & g) && !(f.flags & 128)) return Di = !1, lB(c, f, g); Di = !!(c.flags & 131072) } else Di = !1, Qt && f.flags & 1048576 && I3(f, nd, f.index); switch (f.lanes = 0, f.tag) { case 2: var w = f.type; c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps; var C = ml(f, An.current); yl(f, g), C = bg(null, f, w, c, C, g); var T = Tg(); return f.flags |= 1, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (f.tag = 1, f.memoizedState = null, f.updateQueue = null, xi(w) ? (T = !0, Vh(f)) : T = !1, f.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, pg(f), C.updater = ed, f.stateNode = C, C._reactInternals = f, gg(f, w, c, g), f = Fg(null, f, w, !0, T, g)) : (f.tag = 0, Qt && T && yg(f), ci(null, f, C, g), f = f.child), f; case 16: w = f.elementType; e: { switch (c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), c = f.pendingProps, C = w._init, w = C(w._payload), f.type = w, C = f.tag = wB(w), c = Mr(w, c), C) { case 0: f = Dg(null, f, w, c, g); break e; case 1: f = yM(null, f, w, c, g); break e; case 11: f = hM(null, f, w, c, g); break e; case 14: f = dM(null, f, w, Mr(w.type, c), g); break e }throw Error(o(306, w, "")) } return f; case 0: return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : Mr(w, C), Dg(c, f, w, C, g); case 1: return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : Mr(w, C), yM(c, f, w, C, g); case 3: e: { if (vM(f), c === null) throw Error(o(387)); w = f.pendingProps, T = f.memoizedState, C = T.element, E3(c, f), $h(f, w, null, g); var k = f.memoizedState; if (w = k.element, pe && T.isDehydrated) if (T = { element: w, isDehydrated: !1, cache: k.cache, transitions: k.transitions }, f.updateQueue.baseState = T, f.memoizedState = T, f.flags & 256) { C = Error(o(423)), f = xM(c, f, w, g, C); break e } else if (w !== C) { C = Error(o(424)), f = xM(c, f, w, g, C); break e } else for (pe && (Ii = ge(f.stateNode.containerInfo), Li = f, Qt = !0, _r = null, su = !1), g = z3(f, null, w, g), f.child = g; g;)g.flags = g.flags & -3 | 4096, g = g.sibling; else { if (Al(), w === C) { f = xs(c, f, g); break e } ci(c, f, w, g) } f = f.child } return f; case 5: return U3(f), c === null && Ag(f), w = f.type, C = f.pendingProps, T = c !== null ? c.memoizedProps : null, k = C.children, q(w, C) ? k = null : T !== null && q(w, T) && (f.flags |= 32), gM(c, f), ci(c, f, k, g), f.child; case 6: return c === null && Ag(f), null; case 13: return AM(c, f, g); case 4: return _g(f, f.stateNode.containerInfo), w = f.pendingProps, c === null ? f.child = Ml(f, null, w, g) : ci(c, f, w, g), f.child; case 11: return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : Mr(w, C), hM(c, f, w, C, g); case 7: return ci(c, f, f.pendingProps, g), f.child; case 8: return ci(c, f, f.pendingProps.children, g), f.child; case 12: return ci(c, f, f.pendingProps.children, g), f.child; case 10: e: { if (w = f.type._context, C = f.pendingProps, T = f.memoizedProps, k = C.value, C3(f, w, k), T !== null) if (jr(T.value, k)) { if (T.children === C.children && !Xn.current) { f = xs(c, f, g); break e } } else for (T = f.child, T !== null && (T.return = f); T !== null;) { var Q = T.dependencies; if (Q !== null) { k = T.child; for (var ce = Q.firstContext; ce !== null;) { if (ce.context === w) { if (T.tag === 1) { ce = ms(-1, g & -g), ce.tag = 2; var Ee = T.updateQueue; if (Ee !== null) { Ee = Ee.shared; var We = Ee.pending; We === null ? ce.next = ce : (ce.next = We.next, We.next = ce), Ee.pending = ce } } T.lanes |= g, ce = T.alternate, ce !== null && (ce.lanes |= g), dg(T.return, g, f), Q.lanes |= g; break } ce = ce.next } } else if (T.tag === 10) k = T.type === f.type ? null : T.child; else if (T.tag === 18) { if (k = T.return, k === null) throw Error(o(341)); k.lanes |= g, Q = k.alternate, Q !== null && (Q.lanes |= g), dg(k, g, f), k = T.sibling } else k = T.child; if (k !== null) k.return = T; else for (k = T; k !== null;) { if (k === f) { k = null; break } if (T = k.sibling, T !== null) { T.return = k.return, k = T; break } k = k.return } T = k } ci(c, f, C.children, g), f = f.child } return f; case 9: return C = f.type, w = f.pendingProps.children, yl(f, g), C = qi(C), w = w(C), f.flags |= 1, ci(c, f, w, g), f.child; case 14: return w = f.type, C = Mr(w, f.pendingProps), C = Mr(w.type, C), dM(c, f, w, C, g); case 15: return pM(c, f, f.type, f.pendingProps, g); case 17: return w = f.type, C = f.pendingProps, C = f.elementType === w ? C : Mr(w, C), c !== null && (c.alternate = null, f.alternate = null, f.flags |= 2), f.tag = 1, xi(w) ? (c = !0, Vh(f)) : c = !1, yl(f, g), R3(f, w, C), gg(f, w, C, g), Fg(null, f, w, !0, c, g); case 19: return SM(c, f, g); case 22: return mM(c, f, g) }throw Error(o(156, f.tag)) }; function QM(c, f) { return og(c, f) } function _B(c, f, g, w) { this.tag = c, this.key = g, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ir(c, f, g, w) { return new _B(c, f, g, w) } function i1(c) { return c = c.prototype, !(!c || !c.isReactComponent) } function wB(c) { if (typeof c == "function") return i1(c) ? 1 : 0; if (c != null) { if (c = c.$$typeof, c === y) return 11; if (c === _) return 14 } return 2 } function ro(c, f) { var g = c.alternate; return g === null ? (g = ir(c.tag, f, c.key, c.mode), g.elementType = c.elementType, g.type = c.type, g.stateNode = c.stateNode, g.alternate = c, c.alternate = g) : (g.pendingProps = f, g.type = c.type, g.flags = 0, g.subtreeFlags = 0, g.deletions = null), g.flags = c.flags & 14680064, g.childLanes = c.childLanes, g.lanes = c.lanes, g.child = c.child, g.memoizedProps = c.memoizedProps, g.memoizedState = c.memoizedState, g.updateQueue = c.updateQueue, f = c.dependencies, g.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, g.sibling = c.sibling, g.index = c.index, g.ref = c.ref, g } function Dd(c, f, g, w, C, T) { var k = 2; if (w = c, typeof c == "function") i1(c) && (k = 1); else if (typeof c == "string") k = 5; else e: switch (c) { case h: return ha(g.children, C, T, f); case d: k = 8, C |= 8; break; case p: return c = ir(12, g, f, C | 2), c.elementType = p, c.lanes = T, c; case x: return c = ir(13, g, f, C), c.elementType = x, c.lanes = T, c; case A: return c = ir(19, g, f, C), c.elementType = A, c.lanes = T, c; case S: return Fd(g, C, T, f); default: if (typeof c == "object" && c !== null) switch (c.$$typeof) { case m: k = 10; break e; case v: k = 9; break e; case y: k = 11; break e; case _: k = 14; break e; case M: k = 16, w = null; break e }throw Error(o(130, c == null ? c : typeof c, "")) }return f = ir(k, g, f, C), f.elementType = c, f.type = w, f.lanes = T, f } function ha(c, f, g, w) { return c = ir(7, c, w, f), c.lanes = g, c } function Fd(c, f, g, w) { return c = ir(22, c, w, f), c.elementType = S, c.lanes = g, c.stateNode = {}, c } function r1(c, f, g) { return c = ir(6, c, null, f), c.lanes = g, c } function s1(c, f, g) { return f = ir(4, c.children !== null ? c.children : [], c.key, f), f.lanes = g, f.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, f } function SB(c, f, g, w, C) { this.tag = f, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = ze, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = rg(0), this.expirationTimes = rg(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = rg(0), this.identifierPrefix = w, this.onRecoverableError = C, pe && (this.mutableSourceEagerHydrationData = null) } function KM(c, f, g, w, C, T, k, Q, ce) { return c = new SB(c, f, g, Q, ce), f === 1 ? (f = 1, T === !0 && (f |= 8)) : f = 0, T = ir(3, null, null, f), c.current = T, T.stateNode = c, T.memoizedState = { element: w, isDehydrated: g, cache: null, transitions: null }, pg(T), c } function YM(c) { if (!c) return un; c = c._reactInternals; e: { if (P(c) !== c || c.tag !== 1) throw Error(o(170)); var f = c; do { switch (f.tag) { case 3: f = f.stateNode.context; break e; case 1: if (xi(f.type)) { f = f.stateNode.__reactInternalMemoizedMergedChildContext; break e } }f = f.return } while (f !== null); throw Error(o(171)) } if (c.tag === 1) { var g = c.type; if (xi(g)) return A3(c, g, f) } return f } function qM(c) { var f = c._reactInternals; if (f === void 0) throw typeof c.render == "function" ? Error(o(188)) : (c = Object.keys(c).join(","), Error(o(268, c))); return c = Z(f), c === null ? null : c.stateNode } function ZM(c, f) { if (c = c.memoizedState, c !== null && c.dehydrated !== null) { var g = c.retryLane; c.retryLane = g !== 0 && g < f ? g : f } } function o1(c, f) { ZM(c, f), (c = c.alternate) && ZM(c, f) } function CB(c) { return c = Z(c), c === null ? null : c.stateNode } function EB() { return null } return t.attemptContinuousHydration = function (c) { if (c.tag === 13) { var f = ui(); nr(c, 134217728, f), o1(c, 134217728) } }, t.attemptHydrationAtCurrentPriority = function (c) { if (c.tag === 13) { var f = ui(), g = no(c); nr(c, g, f), o1(c, g) } }, t.attemptSynchronousHydration = function (c) { switch (c.tag) { case 3: var f = c.stateNode; if (f.current.memoizedState.isDehydrated) { var g = iu(f.pendingLanes); g !== 0 && (sg(f, g | 1), Mi(f, In()), !(mt & 6) && (bl(), Jr())) } break; case 13: var w = ui(); UM(function () { return nr(c, 1, w) }), o1(c, 1) } }, t.batchedUpdates = function (c, f) { var g = mt; mt |= 1; try { return c(f) } finally { mt = g, mt === 0 && (bl(), Qh && Jr()) } }, t.createComponentSelector = function (c) { return { $$typeof: Ad, value: c } }, t.createContainer = function (c, f, g, w, C, T, k) { return KM(c, f, !1, null, g, w, C, T, k) }, t.createHasPseudoClassSelector = function (c) { return { $$typeof: Md, value: c } }, t.createHydrationContainer = function (c, f, g, w, C, T, k, Q, ce) { return c = KM(g, w, !0, c, C, T, k, Q, ce), c.context = YM(null), g = c.current, w = ui(), C = no(g), T = ms(w, C), T.callback = f ?? null, $s(g, T), c.current.lanes = C, ru(c, C, w), Mi(c, w), c }, t.createPortal = function (c, f, g) { var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: u, key: w == null ? null : "" + w, children: c, containerInfo: f, implementation: g } }, t.createRoleSelector = function (c) { return { $$typeof: _d, value: c } }, t.createTestNameSelector = function (c) { return { $$typeof: wd, value: c } }, t.createTextSelector = function (c) { return { $$typeof: Sd, value: c } }, t.deferredUpdates = function (c) { var f = Pt, g = gn.transition; try { return gn.transition = null, Pt = 16, c() } finally { Pt = f, gn.transition = g } }, t.discreteUpdates = function (c, f, g, w, C) { var T = Pt, k = gn.transition; try { return gn.transition = null, Pt = 1, c(f, g, w, C) } finally { Pt = T, gn.transition = k, mt === 0 && bl() } }, t.findAllNodes = Jg, t.findBoundingRects = function (c, f) { if (!gt) throw Error(o(363)); f = Jg(c, f), c = []; for (var g = 0; g < f.length; g++)c.push(O(f[g])); for (f = c.length - 1; 0 < f; f--) { g = c[f]; for (var w = g.x, C = w + g.width, T = g.y, k = T + g.height, Q = f - 1; 0 <= Q; Q--)if (f !== Q) { var ce = c[Q], Ee = ce.x, We = Ee + ce.width, at = ce.y, nt = at + ce.height; if (w >= Ee && T >= at && C <= We && k <= nt) { c.splice(f, 1); break } else if (w !== Ee || g.width !== ce.width || nt < T || at > k) { if (!(T !== at || g.height !== ce.height || We < w || Ee > C)) { Ee > w && (ce.width += Ee - w, ce.x = w), We < C && (ce.width = C - Ee), c.splice(f, 1); break } } else { at > T && (ce.height += at - T, ce.y = T), nt < k && (ce.height = k - at), c.splice(f, 1); break } } } return c }, t.findHostInstance = qM, t.findHostInstanceWithNoPortals = function (c) { return c = z(c), c = c !== null ? V(c) : null, c === null ? null : c.stateNode }, t.findHostInstanceWithWarning = function (c) { return qM(c) }, t.flushControlled = function (c) { var f = mt; mt |= 1; var g = gn.transition, w = Pt; try { gn.transition = null, Pt = 1, c() } finally { Pt = w, gn.transition = g, mt = f, mt === 0 && (bl(), Jr()) } }, t.flushPassiveEffects = fa, t.flushSync = UM, t.focusWithin = function (c, f) { if (!gt) throw Error(o(363)); for (c = Vg(c), f = NM(c, f), f = Array.from(f), c = 0; c < f.length;) { var g = f[c++]; if (!ie(g)) { if (g.tag === 5 && Ce(g.stateNode)) return !0; for (g = g.child; g !== null;)f.push(g), g = g.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return Pt }, t.getFindAllNodesFailureDescription = function (c, f) {
    if (!gt) throw Error(o(363)); var g = 0, w = []; c = [Vg(c), 0]; for (var C = 0; C < c.length;) { var T = c[C++], k = c[C++], Q = f[k]; if ((T.tag !== 5 || !ie(T)) && (Wg(T, Q) && (w.push(jg(Q)), k++, k > g && (g = k)), k < f.length)) for (T = T.child; T !== null;)c.push(T, k), T = T.sibling } if (g < f.length) {
      for (c = []; g < f.length; g++)c.push(jg(f[g])); return `findAllNodes was able to match part of the selector:
  `+ (w.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ")
    } return null
  }, t.getPublicRootInstance = function (c) { if (c = c.current, !c.child) return null; switch (c.child.tag) { case 5: return ee(c.child.stateNode); default: return c.child.stateNode } }, t.injectIntoDevTools = function (c) { if (c = { bundleType: c.bundleType, version: c.version, rendererPackageName: c.rendererPackageName, rendererConfig: c.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: CB, findFiberByHostInstance: c.findFiberByHostInstance || EB, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") c = !1; else { var f = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (f.isDisabled || !f.supportsFiber) c = !0; else { try { Xh = f.inject(c), Wr = f } catch { } c = !!f.checkDCE } } return c }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (c, f, g, w) { if (!gt) throw Error(o(363)); c = Jg(c, f); var C = Pe(c, g, w).disconnect; return { disconnect: function () { C() } } }, t.registerMutableSourceForHydration = function (c, f) { var g = f._getVersion; g = g(f._source), c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [f, g] : c.mutableSourceEagerHydrationData.push(f, g) }, t.runWithPriority = function (c, f) { var g = Pt; try { return Pt = c, f() } finally { Pt = g } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (c, f, g, w) { var C = f.current, T = ui(), k = no(C); return g = YM(g), f.context === null ? f.context = g : f.pendingContext = g, f = ms(T, k), f.payload = { element: c }, w = w === void 0 ? null : w, w !== null && (f.callback = w), $s(C, f), c = nr(C, k, T), c !== null && Zh(c, C, k), k }, t
}; (function (n) { n.exports = VO })(GO); const WO = CC(_2); function OT(n, e, t = (i, r) => i === r) { if (n === e) return !0; if (!n || !e) return !1; const i = n.length; if (e.length !== i) return !1; for (let r = 0; r < i; r++)if (!t(n[r], e[r])) return !1; return !0 } const Ps = []; function zT(n, e, t = !1, i = {}) { for (const s of Ps) if (OT(e, s.keys, s.equal)) { if (t) return; if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error; if (Object.prototype.hasOwnProperty.call(s, "response")) return s.response; if (!t) throw s.promise } const r = { keys: e, equal: i.equal, promise: n(...e).then(s => r.response = s).then(() => { i.lifespan && i.lifespan > 0 && setTimeout(() => { const s = Ps.indexOf(r); s !== -1 && Ps.splice(s, 1) }, i.lifespan) }).catch(s => r.error = s) }; if (Ps.push(r), !t) throw r.promise } const jO = (n, e, t) => zT(n, e, !1, t), JO = (n, e, t) => void zT(n, e, !0, t), XO = n => { if (n === void 0 || n.length === 0) Ps.splice(0, Ps.length); else { const e = Ps.find(t => OT(n, t.keys, t.equal)); if (e) { const t = Ps.indexOf(e); t !== -1 && Ps.splice(t, 1) } } }, NA = {}, QO = n => void Object.assign(NA, n); function KO(n, e) { function t(h, { args: d = [], attach: p, ...m }, v) { let y = `${h[0].toUpperCase()}${h.slice(1)}`, x; if (h === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const A = m.object; x = Ql(A, { type: h, root: v, attach: p, primitive: !0 }) } else { const A = NA[y]; if (!A) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!"); x = Ql(new A(...d), { type: h, root: v, attach: p, memoizedProps: { args: d } }) } return x.__r3f.attach === void 0 && (x instanceof ut ? x.__r3f.attach = "geometry" : x instanceof En && (x.__r3f.attach = "material")), y !== "inject" && my(x, m), x } function i(h, d) { let p = !1; if (d) { var m, v; (m = d.__r3f) != null && m.attach ? py(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d), p = !0), p || (v = h.__r3f) == null || v.objects.push(d), d.__r3f || Ql(d, {}), d.__r3f.parent = h, S2(d), Kl(d) } } function r(h, d, p) { let m = !1; if (d) { var v, y; if ((v = d.__r3f) != null && v.attach) py(h, d, d.__r3f.attach); else if (d.isObject3D && h.isObject3D) { d.parent = h, d.dispatchEvent({ type: "added" }); const x = h.children.filter(_ => _ !== d), A = x.indexOf(p); h.children = [...x.slice(0, A), d, ...x.slice(A)], m = !0 } m || (y = h.__r3f) == null || y.objects.push(d), d.__r3f || Ql(d, {}), d.__r3f.parent = h, S2(d), Kl(d) } } function s(h, d, p = !1) { h && [...h].forEach(m => o(d, m, p)) } function o(h, d, p) { if (d) { var m, v, y; if (d.__r3f && (d.__r3f.parent = null), (m = h.__r3f) != null && m.objects && (h.__r3f.objects = h.__r3f.objects.filter(S => S !== d)), (v = d.__r3f) != null && v.attach) HS(h, d, d.__r3f.attach); else if (d.isObject3D && h.isObject3D) { var x; h.remove(d), (x = d.__r3f) != null && x.root && iz(d.__r3f.root, d) } const _ = (y = d.__r3f) == null ? void 0 : y.primitive, M = p === void 0 ? d.dispose !== null && !_ : p; if (!_) { var A; s((A = d.__r3f) == null ? void 0 : A.objects, d, M), s(d.children, d, M) } d.__r3f && (delete d.__r3f.root, delete d.__r3f.objects, delete d.__r3f.handlers, delete d.__r3f.memoizedProps, _ || delete d.__r3f), M && d.dispose && d.type !== "Scene" && eh.unstable_scheduleCallback(eh.unstable_IdlePriority, () => { try { d.dispose() } catch { } }), Kl(h) } } function a(h, d, p, m) { var v; const y = (v = h.__r3f) == null ? void 0 : v.parent; if (!y) return; const x = t(d, p, h.__r3f.root); if (h.children) { for (const A of h.children) A.__r3f && i(x, A); h.children = h.children.filter(A => !A.__r3f) } h.__r3f.objects.forEach(A => i(x, A)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || o(y, h), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), i(y, x), x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x), [m, m.alternate].forEach(A => { A !== null && (A.stateNode = x, A.ref && (typeof A.ref == "function" ? A.ref(x) : A.ref.current = x)) }) } const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."); return { reconciler: WO({ createInstance: t, removeChild: o, appendChild: i, appendInitialChild: i, insertBefore: r, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (h, d) => { if (!d) return; const p = h.getState().scene; p.__r3f && (p.__r3f.root = h, i(p, d)) }, removeChildFromContainer: (h, d) => { d && o(h.getState().scene, d) }, insertInContainerBefore: (h, d, p) => { if (!d || !p) return; const m = h.getState().scene; m.__r3f && r(m, d, p) }, getRootHostContext: () => null, getChildHostContext: h => h, finalizeInitialChildren(h) { var d; const p = (d = h == null ? void 0 : h.__r3f) != null ? d : {}; return Boolean(p.handlers) }, prepareUpdate(h, d, p, m) { if (h.__r3f.primitive && m.object && m.object !== h) return [!0]; { const { args: v = [], children: y, ...x } = m, { args: A = [], children: _, ...M } = p; if (!Array.isArray(v)) throw new Error("R3F: the args prop must be an array!"); if (v.some((b, B) => b !== A[B])) return [!0]; const S = JT(h, x, M, !0); return S.changes.length ? [!1, S] : null } }, commitUpdate(h, [d, p], m, v, y, x) { d ? a(h, m, y, x) : my(h, p) }, commitMount(h, d, p, m) { var v; const y = (v = h.__r3f) != null ? v : {}; h.raycast && y.handlers && y.eventCount && h.__r3f.root.getState().internal.interaction.push(h) }, getPublicInstance: h => h, prepareForCommit: () => null, preparePortalMount: h => Ql(h.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(h) { var d; const { attach: p, parent: m } = (d = h.__r3f) != null ? d : {}; p && m && HS(m, h, p), h.isObject3D && (h.visible = !1), Kl(h) }, unhideInstance(h, d) { var p; const { attach: m, parent: v } = (p = h.__r3f) != null ? p : {}; m && v && py(v, h, m), (h.isObject3D && d.visible == null || d.visible) && (h.visible = !0), Kl(h) }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : bo.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && Wt.fun(performance.now) ? performance.now : Wt.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: Wt.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: Wt.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: my } } var OS, zS; const UT = () => { var n; return (n = NA.ColorManagement) != null ? n : null }, GT = n => n && n.isOrthographicCamera, YO = n => n && n.hasOwnProperty("current"), Dh = typeof window < "u" && ((OS = window.document) != null && OS.createElement || ((zS = window.navigator) == null ? void 0 : zS.product) === "ReactNative") ? U.useLayoutEffect : U.useEffect; function HT(n) { const e = U.useRef(n); return Dh(() => void (e.current = n), [n]), e } function qO({ set: n }) { return Dh(() => (n(new Promise(() => null)), () => n(!1)), [n]), null } class VT extends U.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } VT.getDerivedStateFromError = () => ({ error: !0 }); const WT = "__default", US = new Map, ZO = n => n && !!n.memoized && !!n.changes; function jT(n) { const e = typeof window < "u" ? window.devicePixelRatio : 1; return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n } const Hu = n => { var e; return (e = n.__r3f) == null ? void 0 : e.root.getState() }, Wt = { obj: n => n === Object(n) && !Wt.arr(n) && typeof n != "function", fun: n => typeof n == "function", str: n => typeof n == "string", num: n => typeof n == "number", boo: n => typeof n == "boolean", und: n => n === void 0, arr: n => Array.isArray(n), equ(n, e, { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}) { if (typeof n != typeof e || !!n != !!e) return !1; if (Wt.str(n) || Wt.num(n)) return n === e; const s = Wt.obj(n); if (s && i === "reference") return n === e; const o = Wt.arr(n); if (o && t === "reference") return n === e; if ((o || s) && n === e) return !0; let a; for (a in n) if (!(a in e)) return !1; if (s && t === "shallow" && i === "shallow") { for (a in r ? e : n) if (!Wt.equ(n[a], e[a], { strict: r, objects: "reference" })) return !1 } else for (a in r ? e : n) if (n[a] !== e[a]) return !1; if (Wt.und(a)) { if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0; if (n !== e) return !1 } return !0 } }; function $O(n) { const e = { nodes: {}, materials: {} }; return n && n.traverse(t => { t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material) }), e } function ez(n) { n.dispose && n.type !== "Scene" && n.dispose(); for (const e in n) e.dispose == null || e.dispose(), delete n[e] } function Ql(n, e) { const t = n; return (e != null && e.primitive || !t.__r3f) && (t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }), n } function w2(n, e) { let t = n; if (e.includes("-")) { const i = e.split("-"), r = i.pop(); return t = i.reduce((s, o) => s[o], n), { target: t, key: r } } else return { target: t, key: e } } const GS = /-\d+$/; function py(n, e, t) { if (Wt.str(t)) { if (GS.test(t)) { const s = t.replace(GS, ""), { target: o, key: a } = w2(n, s); Array.isArray(o[a]) || (o[a] = []) } const { target: i, key: r } = w2(n, t); e.__r3f.previousAttach = i[r], i[r] = e } else e.__r3f.previousAttach = t(n, e) } function HS(n, e, t) { var i, r; if (Wt.str(t)) { const { target: s, key: o } = w2(n, t), a = e.__r3f.previousAttach; a === void 0 ? delete s[o] : s[o] = a } else (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e); (r = e.__r3f) == null || delete r.previousAttach } function JT(n, { children: e, key: t, ref: i, ...r }, { children: s, key: o, ref: a, ...l } = {}, u = !1) { var h; const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {}, p = Object.entries(r), m = []; if (u) { const y = Object.keys(l); for (let x = 0; x < y.length; x++)r.hasOwnProperty(y[x]) || p.unshift([y[x], WT + "remove"]) } p.forEach(([y, x]) => { var A; if ((A = n.__r3f) != null && A.primitive && y === "object" || Wt.equ(x, l[y])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y)) return m.push([y, x, !0, []]); let _ = []; y.includes("-") && (_ = y.split("-")), m.push([y, x, !1, _]); for (const M in r) { const S = r[M]; M.startsWith(`${y}-`) && m.push([M, S, !1, M.split("-")]) } }); const v = { ...r }; return d.memoizedProps && d.memoizedProps.args && (v.args = d.memoizedProps.args), d.memoizedProps && d.memoizedProps.attach && (v.attach = d.memoizedProps.attach), { memoized: v, changes: m } } function my(n, e) { var t, i, r; const s = (t = n.__r3f) != null ? t : {}, o = s.root, a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}, { memoized: l, changes: u } = ZO(e) ? e : JT(n, e), h = s.eventCount; n.__r3f && (n.__r3f.memoizedProps = l); for (let p = 0; p < u.length; p++) { let [m, v, y, x] = u[p], A = n, _ = A[m]; if (x.length && (_ = x.reduce((M, S) => M[S], n), !(_ && _.set))) { const [M, ...S] = x.reverse(); A = S.reverse().reduce((b, B) => b[B], n), m = M } if (v === WT + "remove") if (A.constructor) { let M = US.get(A.constructor); M || (M = new A.constructor, US.set(A.constructor, M)), v = M[m] } else v = 0; if (y) v ? s.handlers[m] = v : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length; else if (_ && _.set && (_.copy || _ instanceof Ka)) { if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v); else if (_.copy && v && v.constructor && _.constructor === v.constructor) _.copy(v); else if (v !== void 0) { const M = _ instanceof Re; !M && _.setScalar ? _.setScalar(v) : _ instanceof Ka && v instanceof Ka ? _.mask = v.mask : _.set(v), !UT() && !a.linear && M && _.convertSRGBToLinear() } } else A[m] = v, !a.linear && A[m] instanceof Zt && A[m].format === Si && A[m].type === js && (A[m].encoding = St); Kl(n) } if (s.parent && a.internal && n.raycast && h !== s.eventCount) { const p = a.internal.interaction.indexOf(n); p > -1 && a.internal.interaction.splice(p, 1), s.eventCount && a.internal.interaction.push(n) } return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (r = n.__r3f) != null && r.parent && S2(n), n } function Kl(n) { var e, t; const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState(); i && i.internal.frames === 0 && i.invalidate() } function S2(n) { n.onUpdate == null || n.onUpdate(n) } function tz(n, e) { n.manual || (GT(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld()) } function Op(n) { return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId } function nz() { var n; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return bo.DefaultEventPriority; switch ((n = e.event) == null ? void 0 : n.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return bo.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return bo.ContinuousEventPriority; default: return bo.DefaultEventPriority } } function XT(n, e, t, i) { const r = t.get(e); r && (t.delete(e), t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i))) } function iz(n, e) { const { internal: t } = n.getState(); t.interaction = t.interaction.filter(i => i !== e), t.initialHits = t.initialHits.filter(i => i !== e), t.hovered.forEach((i, r) => { (i.eventObject === e || i.object === e) && t.hovered.delete(r) }), t.capturedMap.forEach((i, r) => { XT(t.capturedMap, e, i, r) }) } function rz(n) { function e(l) { const { internal: u } = n.getState(), h = l.offsetX - u.initialClick[0], d = l.offsetY - u.initialClick[1]; return Math.round(Math.sqrt(h * h + d * d)) } function t(l) { return l.filter(u => ["Move", "Over", "Enter", "Out", "Leave"].some(h => { var d; return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + h] })) } function i(l, u) { const h = n.getState(), d = new Set, p = [], m = u ? u(h.internal.interaction) : h.internal.interaction; for (let A = 0; A < m.length; A++) { const _ = Hu(m[A]); _ && (_.raycaster.camera = void 0) } h.previousRoot || h.events.compute == null || h.events.compute(l, h); function v(A) { const _ = Hu(A); if (!_ || !_.events.enabled || _.raycaster.camera === null) return []; if (_.raycaster.camera === void 0) { var M; _.events.compute == null || _.events.compute(l, _, (M = _.previousRoot) == null ? void 0 : M.getState()), _.raycaster.camera === void 0 && (_.raycaster.camera = null) } return _.raycaster.camera ? _.raycaster.intersectObject(A, !0) : [] } let y = m.flatMap(v).sort((A, _) => { const M = Hu(A.object), S = Hu(_.object); return !M || !S ? A.distance - _.distance : S.events.priority - M.events.priority || A.distance - _.distance }).filter(A => { const _ = Op(A); return d.has(_) ? !1 : (d.add(_), !0) }); h.events.filter && (y = h.events.filter(y, h)); for (const A of y) { let _ = A.object; for (; _;) { var x; (x = _.__r3f) != null && x.eventCount && p.push({ ...A, eventObject: _ }), _ = _.parent } } if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId)) for (let A of h.internal.capturedMap.get(l.pointerId).values()) d.has(Op(A.intersection)) || p.push(A.intersection); return p } function r(l, u, h, d) { const p = n.getState(); if (l.length) { const m = { stopped: !1 }; for (const v of l) { const y = Hu(v.object) || p, { raycaster: x, pointer: A, camera: _, internal: M } = y, S = new D(A.x, A.y, 0).unproject(_), b = L => { var z, Z; return (z = (Z = M.capturedMap.get(L)) == null ? void 0 : Z.has(v.eventObject)) != null ? z : !1 }, B = L => { const z = { intersection: v, target: u.target }; M.capturedMap.has(L) ? M.capturedMap.get(L).set(v.eventObject, z) : M.capturedMap.set(L, new Map([[v.eventObject, z]])), u.target.setPointerCapture(L) }, R = L => { const z = M.capturedMap.get(L); z && XT(M.capturedMap, v.eventObject, z, L) }; let E = {}; for (let L in u) { let z = u[L]; typeof z != "function" && (E[L] = z) } let P = { ...v, ...E, pointer: A, intersections: l, stopped: m.stopped, delta: h, unprojectedPoint: S, ray: x.ray, camera: _, stopPropagation() { const L = "pointerId" in u && M.capturedMap.get(u.pointerId); if ((!L || L.has(v.eventObject)) && (P.stopped = m.stopped = !0, M.hovered.size && Array.from(M.hovered.values()).find(z => z.eventObject === v.eventObject))) { const z = l.slice(0, l.indexOf(v)); s([...z, v]) } }, target: { hasPointerCapture: b, setPointerCapture: B, releasePointerCapture: R }, currentTarget: { hasPointerCapture: b, setPointerCapture: B, releasePointerCapture: R }, nativeEvent: u }; if (d(P), m.stopped === !0) break } } return l } function s(l) { const { internal: u } = n.getState(); for (const h of u.hovered.values()) if (!l.length || !l.find(d => d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) { const p = h.eventObject.__r3f, m = p == null ? void 0 : p.handlers; if (u.hovered.delete(Op(h)), p != null && p.eventCount) { const v = { ...h, intersections: l }; m.onPointerOut == null || m.onPointerOut(v), m.onPointerLeave == null || m.onPointerLeave(v) } } } function o(l, u) { for (let h = 0; h < u.length; h++) { const d = u[h].__r3f; d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l) } } function a(l) { switch (l) { case "onPointerLeave": case "onPointerCancel": return () => s([]); case "onLostPointerCapture": return u => { const { internal: h } = n.getState(); "pointerId" in u && h.capturedMap.has(u.pointerId) && (h.capturedMap.delete(u.pointerId), s([])) } }return function (h) { const { onPointerMissed: d, internal: p } = n.getState(); p.lastEvent.current = h; const m = l === "onPointerMove", v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", x = i(h, m ? t : void 0), A = v ? e(h) : 0; l === "onPointerDown" && (p.initialClick = [h.offsetX, h.offsetY], p.initialHits = x.map(M => M.eventObject)), v && !x.length && A <= 2 && (o(h, p.interaction), d && d(h)), m && s(x); function _(M) { const S = M.eventObject, b = S.__r3f, B = b == null ? void 0 : b.handlers; if (b != null && b.eventCount) if (m) { if (B.onPointerOver || B.onPointerEnter || B.onPointerOut || B.onPointerLeave) { const R = Op(M), E = p.hovered.get(R); E ? E.stopped && M.stopPropagation() : (p.hovered.set(R, M), B.onPointerOver == null || B.onPointerOver(M), B.onPointerEnter == null || B.onPointerEnter(M)) } B.onPointerMove == null || B.onPointerMove(M) } else { const R = B[l]; R ? (!v || p.initialHits.includes(S)) && (o(h, p.interaction.filter(E => !p.initialHits.includes(E))), R(M)) : v && p.initialHits.includes(S) && o(h, p.interaction.filter(E => !p.initialHits.includes(E))) } } r(x, h, A, _) } } return { handlePointer: a } } const QT = n => !!(n != null && n.render), KT = U.createContext(null), sz = (n, e) => { const t = kT((a, l) => { const u = new D, h = new D, d = new D; function p(A = l().camera, _ = h, M = l().size) { const { width: S, height: b, top: B, left: R } = M, E = S / b; _ instanceof D ? d.copy(_) : d.set(..._); const P = A.getWorldPosition(u).distanceTo(d); if (GT(A)) return { width: S / A.zoom, height: b / A.zoom, top: B, left: R, factor: 1, distance: P, aspect: E }; { const L = A.fov * Math.PI / 180, z = 2 * Math.tan(L / 2) * P, Z = z * (S / b); return { width: Z, height: z, top: B, left: R, factor: S / Z, distance: P, aspect: E } } } let m; const v = A => a(_ => ({ performance: { ..._.performance, current: A } })), y = new me; return { set: a, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, invalidate: (A = 1) => n(l(), A), advance: (A, _) => e(A, _, l()), legacy: !1, linear: !1, flat: !1, scene: Ql(new fA), controls: null, clock: new IA, pointer: y, mouse: y, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const A = l(); m && clearTimeout(m), A.performance.current !== A.performance.min && v(A.performance.min), m = setTimeout(() => v(l().performance.max), A.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: A => a(_ => ({ ..._, events: { ..._.events, ...A } })), setSize: (A, _, M, S, b) => { const B = l().camera, R = { width: A, height: _, top: S || 0, left: b || 0, updateStyle: M }; a(E => ({ size: R, viewport: { ...E.viewport, ...p(B, h, R) } })) }, setDpr: A => a(_ => { const M = jT(A); return { viewport: { ..._.viewport, dpr: M, initialDpr: _.viewport.initialDpr || M } } }), setFrameloop: (A = "always") => { const _ = l().clock; _.stop(), _.elapsedTime = 0, A !== "never" && (_.start(), _.elapsedTime = 0), a(() => ({ frameloop: A })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: U.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (A, _, M) => { const S = l().internal; return S.priority = S.priority + (_ > 0 ? 1 : 0), S.subscribers.push({ ref: A, priority: _, store: M }), S.subscribers = S.subscribers.sort((b, B) => b.priority - B.priority), () => { const b = l().internal; b != null && b.subscribers && (b.priority = b.priority - (_ > 0 ? 1 : 0), b.subscribers = b.subscribers.filter(B => B.ref !== A)) } } } } }), i = t.getState(); let r = i.size, s = i.viewport.dpr, o = i.camera; return t.subscribe(() => { const { camera: a, size: l, viewport: u, gl: h, set: d } = t.getState(); if (l !== r || u.dpr !== s) { var p; r = l, s = u.dpr, tz(a, l), h.setPixelRatio(u.dpr); const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement; h.setSize(l.width, l.height, m) } a !== o && (o = a, d(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) } }))) }), t.subscribe(a => n(a)), t }; let zp, oz = new Set, az = new Set, lz = new Set; function gy(n, e) { if (n.size) for (const { callback: t } of n.values()) t(e) } function Vu(n, e) { switch (n) { case "before": return gy(oz, e); case "after": return gy(az, e); case "tail": return gy(lz, e) } } let yy, vy; function xy(n, e, t) { let i = e.clock.getDelta(); for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), yy = e.internal.subscribers, zp = 0; zp < yy.length; zp++)vy = yy[zp], vy.ref.current(vy.store.getState(), i, t); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function cz(n) { let e = !1, t, i, r; function s(l) { i = requestAnimationFrame(s), e = !0, t = 0, Vu("before", l); for (const h of n.values()) { var u; r = h.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((u = r.gl.xr) != null && u.isPresenting) && (t += xy(l, r)) } if (Vu("after", l), t === 0) return Vu("tail", l), e = !1, cancelAnimationFrame(i) } function o(l, u = 1) { var h; if (!l) return n.forEach(d => o(d.store.getState()), u); (h = l.gl.xr) != null && h.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + u), e || (e = !0, requestAnimationFrame(s))) } function a(l, u = !0, h, d) { if (u && Vu("before", l), h) xy(l, h, d); else for (const p of n.values()) xy(l, p.store.getState()); u && Vu("after", l) } return { loop: s, invalidate: o, advance: a } } function YT() { const n = U.useContext(KT); if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return n } function zi(n = t => t, e) { return YT()(n, e) } function tu(n, e = 0) { const t = YT(), i = t.getState().internal.subscribe, r = HT(n); return Dh(() => i(r, e, t), [e, i, t]), null } function qT(n, e) { return function (t, ...i) { const r = new t; return n && n(r), Promise.all(i.map(s => new Promise((o, a) => r.load(s, l => { l.scene && Object.assign(l, $O(l.scene)), o(l) }, e, l => a(new Error(`Could not load ${s}: ${l.message})`)))))) } } function na(n, e, t, i) { const r = Array.isArray(e) ? e : [e], s = jO(qT(t, i), [n, ...r], { equal: Wt.equ }); return Array.isArray(e) ? s : s[0] } na.preload = function (n, e, t) { const i = Array.isArray(e) ? e : [e]; return JO(qT(t), [n, ...i]) }; na.clear = function (n, e) { const t = Array.isArray(e) ? e : [e]; return XO([n, ...t]) }; const Gc = new Map, { invalidate: VS, advance: WS } = cz(Gc), { reconciler: Wm, applyProps: To } = KO(Gc, nz), Jl = { objects: "shallow", strict: !1 }, uz = (n, e) => { const t = typeof n == "function" ? n(e) : n; return QT(t) ? t : new L0({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...n }) }; function fz(n, e) { if (e) return e; if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) { const { width: t, height: i, top: r, left: s } = n.parentElement.getBoundingClientRect(); return { width: t, height: i, top: r, left: s } } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return { width: n.width, height: n.height, top: 0, left: 0 }; return { width: 0, height: 0, top: 0, left: 0 } } function hz(n) { const e = Gc.get(n), t = e == null ? void 0 : e.fiber, i = e == null ? void 0 : e.store; e && console.warn("R3F.createRoot should only be called once!"); const r = typeof reportError == "function" ? reportError : console.error, s = i || sz(VS, WS), o = t || Wm.createContainer(s, bo.ConcurrentRoot, null, !1, null, "", r, null); e || Gc.set(n, { fiber: o, store: s }); let a, l = !1, u; return { configure(h = {}) { let { gl: d, size: p, events: m, onCreated: v, shadows: y = !1, linear: x = !1, flat: A = !1, legacy: _ = !1, orthographic: M = !1, frameloop: S = "always", dpr: b = [1, 2], performance: B, raycaster: R, camera: E, onPointerMissed: P } = h, L = s.getState(), z = L.gl; L.gl || L.set({ gl: z = uz(d, n) }); let Z = L.raycaster; Z || L.set({ raycaster: Z = new DT }); const { params: J, ...V } = R || {}; if (Wt.equ(V, Z, Jl) || To(Z, { ...V }), Wt.equ(J, Z.params, Jl) || To(Z, { params: { ...Z.params, ...J } }), !L.camera || L.camera === u && !Wt.equ(u, E, Jl)) { u = E; const W = E instanceof gh, se = W ? E : M ? new kr(0, 0, 0, 0, .1, 1e3) : new Ut(75, 0, .1, 1e3); W || (se.position.z = 5, E && To(se, E), !L.camera && !(E != null && E.rotation) && se.lookAt(0, 0, 0)), L.set({ camera: se }) } if (!L.xr) { const W = (oe, ve) => { const q = s.getState(); q.frameloop !== "never" && WS(oe, !0, q, ve) }, se = () => { const oe = s.getState(); oe.gl.xr.enabled = oe.gl.xr.isPresenting, oe.gl.xr.setAnimationLoop(oe.gl.xr.isPresenting ? W : null), oe.gl.xr.isPresenting || VS(oe) }, j = { connect() { const oe = s.getState().gl; oe.xr.addEventListener("sessionstart", se), oe.xr.addEventListener("sessionend", se) }, disconnect() { const oe = s.getState().gl; oe.xr.removeEventListener("sessionstart", se), oe.xr.removeEventListener("sessionend", se) } }; z.xr && j.connect(), L.set({ xr: j }) } if (z.shadowMap) { const W = z.shadowMap.enabled, se = z.shadowMap.type; if (z.shadowMap.enabled = !!y, Wt.boo(y)) z.shadowMap.type = df; else if (Wt.str(y)) { var K; const j = { basic: Vb, percentage: C0, soft: df, variance: Na }; z.shadowMap.type = (K = j[y]) != null ? K : df } else Wt.obj(y) && Object.assign(z.shadowMap, y); (W !== z.shadowMap.enabled || se !== z.shadowMap.type) && (z.shadowMap.needsUpdate = !0) } const ee = UT(); ee && ("enabled" in ee ? ee.enabled = !_ : "legacyMode" in ee && (ee.legacyMode = _)); const le = x ? Js : St, N = A ? Fr : Kx; z.outputEncoding !== le && (z.outputEncoding = le), z.toneMapping !== N && (z.toneMapping = N), L.legacy !== _ && L.set(() => ({ legacy: _ })), L.linear !== x && L.set(() => ({ linear: x })), L.flat !== A && L.set(() => ({ flat: A })), d && !Wt.fun(d) && !QT(d) && !Wt.equ(d, z, Jl) && To(z, d), m && !L.events.handlers && L.set({ events: m(s) }); const H = fz(n, p); return Wt.equ(H, L.size, Jl) || L.setSize(H.width, H.height, H.updateStyle, H.top, H.left), b && L.viewport.dpr !== jT(b) && L.setDpr(b), L.frameloop !== S && L.setFrameloop(S), L.onPointerMissed || L.set({ onPointerMissed: P }), B && !Wt.equ(B, L.performance, Jl) && L.set(W => ({ performance: { ...W.performance, ...B } })), a = v, l = !0, this }, render(h) { return l || this.configure(), Wm.updateContainer(U.createElement(dz, { store: s, children: h, onCreated: a, rootElement: n }), o, null, () => { }), s }, unmount() { ZT(n) } } } function dz({ store: n, children: e, onCreated: t, rootElement: i }) { return Dh(() => { const r = n.getState(); r.set(s => ({ internal: { ...s.internal, active: !0 } })), t && t(r), n.getState().events.connected || r.events.connect == null || r.events.connect(i) }, []), U.createElement(KT.Provider, { value: n }, e) } function ZT(n, e) { const t = Gc.get(n), i = t == null ? void 0 : t.fiber; if (i) { const r = t == null ? void 0 : t.store.getState(); r && (r.internal.active = !1), Wm.updateContainer(null, i, null, () => { r && setTimeout(() => { try { var s, o, a, l; r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = r.gl) != null && l.xr && r.xr.disconnect(), ez(r), Gc.delete(n), e && e(n) } catch { } }, 500) }) } } Wm.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: U.version }); function yr() { return yr = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, yr.apply(null, arguments) } function C2(n, e, t) { var i, r, s, o, a; e == null && (e = 100); function l() { var h = Date.now() - o; h < e && h >= 0 ? i = setTimeout(l, e - h) : (i = null, t || (a = n.apply(s, r), s = r = null)) } var u = function () { s = this, r = arguments, o = Date.now(); var h = t && !i; return i || (i = setTimeout(l, e)), h && (a = n.apply(s, r), s = r = null), a }; return u.clear = function () { i && (clearTimeout(i), i = null) }, u.flush = function () { i && (a = n.apply(s, r), s = r = null, clearTimeout(i), i = null) }, u } C2.debounce = C2; var jS = C2; function pz(n) { let { debounce: e, scroll: t, polyfill: i, offsetSize: r } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n; const s = i || (typeof window > "u" ? class { } : window.ResizeObserver); if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [o, a] = U.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = U.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o }), u = e ? typeof e == "number" ? e : e.scroll : null, h = e ? typeof e == "number" ? e : e.resize : null, d = U.useRef(!1); U.useEffect(() => (d.current = !0, () => void (d.current = !1))); const [p, m, v] = U.useMemo(() => { const _ = () => { if (!l.current.element) return; const { left: M, top: S, width: b, height: B, bottom: R, right: E, x: P, y: L } = l.current.element.getBoundingClientRect(), z = { left: M, top: S, width: b, height: B, bottom: R, right: E, x: P, y: L }; l.current.element instanceof HTMLElement && r && (z.height = l.current.element.offsetHeight, z.width = l.current.element.offsetWidth), Object.freeze(z), d.current && !vz(l.current.lastBounds, z) && a(l.current.lastBounds = z) }; return [_, h ? jS(_, h) : _, u ? jS(_, u) : _] }, [a, r, u, h]); function y() { l.current.scrollContainers && (l.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null) } function x() { l.current.element && (l.current.resizeObserver = new s(v), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(_ => _.addEventListener("scroll", v, { capture: !0, passive: !0 }))) } const A = _ => { !_ || _ === l.current.element || (y(), l.current.element = _, l.current.scrollContainers = $T(_), x()) }; return gz(v, Boolean(t)), mz(m), U.useEffect(() => { y(), x() }, [t, v, m]), U.useEffect(() => y, []), [A, o, p] } function mz(n) { U.useEffect(() => { const e = n; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [n]) } function gz(n, e) { U.useEffect(() => { if (e) { const t = n; return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0) } }, [n, e]) } function $T(n) { const e = []; if (!n || n === document.body) return e; const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n); return [t, i, r].some(s => s === "auto" || s === "scroll") && e.push(n), [...e, ...$T(n.parentElement)] } const yz = ["x", "y", "top", "bottom", "left", "right", "width", "height"], vz = (n, e) => yz.every(t => n[t] === e[t]); var xz = Object.defineProperty, Az = Object.defineProperties, Mz = Object.getOwnPropertyDescriptors, JS = Object.getOwnPropertySymbols, _z = Object.prototype.hasOwnProperty, wz = Object.prototype.propertyIsEnumerable, XS = (n, e, t) => e in n ? xz(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, QS = (n, e) => { for (var t in e || (e = {})) _z.call(e, t) && XS(n, t, e[t]); if (JS) for (var t of JS(e)) wz.call(e, t) && XS(n, t, e[t]); return n }, Sz = (n, e) => Az(n, Mz(e)), KS; function e6(n, e, t) { if (!n) return; if (t(n) === !0) return n; let i = e ? n.return : n.child; for (; i;) { const r = e6(i, e, t); if (r) return r; i = e ? null : i.sibling } } function t6(n) { try { return Object.defineProperties(n, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return n } } const OA = t6(U.createContext(null)); class n6 extends U.Component { render() { return U.createElement(OA.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: YS, ReactCurrentDispatcher: qS } = (KS = U.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) != null ? KS : {}; function Cz() { const n = U.useContext(OA), e = U.useId(); return U.useMemo(() => { var i; return (i = YS == null ? void 0 : YS.current) != null ? i : e6(n, !1, r => { let s = r.memoizedState; for (; s;) { if (s.memoizedState === e) return !0; s = s.next } }) }, [n, e]) } function Ez() { var n, e; const t = Cz(), [i] = U.useState(() => new Map); i.clear(); let r = t; for (; r;) { const s = (n = r.type) == null ? void 0 : n._context; s && s !== OA && !i.has(s) && i.set(s, (e = qS == null ? void 0 : qS.current) == null ? void 0 : e.readContext(t6(s))), r = r.return } return U.useMemo(() => Array.from(i.keys()).reduce((s, o) => a => U.createElement(s, null, U.createElement(o.Provider, Sz(QS({}, a), { value: i.get(o) }))), s => U.createElement(n6, QS({}, s))), [i]) } const Ay = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function bz(n) { const { handlePointer: e } = rz(n); return { priority: 1, enabled: !0, compute(t, i, r) { i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera) }, connected: void 0, handlers: Object.keys(Ay).reduce((t, i) => ({ ...t, [i]: e(i) }), {}), update: () => { var t; const { events: i, internal: r } = n.getState(); (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current) }, connect: t => { var i; const { set: r, events: s } = n.getState(); s.disconnect == null || s.disconnect(), r(o => ({ events: { ...o.events, connected: t } })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => { const [l, u] = Ay[o]; t.addEventListener(l, a, { passive: u }) }) }, disconnect: () => { const { set: t, events: i } = n.getState(); if (i.connected) { var r; Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => { if (i && i.connected instanceof HTMLElement) { const [a] = Ay[s]; i.connected.removeEventListener(a, o) } }), t(s => ({ events: { ...s.events, connected: void 0 } })) } } } } const Tz = U.forwardRef(function ({ children: e, fallback: t, resize: i, style: r, gl: s, events: o = bz, eventSource: a, eventPrefix: l, shadows: u, linear: h, flat: d, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: x, raycaster: A, camera: _, onPointerMissed: M, onCreated: S, ...b }, B) { U.useMemo(() => QO(NO), []); const R = Ez(), [E, P] = pz({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }), L = U.useRef(null), z = U.useRef(null); U.useImperativeHandle(B, () => L.current); const Z = HT(M), [J, V] = U.useState(!1), [K, ee] = U.useState(!1); if (J) throw J; if (K) throw K; const le = U.useRef(null); Dh(() => { const H = L.current; P.width > 0 && P.height > 0 && H && (le.current || (le.current = hz(H)), le.current.configure({ gl: s, events: o, shadows: u, linear: h, flat: d, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: x, raycaster: A, camera: _, size: P, onPointerMissed: (...W) => Z.current == null ? void 0 : Z.current(...W), onCreated: W => { W.events.connect == null || W.events.connect(a ? YO(a) ? a.current : a : z.current), l && W.setEvents({ compute: (se, j) => { const oe = se[l + "X"], ve = se[l + "Y"]; j.pointer.set(oe / j.size.width * 2 - 1, -(ve / j.size.height) * 2 + 1), j.raycaster.setFromCamera(j.pointer, j.camera) } }), S == null || S(W) } }), le.current.render(U.createElement(R, null, U.createElement(VT, { set: ee }, U.createElement(U.Suspense, { fallback: U.createElement(qO, { set: V }) }, e))))) }), U.useEffect(() => { const H = L.current; if (H) return () => ZT(H) }, []); const N = a ? "none" : "auto"; return U.createElement("div", yr({ ref: z, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: N, ...r } }, b), U.createElement("div", { ref: E, style: { width: "100%", height: "100%" } }, U.createElement("canvas", { ref: L, style: { display: "block" } }, t))) }), G0 = U.forwardRef(function (e, t) { return U.createElement(n6, null, U.createElement(Tz, yr({}, e, { ref: t }))) }), Fh = new D, zA = new D, Bz = new D; function Pz(n, e, t) { const i = Fh.setFromMatrixPosition(n.matrixWorld); i.project(e); const r = t.width / 2, s = t.height / 2; return [i.x * r + r, -(i.y * s) + s] } function Rz(n, e) { const t = Fh.setFromMatrixPosition(n.matrixWorld), i = zA.setFromMatrixPosition(e.matrixWorld), r = t.sub(i), s = e.getWorldDirection(Bz); return r.angleTo(s) > Math.PI / 2 } function Lz(n, e, t, i) { const r = Fh.setFromMatrixPosition(n.matrixWorld), s = r.clone(); s.project(e), t.setFromCamera(s, e); const o = t.intersectObjects(i, !0); if (o.length) { const a = o[0].distance; return r.distanceTo(t.ray.origin) < a } return !0 } function Iz(n, e) { if (e instanceof kr) return e.zoom; if (e instanceof Ut) { const t = Fh.setFromMatrixPosition(n.matrixWorld), i = zA.setFromMatrixPosition(e.matrixWorld), r = e.fov * Math.PI / 180, s = t.distanceTo(i); return 1 / (2 * Math.tan(r / 2) * s) } else return 1 } function Dz(n, e, t) { if (e instanceof Ut || e instanceof kr) { const i = Fh.setFromMatrixPosition(n.matrixWorld), r = zA.setFromMatrixPosition(e.matrixWorld), s = i.distanceTo(r), o = (t[1] - t[0]) / (e.far - e.near), a = t[1] - o * e.far; return Math.round(o * s + a) } } const E2 = n => Math.abs(n) < 1e-10 ? 0 : n; function i6(n, e, t = "") { let i = "matrix3d("; for (let r = 0; r !== 16; r++)i += E2(e[r] * n.elements[r]) + (r !== 15 ? "," : ")"); return t + i } const Fz = (n => e => i6(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), kz = (n => (e, t) => i6(e, n(t), "translate(-50%,-50%)"))(n => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]); function Nz(n) { return n && typeof n == "object" && "current" in n } const Oz = U.forwardRef(({ children: n, eps: e = .001, style: t, className: i, prepend: r, center: s, fullscreen: o, portal: a, distanceFactor: l, sprite: u = !1, transform: h = !1, occlude: d, onOcclude: p, castShadow: m, receiveShadow: v, material: y, geometry: x, zIndexRange: A = [16777271, 0], calculatePosition: _ = Pz, as: M = "div", wrapperClass: S, pointerEvents: b = "auto", ...B }, R) => {
  const { gl: E, camera: P, scene: L, size: z, raycaster: Z, events: J, viewport: V } = zi(), [K] = U.useState(() => document.createElement(M)), ee = U.useRef(), le = U.useRef(null), N = U.useRef(0), H = U.useRef([0, 0]), W = U.useRef(null), se = U.useRef(null), j = (a == null ? void 0 : a.current) || J.connected || E.domElement.parentNode, oe = U.useRef(null), ve = U.useRef(!1), q = U.useMemo(() => d && d !== "blending" || Array.isArray(d) && d.length && Nz(d[0]), [d]); U.useLayoutEffect(() => { const Le = E.domElement; d && d === "blending" ? (Le.style.zIndex = `${Math.floor(A[0] / 2)}`, Le.style.position = "absolute", Le.style.pointerEvents = "none") : (Le.style.zIndex = null, Le.style.position = null, Le.style.pointerEvents = null) }, [d]), U.useLayoutEffect(() => { if (le.current) { const Le = ee.current = Db(K); if (L.updateMatrixWorld(), h) K.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"; else { const be = _(le.current, P, z); K.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${be[0]}px,${be[1]}px,0);transform-origin:0 0;` } return j && (r ? j.prepend(K) : j.appendChild(K)), () => { j && j.removeChild(K), Le.unmount() } } }, [j, h]), U.useLayoutEffect(() => { S && (K.className = S) }, [S]); const Te = U.useMemo(() => h ? { position: "absolute", top: 0, left: 0, width: z.width, height: z.height, transformStyle: "preserve-3d", pointerEvents: "none" } : { position: "absolute", transform: s ? "translate3d(-50%,-50%,0)" : "none", ...o && { top: -z.height / 2, left: -z.width / 2, width: z.width, height: z.height }, ...t }, [t, s, o, z, h]), Se = U.useMemo(() => ({ position: "absolute", pointerEvents: b }), [b]); U.useLayoutEffect(() => { if (ve.current = !1, h) { var Le; (Le = ee.current) == null || Le.render(U.createElement("div", { ref: W, style: Te }, U.createElement("div", { ref: se, style: Se }, U.createElement("div", { ref: R, className: i, style: t, children: n })))) } else { var be; (be = ee.current) == null || be.render(U.createElement("div", { ref: R, style: Te, className: i, children: n })) } }); const Fe = U.useRef(!0); tu(Le => { if (le.current) { P.updateMatrixWorld(), le.current.updateWorldMatrix(!0, !1); const be = h ? H.current : _(le.current, P, z); if (h || Math.abs(N.current - P.zoom) > e || Math.abs(H.current[0] - be[0]) > e || Math.abs(H.current[1] - be[1]) > e) { const de = Rz(le.current, P); let pe = !1; q && (d !== "blending" ? pe = [L] : Array.isArray(d) && (pe = d.map(Qe => Qe.current))); const _e = Fe.current; if (pe) { const Qe = Lz(le.current, P, Z, pe); Fe.current = Qe && !de } else Fe.current = !de; _e !== Fe.current && (p ? p(!Fe.current) : K.style.display = Fe.current ? "block" : "none"); const Ve = Math.floor(A[0] / 2), Ie = d ? q ? [A[0], Ve] : [Ve - 1, 0] : A; if (K.style.zIndex = `${Dz(le.current, P, Ie)}`, h) { const [Qe, Xe] = [z.width / 2, z.height / 2], Ze = P.projectionMatrix.elements[5] * Xe, { isOrthographicCamera: gt, top: wt, left: O, bottom: I, right: ie } = P, we = Fz(P.matrixWorldInverse), Ce = gt ? `scale(${Ze})translate(${E2(-(ie + O) / 2)}px,${E2((wt + I) / 2)}px)` : `translateZ(${Ze}px)`; let Pe = le.current.matrixWorld; u && (Pe = P.matrixWorldInverse.clone().transpose().copyPosition(Pe).scale(le.current.scale), Pe.elements[3] = Pe.elements[7] = Pe.elements[11] = 0, Pe.elements[15] = 1), K.style.width = z.width + "px", K.style.height = z.height + "px", K.style.perspective = gt ? "" : `${Ze}px`, W.current && se.current && (W.current.style.transform = `${Ce}${we}translate(${Qe}px,${Xe}px)`, se.current.style.transform = kz(Pe, 1 / ((l || 10) / 400))) } else { const Qe = l === void 0 ? 1 : Iz(le.current, P) * l; K.style.transform = `translate3d(${be[0]}px,${be[1]}px,0) scale(${Qe})` } H.current = be, N.current = P.zoom } } if (!q && oe.current && !ve.current) if (h) { if (W.current) { const be = W.current.children[0]; if (be != null && be.clientWidth && be != null && be.clientHeight) { const { isOrthographicCamera: de } = P; if (de || x) B.scale && (Array.isArray(B.scale) ? B.scale instanceof D ? oe.current.scale.copy(B.scale.clone().divideScalar(1)) : oe.current.scale.set(1 / B.scale[0], 1 / B.scale[1], 1 / B.scale[2]) : oe.current.scale.setScalar(1 / B.scale)); else { const pe = (l || 10) / 400, _e = be.clientWidth * pe, Ve = be.clientHeight * pe; oe.current.scale.set(_e, Ve, 1) } ve.current = !0 } } } else { const be = K.children[0]; if (be != null && be.clientWidth && be != null && be.clientHeight) { const de = 1 / V.factor, pe = be.clientWidth * de, _e = be.clientHeight * de; oe.current.scale.set(pe, _e, 1), ve.current = !0 } oe.current.lookAt(Le.camera.position) } }); const ze = U.useMemo(() => ({
    vertexShader: h ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `, fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}), [h]); return U.createElement("group", yr({}, B, { ref: le }), d && !q && U.createElement("mesh", { castShadow: m, receiveShadow: v, ref: oe }, x || U.createElement("planeGeometry", null), y || U.createElement("shaderMaterial", { side: Lr, vertexShader: ze.vertexShader, fragmentShader: ze.fragmentShader })))
}); let Wu = 0; const zz = kT(n => (fc.onStart = (e, t, i) => { n({ active: !0, item: e, loaded: t, total: i, progress: (t - Wu) / (i - Wu) * 100 }) }, fc.onLoad = () => { n({ active: !1 }) }, fc.onError = e => n(t => ({ errors: [...t.errors, e] })), fc.onProgress = (e, t, i) => { t === i && (Wu = i), n({ active: !0, item: e, loaded: t, total: i, progress: (t - Wu) / (i - Wu) * 100 || 100 }) }, { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 })); function UA(n) { return function (e) { n.forEach(function (t) { typeof t == "function" ? t(e) : t != null && (t.current = e) }) } } function Sc(n, e, t) { return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function ZS(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(n); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable })), t.push.apply(t, i) } return t } function $S(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? ZS(Object(t), !0).forEach(function (i) { Sc(n, i, t[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : ZS(Object(t)).forEach(function (i) { Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i)) }) } return n } new me; new me; function r6(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } var or = function n(e, t, i) { var r = this; r6(this, n), Sc(this, "dot2", function (s, o) { return r.x * s + r.y * o }), Sc(this, "dot3", function (s, o, a) { return r.x * s + r.y * o + r.z * a }), this.x = e, this.y = t, this.z = i }, Uz = [new or(1, 1, 0), new or(-1, 1, 0), new or(1, -1, 0), new or(-1, -1, 0), new or(1, 0, 1), new or(-1, 0, 1), new or(1, 0, -1), new or(-1, 0, -1), new or(0, 1, 1), new or(0, -1, 1), new or(0, 1, -1), new or(0, -1, -1)], e4 = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], t4 = new Array(512), n4 = new Array(512), Gz = function (e) { e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8); for (var t = 0; t < 256; t++) { var i; t & 1 ? i = e4[t] ^ e & 255 : i = e4[t] ^ e >> 8 & 255, t4[t] = t4[t + 256] = i, n4[t] = n4[t + 256] = Uz[i % 12] } }; Gz(0); function Hz(n) { if (typeof n == "number") n = Math.abs(n); else if (typeof n == "string") { var e = n; n = 0; for (var t = 0; t < e.length; t++)n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647 } return n === 0 && (n = 311), n } function i4(n) { var e = Hz(n); return function () { var t = e * 48271 % 2147483647; return e = t, t / 2147483647 } } var Vz = function n(e) { var t = this; r6(this, n), Sc(this, "seed", 0), Sc(this, "init", function (i) { t.seed = i, t.value = i4(i) }), Sc(this, "value", i4(this.seed)), this.init(e) }, Wz = new Vz(Math.random()), jz = { radius: 1, center: [0, 0, 0] }; function Jz(n, e) { for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Wz, i = $S($S({}, jz), e), r = i.radius, s = i.center, o = 0; o < n.length; o += 3) { var a = Math.pow(t.value(), .3333333333333333), l = t.value() * 2 - 1, u = t.value() * 2 - 1, h = t.value() * 2 - 1, d = Math.sqrt(l * l + u * u + h * h); l = a * l / d, u = a * u / d, h = a * h / d, n[o] = l * r + s[0], n[o + 1] = u * r + s[1], n[o + 2] = h * r + s[2] } return n } function th(n) { return th = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, th(n) } function Xz(n, e) { if (th(n) != "object" || !n) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var i = t.call(n, e || "default"); if (th(i) != "object") return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function Qz(n) { var e = Xz(n, "string"); return th(e) == "symbol" ? e : e + "" } function ct(n, e, t) { return (e = Qz(e)) in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } const r4 = (n, e) => (n % e + e) % e; let Kz = class extends us { constructor(e, t) { super(), ct(this, "object", void 0), ct(this, "domElement", void 0), ct(this, "enabled", !0), ct(this, "target", new D), ct(this, "minDistance", 0), ct(this, "maxDistance", 1 / 0), ct(this, "minZoom", 0), ct(this, "maxZoom", 1 / 0), ct(this, "minPolarAngle", 0), ct(this, "maxPolarAngle", Math.PI), ct(this, "minAzimuthAngle", -1 / 0), ct(this, "maxAzimuthAngle", 1 / 0), ct(this, "enableDamping", !1), ct(this, "dampingFactor", .05), ct(this, "enableZoom", !0), ct(this, "zoomSpeed", 1), ct(this, "enableRotate", !0), ct(this, "rotateSpeed", 1), ct(this, "enablePan", !0), ct(this, "panSpeed", 1), ct(this, "screenSpacePanning", !0), ct(this, "keyPanSpeed", 7), ct(this, "autoRotate", !1), ct(this, "autoRotateSpeed", 2), ct(this, "reverseOrbit", !1), ct(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), ct(this, "mouseButtons", { LEFT: Ca.ROTATE, MIDDLE: Ca.DOLLY, RIGHT: Ca.PAN }), ct(this, "touches", { ONE: Ea.ROTATE, TWO: Ea.DOLLY_PAN }), ct(this, "target0", void 0), ct(this, "position0", void 0), ct(this, "zoom0", void 0), ct(this, "_domElementKeyEvents", null), ct(this, "getPolarAngle", void 0), ct(this, "getAzimuthalAngle", void 0), ct(this, "setPolarAngle", void 0), ct(this, "setAzimuthalAngle", void 0), ct(this, "getDistance", void 0), ct(this, "listenToKeyEvents", void 0), ct(this, "saveState", void 0), ct(this, "reset", void 0), ct(this, "update", void 0), ct(this, "connect", void 0), ct(this, "dispose", void 0), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof Ut ? this.object.zoom : 1, this.getPolarAngle = () => h.phi, this.getAzimuthalAngle = () => h.theta, this.setPolarAngle = G => { let he = r4(G, 2 * Math.PI), Ae = h.phi; Ae < 0 && (Ae += 2 * Math.PI), he < 0 && (he += 2 * Math.PI); let Be = Math.abs(he - Ae); 2 * Math.PI - Be < Be && (he < Ae ? he += 2 * Math.PI : Ae += 2 * Math.PI), d.phi = he - Ae, i.update() }, this.setAzimuthalAngle = G => { let he = r4(G, 2 * Math.PI), Ae = h.theta; Ae < 0 && (Ae += 2 * Math.PI), he < 0 && (he += 2 * Math.PI); let Be = Math.abs(he - Ae); 2 * Math.PI - Be < Be && (he < Ae ? he += 2 * Math.PI : Ae += 2 * Math.PI), d.theta = he - Ae, i.update() }, this.getDistance = () => i.object.position.distanceTo(i.target), this.listenToKeyEvents = G => { G.addEventListener("keydown", ie), this._domElementKeyEvents = G }, this.saveState = () => { i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object instanceof Ut ? i.object.zoom : 1 }, this.reset = () => { i.target.copy(i.target0), i.object.position.copy(i.position0), i.object instanceof Ut && (i.object.zoom = i.zoom0, i.object.updateProjectionMatrix()), i.dispatchEvent(r), i.update(), l = a.NONE }, this.update = (() => { const G = new D, he = new jn().setFromUnitVectors(e.up, new D(0, 1, 0)), Ae = he.clone().invert(), Be = new D, tt = new jn, vt = 2 * Math.PI; return function () { const X = i.object.position; G.copy(X).sub(i.target), G.applyQuaternion(he), h.setFromVector3(G), i.autoRotate && l === a.NONE && Z(L()), i.enableDamping ? (h.theta += d.theta * i.dampingFactor, h.phi += d.phi * i.dampingFactor) : (h.theta += d.theta, h.phi += d.phi); let ae = i.minAzimuthAngle, xe = i.maxAzimuthAngle; return isFinite(ae) && isFinite(xe) && (ae < -Math.PI ? ae += vt : ae > Math.PI && (ae -= vt), xe < -Math.PI ? xe += vt : xe > Math.PI && (xe -= vt), ae <= xe ? h.theta = Math.max(ae, Math.min(xe, h.theta)) : h.theta = h.theta > (ae + xe) / 2 ? Math.max(ae, h.theta) : Math.min(xe, h.theta)), h.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, h.phi)), h.makeSafe(), h.radius *= p, h.radius = Math.max(i.minDistance, Math.min(i.maxDistance, h.radius)), i.enableDamping === !0 ? i.target.addScaledVector(m, i.dampingFactor) : i.target.add(m), G.setFromSpherical(h), G.applyQuaternion(Ae), X.copy(i.target).add(G), i.object.lookAt(i.target), i.enableDamping === !0 ? (d.theta *= 1 - i.dampingFactor, d.phi *= 1 - i.dampingFactor, m.multiplyScalar(1 - i.dampingFactor)) : (d.set(0, 0, 0), m.set(0, 0, 0)), p = 1, v || Be.distanceToSquared(i.object.position) > u || 8 * (1 - tt.dot(i.object.quaternion)) > u ? (i.dispatchEvent(r), Be.copy(i.object.position), tt.copy(i.object.quaternion), v = !1, !0) : !1 } })(), this.connect = G => { G === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), i.domElement = G, i.domElement.style.touchAction = "none", i.domElement.addEventListener("contextmenu", Pe), i.domElement.addEventListener("pointerdown", Qe), i.domElement.addEventListener("pointercancel", gt), i.domElement.addEventListener("wheel", I) }, this.dispose = () => { var G, he, Ae, Be, tt, vt; (G = i.domElement) === null || G === void 0 || G.removeEventListener("contextmenu", Pe), (he = i.domElement) === null || he === void 0 || he.removeEventListener("pointerdown", Qe), (Ae = i.domElement) === null || Ae === void 0 || Ae.removeEventListener("pointercancel", gt), (Be = i.domElement) === null || Be === void 0 || Be.removeEventListener("wheel", I), (tt = i.domElement) === null || tt === void 0 || tt.ownerDocument.removeEventListener("pointermove", Xe), (vt = i.domElement) === null || vt === void 0 || vt.ownerDocument.removeEventListener("pointerup", Ze), i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", ie) }; const i = this, r = { type: "change" }, s = { type: "start" }, o = { type: "end" }, a = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let l = a.NONE; const u = 1e-6, h = new M2, d = new M2; let p = 1; const m = new D; let v = !1; const y = new me, x = new me, A = new me, _ = new me, M = new me, S = new me, b = new me, B = new me, R = new me, E = [], P = {}; function L() { return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed } function z() { return Math.pow(.95, i.zoomSpeed) } function Z(G) { i.reverseOrbit ? d.theta += G : d.theta -= G } function J(G) { i.reverseOrbit ? d.phi += G : d.phi -= G } const V = (() => { const G = new D; return function (Ae, Be) { G.setFromMatrixColumn(Be, 0), G.multiplyScalar(-Ae), m.add(G) } })(), K = (() => { const G = new D; return function (Ae, Be) { i.screenSpacePanning === !0 ? G.setFromMatrixColumn(Be, 1) : (G.setFromMatrixColumn(Be, 0), G.crossVectors(i.object.up, G)), G.multiplyScalar(Ae), m.add(G) } })(), ee = (() => { const G = new D; return function (Ae, Be) { const tt = i.domElement; if (tt && i.object instanceof Ut && i.object.isPerspectiveCamera) { const vt = i.object.position; G.copy(vt).sub(i.target); let Ht = G.length(); Ht *= Math.tan(i.object.fov / 2 * Math.PI / 180), V(2 * Ae * Ht / tt.clientHeight, i.object.matrix), K(2 * Be * Ht / tt.clientHeight, i.object.matrix) } else tt && i.object instanceof kr && i.object.isOrthographicCamera ? (V(Ae * (i.object.right - i.object.left) / i.object.zoom / tt.clientWidth, i.object.matrix), K(Be * (i.object.top - i.object.bottom) / i.object.zoom / tt.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1) } })(); function le(G) { i.object instanceof Ut && i.object.isPerspectiveCamera ? p /= G : i.object instanceof kr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * G)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function N(G) { i.object instanceof Ut && i.object.isPerspectiveCamera ? p *= G : i.object instanceof kr && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / G)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function H(G) { y.set(G.clientX, G.clientY) } function W(G) { b.set(G.clientX, G.clientY) } function se(G) { _.set(G.clientX, G.clientY) } function j(G) { x.set(G.clientX, G.clientY), A.subVectors(x, y).multiplyScalar(i.rotateSpeed); const he = i.domElement; he && (Z(2 * Math.PI * A.x / he.clientHeight), J(2 * Math.PI * A.y / he.clientHeight)), y.copy(x), i.update() } function oe(G) { B.set(G.clientX, G.clientY), R.subVectors(B, b), R.y > 0 ? le(z()) : R.y < 0 && N(z()), b.copy(B), i.update() } function ve(G) { M.set(G.clientX, G.clientY), S.subVectors(M, _).multiplyScalar(i.panSpeed), ee(S.x, S.y), _.copy(M), i.update() } function q(G) { G.deltaY < 0 ? N(z()) : G.deltaY > 0 && le(z()), i.update() } function Te(G) { let he = !1; switch (G.code) { case i.keys.UP: ee(0, i.keyPanSpeed), he = !0; break; case i.keys.BOTTOM: ee(0, -i.keyPanSpeed), he = !0; break; case i.keys.LEFT: ee(i.keyPanSpeed, 0), he = !0; break; case i.keys.RIGHT: ee(-i.keyPanSpeed, 0), he = !0; break }he && (G.preventDefault(), i.update()) } function Se() { if (E.length == 1) y.set(E[0].pageX, E[0].pageY); else { const G = .5 * (E[0].pageX + E[1].pageX), he = .5 * (E[0].pageY + E[1].pageY); y.set(G, he) } } function Fe() { if (E.length == 1) _.set(E[0].pageX, E[0].pageY); else { const G = .5 * (E[0].pageX + E[1].pageX), he = .5 * (E[0].pageY + E[1].pageY); _.set(G, he) } } function ze() { const G = E[0].pageX - E[1].pageX, he = E[0].pageY - E[1].pageY, Ae = Math.sqrt(G * G + he * he); b.set(0, Ae) } function Le() { i.enableZoom && ze(), i.enablePan && Fe() } function be() { i.enableZoom && ze(), i.enableRotate && Se() } function de(G) { if (E.length == 1) x.set(G.pageX, G.pageY); else { const Ae = $e(G), Be = .5 * (G.pageX + Ae.x), tt = .5 * (G.pageY + Ae.y); x.set(Be, tt) } A.subVectors(x, y).multiplyScalar(i.rotateSpeed); const he = i.domElement; he && (Z(2 * Math.PI * A.x / he.clientHeight), J(2 * Math.PI * A.y / he.clientHeight)), y.copy(x) } function pe(G) { if (E.length == 1) M.set(G.pageX, G.pageY); else { const he = $e(G), Ae = .5 * (G.pageX + he.x), Be = .5 * (G.pageY + he.y); M.set(Ae, Be) } S.subVectors(M, _).multiplyScalar(i.panSpeed), ee(S.x, S.y), _.copy(M) } function _e(G) { const he = $e(G), Ae = G.pageX - he.x, Be = G.pageY - he.y, tt = Math.sqrt(Ae * Ae + Be * Be); B.set(0, tt), R.set(0, Math.pow(B.y / b.y, i.zoomSpeed)), le(R.y), b.copy(B) } function Ve(G) { i.enableZoom && _e(G), i.enablePan && pe(G) } function Ie(G) { i.enableZoom && _e(G), i.enableRotate && de(G) } function Qe(G) { if (i.enabled !== !1) { if (E.length === 0) { var he, Ae; (he = i.domElement) === null || he === void 0 || he.ownerDocument.addEventListener("pointermove", Xe), (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.addEventListener("pointerup", Ze) } Ye(G), G.pointerType === "touch" ? we(G) : wt(G) } } function Xe(G) { i.enabled !== !1 && (G.pointerType === "touch" ? Ce(G) : O(G)) } function Ze(G) { if (Oe(G), E.length === 0) { var he, Ae, Be; (he = i.domElement) === null || he === void 0 || he.releasePointerCapture(G.pointerId), (Ae = i.domElement) === null || Ae === void 0 || Ae.ownerDocument.removeEventListener("pointermove", Xe), (Be = i.domElement) === null || Be === void 0 || Be.ownerDocument.removeEventListener("pointerup", Ze) } i.dispatchEvent(o), l = a.NONE } function gt(G) { Oe(G) } function wt(G) { let he; switch (G.button) { case 0: he = i.mouseButtons.LEFT; break; case 1: he = i.mouseButtons.MIDDLE; break; case 2: he = i.mouseButtons.RIGHT; break; default: he = -1 }switch (he) { case Ca.DOLLY: if (i.enableZoom === !1) return; W(G), l = a.DOLLY; break; case Ca.ROTATE: if (G.ctrlKey || G.metaKey || G.shiftKey) { if (i.enablePan === !1) return; se(G), l = a.PAN } else { if (i.enableRotate === !1) return; H(G), l = a.ROTATE } break; case Ca.PAN: if (G.ctrlKey || G.metaKey || G.shiftKey) { if (i.enableRotate === !1) return; H(G), l = a.ROTATE } else { if (i.enablePan === !1) return; se(G), l = a.PAN } break; default: l = a.NONE }l !== a.NONE && i.dispatchEvent(s) } function O(G) { if (i.enabled !== !1) switch (l) { case a.ROTATE: if (i.enableRotate === !1) return; j(G); break; case a.DOLLY: if (i.enableZoom === !1) return; oe(G); break; case a.PAN: if (i.enablePan === !1) return; ve(G); break } } function I(G) { i.enabled === !1 || i.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (G.preventDefault(), i.dispatchEvent(s), q(G), i.dispatchEvent(o)) } function ie(G) { i.enabled === !1 || i.enablePan === !1 || Te(G) } function we(G) { switch (ye(G), E.length) { case 1: switch (i.touches.ONE) { case Ea.ROTATE: if (i.enableRotate === !1) return; Se(), l = a.TOUCH_ROTATE; break; case Ea.PAN: if (i.enablePan === !1) return; Fe(), l = a.TOUCH_PAN; break; default: l = a.NONE }break; case 2: switch (i.touches.TWO) { case Ea.DOLLY_PAN: if (i.enableZoom === !1 && i.enablePan === !1) return; Le(), l = a.TOUCH_DOLLY_PAN; break; case Ea.DOLLY_ROTATE: if (i.enableZoom === !1 && i.enableRotate === !1) return; be(), l = a.TOUCH_DOLLY_ROTATE; break; default: l = a.NONE }break; default: l = a.NONE }l !== a.NONE && i.dispatchEvent(s) } function Ce(G) { switch (ye(G), l) { case a.TOUCH_ROTATE: if (i.enableRotate === !1) return; de(G), i.update(); break; case a.TOUCH_PAN: if (i.enablePan === !1) return; pe(G), i.update(); break; case a.TOUCH_DOLLY_PAN: if (i.enableZoom === !1 && i.enablePan === !1) return; Ve(G), i.update(); break; case a.TOUCH_DOLLY_ROTATE: if (i.enableZoom === !1 && i.enableRotate === !1) return; Ie(G), i.update(); break; default: l = a.NONE } } function Pe(G) { i.enabled !== !1 && G.preventDefault() } function Ye(G) { E.push(G) } function Oe(G) { delete P[G.pointerId]; for (let he = 0; he < E.length; he++)if (E[he].pointerId == G.pointerId) { E.splice(he, 1); return } } function ye(G) { let he = P[G.pointerId]; he === void 0 && (he = new me, P[G.pointerId] = he), he.set(G.pageX, G.pageY) } function $e(G) { const he = G.pointerId === E[0].pointerId ? E[1] : E[0]; return P[he.pointerId] } t !== void 0 && this.connect(t), this.update() } }; class GA extends vi { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new eU(t) }), this.register(function (t) { return new aU(t) }), this.register(function (t) { return new lU(t) }), this.register(function (t) { return new nU(t) }), this.register(function (t) { return new iU(t) }), this.register(function (t) { return new rU(t) }), this.register(function (t) { return new sU(t) }), this.register(function (t) { return new $z(t) }), this.register(function (t) { return new oU(t) }), this.register(function (t) { return new tU(t) }), this.register(function (t) { return new qz(t) }), this.register(function (t) { return new cU(t) }) } load(e, t, i, r) { const s = this; let o; this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ss.extractUrlBase(e), this.manager.itemStart(e); const a = function (u) { r ? r(u) : console.error(u), s.manager.itemError(e), s.manager.itemEnd(e) }, l = new ji(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (u) { try { s.parse(u, o, function (h) { t(h), s.manager.itemEnd(e) }, a) } catch (h) { a(h) } }, i, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, i, r) { let s; const o = {}, a = {}; if (typeof e == "string") s = e; else if (ss.decodeText(new Uint8Array(e, 0, 4)) === s6) { try { o[At.KHR_BINARY_GLTF] = new uU(e) } catch (d) { r && r(d); return } s = o[At.KHR_BINARY_GLTF].content } else s = ss.decodeText(new Uint8Array(e)); const l = JSON.parse(s); if (l.asset === void 0 || l.asset.version[0] < 2) { r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const u = new wU(l, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); u.fileLoader.setRequestHeader(this.requestHeader); for (let h = 0; h < this.pluginCallbacks.length; h++) { const d = this.pluginCallbacks[h](u); a[d.name] = d, o[d.name] = !0 } if (l.extensionsUsed) for (let h = 0; h < l.extensionsUsed.length; ++h) { const d = l.extensionsUsed[h], p = l.extensionsRequired || []; switch (d) { case At.KHR_MATERIALS_UNLIT: o[d] = new Zz; break; case At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: o[d] = new dU; break; case At.KHR_DRACO_MESH_COMPRESSION: o[d] = new fU(l, this.dracoLoader); break; case At.KHR_TEXTURE_TRANSFORM: o[d] = new hU; break; case At.KHR_MESH_QUANTIZATION: o[d] = new pU; break; default: p.indexOf(d) >= 0 && a[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".') } } u.setExtensions(o), u.setPlugins(a), u.parse(i, r) } parseAsync(e, t) { const i = this; return new Promise(function (r, s) { i.parse(e, t, r, s) }) } } function Yz() { let n = {}; return { get: function (e) { return n[e] }, add: function (e, t) { n[e] = t }, remove: function (e) { delete n[e] }, removeAll: function () { n = {} } } } const At = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class qz { constructor(e) { this.parser = e, this.name = At.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, i = "light:" + e; let r = t.cache.get(i); if (r) return r; const s = t.json, l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e]; let u; const h = new Re(16777215); l.color !== void 0 && h.fromArray(l.color); const d = l.range !== void 0 ? l.range : 0; switch (l.type) { case "directional": u = new RA(h), u.target.position.set(0, 0, -1), u.add(u.target); break; case "point": u = new PA(h), u.distance = d; break; case "spot": u = new BA(h), u.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, u.angle = l.spot.outerConeAngle, u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, u.target.position.set(0, 0, -1), u.add(u.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type) }return u.position.set(0, 0, 0), u.decay = 2, l.intensity !== void 0 && (u.intensity = l.intensity), u.name = t.createUniqueName(l.name || "light_" + e), r = Promise.resolve(u), t.cache.add(i, r), r } createNodeAttachment(e) { const t = this, i = this.parser, s = i.json.nodes[e], a = (s.extensions && s.extensions[this.name] || {}).light; return a === void 0 ? null : this._loadLight(a).then(function (l) { return i._getNodeRef(t.cache, a, l) }) } } class Zz { constructor() { this.name = At.KHR_MATERIALS_UNLIT } getMaterialType() { return Gi } extendParams(e, t, i) { const r = []; e.color = new Re(1, 1, 1), e.opacity = 1; const s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { const o = s.baseColorFactor; e.color.fromArray(o), e.opacity = o[3] } s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, St)) } return Promise.all(r) } } class $z { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name].emissiveStrength; return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve() } } class eU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) { const a = o.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new me(a, a) } return Promise.all(s) } } class tU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s) } } class nU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_SHEEN } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = []; t.sheenColor = new Re(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const o = r.extensions[this.name]; return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, St)), o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s) } } class iU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s) } } class rU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_VOLUME } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0; const a = o.attenuationColor || [1, 1, 1]; return t.attenuationColor = new Re(a[0], a[1], a[2]), Promise.all(s) } } class sU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_IOR } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name]; return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve() } } class oU { constructor(e) { this.parser = e, this.name = At.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : qs } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture)); const a = o.specularColorFactor || [1, 1, 1]; return t.specularColor = new Re(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, St)), Promise.all(s) } } class aU { constructor(e) { this.parser = e, this.name = At.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, i = t.json, r = i.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const s = r.extensions[this.name], o = t.options.ktx2Loader; if (!o) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s.source, o) } } class lU { constructor(e) { this.parser = e, this.name = At.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, i = this.parser, r = i.json, s = r.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const o = s.extensions[t], a = r.images[o.source]; let l = i.textureLoader; if (a.uri) { const u = i.options.manager.getHandler(a.uri); u !== null && (l = u) } return this.detectSupport().then(function (u) { if (u) return i.loadTextureImage(e, o.source, l); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return i.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class cU { constructor(e) { this.name = At.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { const r = i.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), o = this.parser.options.meshoptDecoder; if (!o || !o.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return s.then(function (a) { const l = r.byteOffset || 0, u = r.byteLength || 0, h = r.count, d = r.byteStride, p = new Uint8Array(a, l, u); return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, d, p, r.mode, r.filter).then(function (m) { return m.buffer }) : o.ready.then(function () { const m = new ArrayBuffer(h * d); return o.decodeGltfBuffer(new Uint8Array(m), h, d, p, r.mode, r.filter), m }) }) } else return null } } const s6 = "glTF", ju = 12, s4 = { JSON: 1313821514, BIN: 5130562 }; class uU { constructor(e) { this.name = At.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, ju); if (this.header = { magic: ss.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== s6) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const i = this.header.length - ju, r = new DataView(e, ju); let s = 0; for (; s < i;) { const o = r.getUint32(s, !0); s += 4; const a = r.getUint32(s, !0); if (s += 4, a === s4.JSON) { const l = new Uint8Array(e, ju + s, o); this.content = ss.decodeText(l) } else if (a === s4.BIN) { const l = ju + s; this.body = e.slice(l, l + o) } s += o } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class fU { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = At.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const i = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, u = {}; for (const h in o) { const d = T2[h] || h.toLowerCase(); a[d] = o[h] } for (const h in e.attributes) { const d = T2[h] || h.toLowerCase(); if (o[h] !== void 0) { const p = i.accessors[e.attributes[h]], m = nh[p.componentType]; u[d] = m.name, l[d] = p.normalized === !0 } } return t.getDependency("bufferView", s).then(function (h) { return new Promise(function (d) { r.decodeDracoFile(h, function (p) { for (const m in p.attributes) { const v = p.attributes[m], y = l[m]; y !== void 0 && (v.normalized = y) } d(p) }, a, u) }) }) } } class hU { constructor() { this.name = At.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class b2 extends $c {
  constructor(e) {
    super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`), i = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`), s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`), o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`), a = { specular: { value: new Re().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = a, this.onBeforeCompile = function (l) { for (const u in a) l.uniforms[u] = a[u]; l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o) }, Object.defineProperties(this, { specular: { get: function () { return a.specular.value }, set: function (l) { a.specular.value = l } }, specularMap: { get: function () { return a.specularMap.value }, set: function (l) { a.specularMap.value = l, l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return a.glossiness.value }, set: function (l) { a.glossiness.value = l } }, glossinessMap: { get: function () { return a.glossinessMap.value }, set: function (l) { a.glossinessMap.value = l, l ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
  } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }
} class dU { constructor() { this.name = At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return b2 } extendParams(e, t, i) { const r = t.extensions[this.name]; e.color = new Re(1, 1, 1), e.opacity = 1; const s = []; if (Array.isArray(r.diffuseFactor)) { const o = r.diffuseFactor; e.color.fromArray(o), e.opacity = o[3] } if (r.diffuseTexture !== void 0 && s.push(i.assignTexture(e, "map", r.diffuseTexture, St)), e.emissive = new Re(0, 0, 0), e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1, e.specular = new Re(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), r.specularGlossinessTexture !== void 0) { const o = r.specularGlossinessTexture; s.push(i.assignTexture(e, "glossinessMap", o)), s.push(i.assignTexture(e, "specularMap", o, St)) } return Promise.all(s) } createMaterial(e) { const t = new b2(e); return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = Ks, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class pU { constructor() { this.name = At.KHR_MESH_QUANTIZATION } } class o6 extends eu { constructor(e, t, i, r) { super(e, t, i, r) } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r * 3 + r; for (let o = 0; o !== r; o++)t[o] = i[s + o]; return t } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, u = a * 3, h = r - t, d = (i - t) / h, p = d * d, m = p * d, v = e * u, y = v - u, x = -2 * m + 3 * p, A = m - p, _ = 1 - x, M = A - p + d; for (let S = 0; S !== a; S++) { const b = o[y + S + a], B = o[y + S + l] * h, R = o[v + S + a], E = o[v + S] * h; s[S] = _ * b + M * B + x * R + A * E } return s } } const mU = new jn; class gU extends o6 { interpolate_(e, t, i, r) { const s = super.interpolate_(e, t, i, r); return mU.fromArray(s).normalize().toArray(s), s } } const Es = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, nh = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, o4 = { 9728: pn, 9729: tn, 9984: Wf, 9985: b0, 9986: Mc, 9987: ls }, a4 = { 33071: Hn, 33648: Lc, 10497: Wo }, l4 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, T2 = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, ho = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, yU = { CUBICSPLINE: void 0, LINEAR: il, STEP: Dc }, My = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function vU(n) { return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new $c({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: as })), n.DefaultMaterial } function Ju(n, e, t) { for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]) } function Ta(n, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function xU(n, e, t) { let i = !1, r = !1, s = !1; for (let u = 0, h = e.length; u < h; u++) { const d = e[u]; if (d.POSITION !== void 0 && (i = !0), d.NORMAL !== void 0 && (r = !0), d.COLOR_0 !== void 0 && (s = !0), i && r && s) break } if (!i && !r && !s) return Promise.resolve(n); const o = [], a = [], l = []; for (let u = 0, h = e.length; u < h; u++) { const d = e[u]; if (i) { const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : n.attributes.position; o.push(p) } if (r) { const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : n.attributes.normal; a.push(p) } if (s) { const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : n.attributes.color; l.push(p) } } return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (u) { const h = u[0], d = u[1], p = u[2]; return i && (n.morphAttributes.position = h), r && (n.morphAttributes.normal = d), s && (n.morphAttributes.color = p), n.morphTargetsRelative = !0, n }) } function AU(n, e) { if (n.updateMorphTargets(), e.weights !== void 0) for (let t = 0, i = e.weights.length; t < i; t++)n.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (n.morphTargetInfluences.length === t.length) { n.morphTargetDictionary = {}; for (let i = 0, r = t.length; i < r; i++)n.morphTargetDictionary[t[i]] = i } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function MU(n) { const e = n.extensions && n.extensions[At.KHR_DRACO_MESH_COMPRESSION]; let t; return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + c4(e.attributes) : t = n.indices + ":" + c4(n.attributes) + ":" + n.mode, t } function c4(n) { let e = ""; const t = Object.keys(n).sort(); for (let i = 0, r = t.length; i < r; i++)e += t[i] + ":" + n[t[i]] + ";"; return e } function B2(n) { switch (n) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function _U(n) { return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } class wU { constructor(e = {}, t = {}) { var i, r; this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Yz, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, o = typeof navigator < "u" && ((i = navigator.userAgent) === null || i === void 0 ? void 0 : i.indexOf("Firefox")) > -1, a = typeof navigator < "u" && o ? (r = navigator.userAgent) === null || r === void 0 ? void 0 : r.match(/Firefox\/([0-9]+)\./)[1] : -1; typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new Ih(this.options.manager) : this.textureLoader = new RT(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ji(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const i = this, r = this.json, s = this.extensions; this.cache.removeAll(), this._invokeAll(function (o) { return o._markDefs && o._markDefs() }), Promise.all(this._invokeAll(function (o) { return o.beforeRoot && o.beforeRoot() })).then(function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) }).then(function (o) { const a = { scene: o[0][r.scene || 0], scenes: o[0], animations: o[1], cameras: o[2], asset: r.asset, parser: i, userData: {} }; Ju(s, a, r), Ta(a, r), Promise.all(i._invokeAll(function (l) { return l.afterRoot && l.afterRoot(a) })).then(function () { e(a) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || []; for (let r = 0, s = t.length; r < s; r++) { const o = t[r].joints; for (let a = 0, l = o.length; a < l; a++)e[o[a]].isBone = !0 } for (let r = 0, s = e.length; r < s; r++) { const o = e[r]; o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, i) { if (e.refs[t] <= 1) return i; const r = i.clone(), s = (o, a) => { const l = this.associations.get(o); l != null && this.associations.set(a, l); for (const [u, h] of o.children.entries()) s(h, a.children[u]) }; return s(i, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let i = 0; i < t.length; i++) { const r = e(t[i]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const i = []; for (let r = 0; r < t.length; r++) { const s = e(t[r]); s && i.push(s) } return i } getDependency(e, t) { const i = e + ":" + t; let r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (s) { return s.loadMesh && s.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (s) { return s.loadBufferView && s.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (s) { return s.loadMaterial && s.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (s) { return s.loadTexture && s.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this._invokeOne(function (s) { return s.loadAnimation && s.loadAnimation(t) }); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const i = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(r.map(function (s, o) { return i.getDependency(e, o) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], i = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[At.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (s, o) { i.load(ss.resolveURL(t.uri, r.path), s, void 0, function () { o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (i) { const r = t.byteLength || 0, s = t.byteOffset || 0; return i.slice(s, s + r) }) } loadAccessor(e) { const t = this, i = this.json, r = this.json.accessors[e]; if (r.bufferView === void 0 && r.sparse === void 0) return Promise.resolve(null); const s = []; return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (o) { const a = o[0], l = l4[r.type], u = nh[r.componentType], h = u.BYTES_PER_ELEMENT, d = h * l, p = r.byteOffset || 0, m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0, v = r.normalized === !0; let y, x; if (m && m !== d) { const A = Math.floor(p / m), _ = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + A + ":" + r.count; let M = t.cache.get(_); M || (y = new u(a, A * m, r.count * m / h), M = new vh(y, m / h), t.cache.add(_, M)), x = new jo(M, l, p % m / h, v) } else a === null ? y = new u(r.count * l) : y = new u(a, p, r.count * l), x = new It(y, l, v); if (r.sparse !== void 0) { const A = l4.SCALAR, _ = nh[r.sparse.indices.componentType], M = r.sparse.indices.byteOffset || 0, S = r.sparse.values.byteOffset || 0, b = new _(o[1], M, r.sparse.count * A), B = new u(o[2], S, r.sparse.count * l); a !== null && (x = new It(x.array.slice(), x.itemSize, x.normalized)); for (let R = 0, E = b.length; R < E; R++) { const P = b[R]; if (x.setX(P, B[R * l]), l >= 2 && x.setY(P, B[R * l + 1]), l >= 3 && x.setZ(P, B[R * l + 2]), l >= 4 && x.setW(P, B[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return x }) } loadTexture(e) { const t = this.json, i = this.options, s = t.textures[e].source, o = t.images[s]; let a = this.textureLoader; if (o.uri) { const l = i.manager.getHandler(o.uri); l !== null && (a = l) } return this.loadTextureImage(e, s, a) } loadTextureImage(e, t, i) { const r = this, s = this.json, o = s.textures[e], a = s.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler; if (this.textureCache[l]) return this.textureCache[l]; const u = this.loadImageSource(t, i).then(function (h) { h.flipY = !1, o.name && (h.name = o.name); const p = (s.samplers || {})[o.sampler] || {}; return h.magFilter = o4[p.magFilter] || tn, h.minFilter = o4[p.minFilter] || ls, h.wrapS = a4[p.wrapS] || Wo, h.wrapT = a4[p.wrapT] || Wo, r.associations.set(h, { textures: e }), h }).catch(function () { return null }); return this.textureCache[l] = u, u } loadImageSource(e, t) { const i = this, r = this.json, s = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(d => d.clone()); const o = r.images[e], a = self.URL || self.webkitURL; let l = o.uri || "", u = !1; if (o.bufferView !== void 0) l = i.getDependency("bufferView", o.bufferView).then(function (d) { u = !0; const p = new Blob([d], { type: o.mimeType }); return l = a.createObjectURL(p), l }); else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const h = Promise.resolve(l).then(function (d) { return new Promise(function (p, m) { let v = p; t.isImageBitmapLoader === !0 && (v = function (y) { const x = new Zt(y); x.needsUpdate = !0, p(x) }), t.load(ss.resolveURL(d, s.path), v, void 0, m) }) }).then(function (d) { return u === !0 && a.revokeObjectURL(l), d.userData.mimeType = o.mimeType || _U(o.uri), d }).catch(function (d) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d }); return this.sourceCache[e] = h, h } assignTexture(e, t, i, r) { const s = this; return this.getDependency("texture", i.index).then(function (o) { if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), s.extensions[At.KHR_TEXTURE_TRANSFORM]) { const a = i.extensions !== void 0 ? i.extensions[At.KHR_TEXTURE_TRANSFORM] : void 0; if (a) { const l = s.associations.get(o); o = s.extensions[At.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l) } } return r !== void 0 && (o.encoding = r), e[t] = o, o }) } assignFinalMaterial(e) { const t = e.geometry; let i = e.material; const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0; if (e.isPoints) { const a = "PointsMaterial:" + i.uuid; let l = this.cache.get(a); l || (l = new Ah, En.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l } else if (e.isLine) { const a = "LineBasicMaterial:" + i.uuid; let l = this.cache.get(a); l || (l = new oi, En.prototype.copy.call(l, i), l.color.copy(i.color), this.cache.add(a, l)), i = l } if (r || s || o) { let a = "ClonedMaterial:" + i.uuid + ":"; i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"), r && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:"); let l = this.cache.get(a); l || (l = i.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l } i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = i } getMaterialType() { return $c } loadMaterial(e) { const t = this, i = this.json, r = this.extensions, s = i.materials[e]; let o; const a = {}, l = s.extensions || {}, u = []; if (l[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const d = r[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; o = d.getMaterialType(), u.push(d.extendParams(a, s, t)) } else if (l[At.KHR_MATERIALS_UNLIT]) { const d = r[At.KHR_MATERIALS_UNLIT]; o = d.getMaterialType(), u.push(d.extendParams(a, s, t)) } else { const d = s.pbrMetallicRoughness || {}; if (a.color = new Re(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) { const p = d.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } d.baseColorTexture !== void 0 && u.push(t.assignTexture(a, "map", d.baseColorTexture, St)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (u.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), u.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function (p) { return p.getMaterialType && p.getMaterialType(e) }), u.push(Promise.all(this._invokeAll(function (p) { return p.extendMaterialParams && p.extendMaterialParams(e, a) }))) } s.doubleSided === !0 && (a.side = Lr); const h = s.alphaMode || My.OPAQUE; if (h === My.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === My.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== Gi && (u.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new me(1, 1), s.normalTexture.scale !== void 0)) { const d = s.normalTexture.scale; a.normalScale.set(d, d) } return s.occlusionTexture !== void 0 && o !== Gi && (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== Gi && (a.emissive = new Re().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== Gi && u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, St)), Promise.all(u).then(function () { let d; return o === b2 ? d = r[At.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : d = new o(a), s.name && (d.name = s.name), Ta(d, s), t.associations.set(d, { materials: e }), s.extensions && Ju(r, d, s), d }) } createUniqueName(e) { const t = Et.sanitizeNodeName(e || ""); let i = t; for (let r = 1; this.nodeNamesUsed[i]; ++r)i = t + "_" + r; return this.nodeNamesUsed[i] = !0, i } loadGeometries(e) { const t = this, i = this.extensions, r = this.primitiveCache; function s(a) { return i[At.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) { return u4(l, a, t) }) } const o = []; for (let a = 0, l = e.length; a < l; a++) { const u = e[a], h = MU(u), d = r[h]; if (d) o.push(d.promise); else { let p; u.extensions && u.extensions[At.KHR_DRACO_MESH_COMPRESSION] ? p = s(u) : p = u4(new ut, u, t), r[h] = { primitive: u, promise: p }, o.push(p) } } return Promise.all(o) } loadMesh(e) { const t = this, i = this.json, r = this.extensions, s = i.meshes[e], o = s.primitives, a = []; for (let l = 0, u = o.length; l < u; l++) { const h = o[l].material === void 0 ? vU(this.cache) : this.getDependency("material", o[l].material); a.push(h) } return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) { const u = l.slice(0, l.length - 1), h = l[l.length - 1], d = []; for (let m = 0, v = h.length; m < v; m++) { const y = h[m], x = o[m]; let A; const _ = u[m]; if (x.mode === Es.TRIANGLES || x.mode === Es.TRIANGLE_STRIP || x.mode === Es.TRIANGLE_FAN || x.mode === void 0) A = s.isSkinnedMesh === !0 ? new dA(y, _) : new Pn(y, _), A.isSkinnedMesh === !0 && !A.geometry.attributes.skinWeight.normalized && A.normalizeSkinWeights(), x.mode === Es.TRIANGLE_STRIP ? A.geometry = f4(A.geometry, I5) : x.mode === Es.TRIANGLE_FAN && (A.geometry = f4(A.geometry, Zx)); else if (x.mode === Es.LINES) A = new zr(y, _); else if (x.mode === Es.LINE_STRIP) A = new Xs(y, _); else if (x.mode === Es.LINE_LOOP) A = new pA(y, _); else if (x.mode === Es.POINTS) A = new mA(y, _); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode); Object.keys(A.geometry.morphAttributes).length > 0 && AU(A, s), A.name = t.createUniqueName(s.name || "mesh_" + e), Ta(A, s), x.extensions && Ju(r, A, x), t.assignFinalMaterial(A), d.push(A) } for (let m = 0, v = d.length; m < v; m++)t.associations.set(d[m], { meshes: e, primitives: m }); if (d.length === 1) return d[0]; const p = new Fs; t.associations.set(p, { meshes: e }); for (let m = 0, v = d.length; m < v; m++)p.add(d[m]); return p }) } loadCamera(e) { let t; const i = this.json.cameras[e], r = i[i.type]; if (!r) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return i.type === "perspective" ? t = new Ut(tA.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new kr(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Ta(t, i), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], i = { joints: t.joints }; return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function (r) { return i.inverseBindMatrices = r, i }) } loadAnimation(e) { const i = this.json.animations[e], r = [], s = [], o = [], a = [], l = []; for (let u = 0, h = i.channels.length; u < h; u++) { const d = i.channels[u], p = i.samplers[d.sampler], m = d.target, v = m.node, y = i.parameters !== void 0 ? i.parameters[p.input] : p.input, x = i.parameters !== void 0 ? i.parameters[p.output] : p.output; r.push(this.getDependency("node", v)), s.push(this.getDependency("accessor", y)), o.push(this.getDependency("accessor", x)), a.push(p), l.push(m) } return Promise.all([Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (u) { const h = u[0], d = u[1], p = u[2], m = u[3], v = u[4], y = []; for (let A = 0, _ = h.length; A < _; A++) { const M = h[A], S = d[A], b = p[A], B = m[A], R = v[A]; if (M === void 0) continue; M.updateMatrix(); let E; switch (ho[R.path]) { case ho.weights: E = Oc; break; case ho.rotation: E = Jo; break; case ho.position: case ho.scale: default: E = zc; break }const P = M.name ? M.name : M.uuid, L = B.interpolation !== void 0 ? yU[B.interpolation] : il, z = []; ho[R.path] === ho.weights ? M.traverse(function (J) { J.morphTargetInfluences && z.push(J.name ? J.name : J.uuid) }) : z.push(P); let Z = b.array; if (b.normalized) { const J = B2(Z.constructor), V = new Float32Array(Z.length); for (let K = 0, ee = Z.length; K < ee; K++)V[K] = Z[K] * J; Z = V } for (let J = 0, V = z.length; J < V; J++) { const K = new E(z[J] + "." + ho[R.path], S.array, Z, L); B.interpolation === "CUBICSPLINE" && (K.createInterpolant = function (le) { const N = this instanceof Jo ? gU : o6; return new N(this.times, this.values, this.getValueSize() / 3, le) }, K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(K) } } const x = i.name ? i.name : "animation_" + e; return new Uc(x, void 0, y) }) } createNodeMesh(e) { const t = this.json, i = this, r = t.nodes[e]; return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function (s) { const o = i._getNodeRef(i.meshCache, r.mesh, s); return r.weights !== void 0 && o.traverse(function (a) { if (a.isMesh) for (let l = 0, u = r.weights.length; l < u; l++)a.morphTargetInfluences[l] = r.weights[l] }), o }) } loadNode(e) { const t = this.json, i = this.extensions, r = this, s = t.nodes[e], o = s.name ? r.createUniqueName(s.name) : ""; return function () { const a = [], l = r._invokeOne(function (u) { return u.createNodeMesh && u.createNodeMesh(e) }); return l && a.push(l), s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function (u) { return r._getNodeRef(r.cameraCache, s.camera, u) })), r._invokeAll(function (u) { return u.createNodeAttachment && u.createNodeAttachment(e) }).forEach(function (u) { a.push(u) }), Promise.all(a) }().then(function (a) { let l; if (s.isBone === !0 ? l = new F0 : a.length > 1 ? l = new Fs : a.length === 1 ? l = a[0] : l = new bt, l !== a[0]) for (let u = 0, h = a.length; u < h; u++)l.add(a[u]); if (s.name && (l.userData.name = s.name, l.name = o), Ta(l, s), s.extensions && Ju(i, l, s), s.matrix !== void 0) { const u = new st; u.fromArray(s.matrix), l.applyMatrix4(u) } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale); return r.associations.has(l) || r.associations.set(l, {}), r.associations.get(l).nodes = e, l }) } loadScene(e) { const t = this.json, i = this.extensions, r = this.json.scenes[e], s = this, o = new Fs; r.name && (o.name = s.createUniqueName(r.name)), Ta(o, r), r.extensions && Ju(i, o, r); const a = r.nodes || [], l = []; for (let u = 0, h = a.length; u < h; u++)l.push(a6(a[u], o, t, s)); return Promise.all(l).then(function () { const u = h => { const d = new Map; for (const [p, m] of s.associations) (p instanceof En || p instanceof Zt) && d.set(p, m); return h.traverse(p => { const m = s.associations.get(p); m != null && d.set(p, m) }), d }; return s.associations = u(o), o }) } } function a6(n, e, t, i) { const r = t.nodes[n]; return i.getDependency("node", n).then(function (s) { if (r.skin === void 0) return s; let o; return i.getDependency("skin", r.skin).then(function (a) { o = a; const l = []; for (let u = 0, h = o.joints.length; u < h; u++)l.push(i.getDependency("node", o.joints[u])); return Promise.all(l) }).then(function (a) { return s.traverse(function (l) { if (!l.isMesh) return; const u = [], h = []; for (let d = 0, p = a.length; d < p; d++) { const m = a[d]; if (m) { u.push(m); const v = new st; o.inverseBindMatrices !== void 0 && v.fromArray(o.inverseBindMatrices.array, d * 16), h.push(v) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[d]) } l.bind(new xh(u, h), l.matrixWorld) }), s }) }).then(function (s) { e.add(s); const o = []; if (r.children) { const a = r.children; for (let l = 0, u = a.length; l < u; l++) { const h = a[l]; o.push(a6(h, s, t, i)) } } return Promise.all(o) }) } function SU(n, e, t) { const i = e.attributes, r = new Zo; if (i.POSITION !== void 0) { const a = t.json.accessors[i.POSITION], l = a.min, u = a.max; if (l !== void 0 && u !== void 0) { if (r.set(new D(l[0], l[1], l[2]), new D(u[0], u[1], u[2])), a.normalized) { const h = B2(nh[a.componentType]); r.min.multiplyScalar(h), r.max.multiplyScalar(h) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const s = e.targets; if (s !== void 0) { const a = new D, l = new D; for (let u = 0, h = s.length; u < h; u++) { const d = s[u]; if (d.POSITION !== void 0) { const p = t.json.accessors[d.POSITION], m = p.min, v = p.max; if (m !== void 0 && v !== void 0) { if (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))), p.normalized) { const y = B2(nh[p.componentType]); l.multiplyScalar(y) } a.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(a) } n.boundingBox = r; const o = new $o; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, n.boundingSphere = o } function u4(n, e, t) { const i = e.attributes, r = []; function s(o, a) { return t.getDependency("accessor", o).then(function (l) { n.setAttribute(a, l) }) } for (const o in i) { const a = T2[o] || o.toLowerCase(); a in n.attributes || r.push(s(i[o], a)) } if (e.indices !== void 0 && !n.index) { const o = t.getDependency("accessor", e.indices).then(function (a) { n.setIndex(a) }); r.push(o) } return Ta(n, e), SU(n, e, t), Promise.all(r).then(function () { return e.targets !== void 0 ? xU(n, e.targets, t) : n }) } function f4(n, e) { let t = n.getIndex(); if (t === null) { const o = [], a = n.getAttribute("position"); if (a !== void 0) { for (let l = 0; l < a.count; l++)o.push(l); n.setIndex(o), t = n.getIndex() } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n } const i = t.count - 2, r = []; if (e === Zx) for (let o = 1; o <= i; o++)r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)); else for (let o = 0; o < i; o++)o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o))); r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = n.clone(); return s.setIndex(r), s } class CU extends ut { constructor(e, t, i, r) { super(); const s = [], o = [], a = [], l = new D, u = new st; u.makeRotationFromEuler(i), u.setPosition(t); const h = new st; h.copy(u).invert(), d(), this.setAttribute("position", new je(s, 3)), this.setAttribute("normal", new je(o, 3)), this.setAttribute("uv", new je(a, 2)); function d() { let y, x = []; const A = new D, _ = new D; if (e.geometry.isGeometry === !0) { console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead."); return } const M = e.geometry, S = M.attributes.position, b = M.attributes.normal; if (M.index !== null) { const B = M.index; for (y = 0; y < B.count; y++)A.fromBufferAttribute(S, B.getX(y)), _.fromBufferAttribute(b, B.getX(y)), p(x, A, _) } else for (y = 0; y < S.count; y++)A.fromBufferAttribute(S, y), _.fromBufferAttribute(b, y), p(x, A, _); for (x = m(x, l.set(1, 0, 0)), x = m(x, l.set(-1, 0, 0)), x = m(x, l.set(0, 1, 0)), x = m(x, l.set(0, -1, 0)), x = m(x, l.set(0, 0, 1)), x = m(x, l.set(0, 0, -1)), y = 0; y < x.length; y++) { const B = x[y]; a.push(.5 + B.position.x / r.x, .5 + B.position.y / r.y), B.position.applyMatrix4(u), s.push(B.position.x, B.position.y, B.position.z), o.push(B.normal.x, B.normal.y, B.normal.z) } } function p(y, x, A) { x.applyMatrix4(e.matrixWorld), x.applyMatrix4(h), A.transformDirection(e.matrixWorld), y.push(new h4(x.clone(), A.clone())) } function m(y, x) { const A = [], _ = .5 * Math.abs(r.dot(x)); for (let M = 0; M < y.length; M += 3) { let S, b, B, R = 0, E, P, L, z; const Z = y[M + 0].position.dot(x) - _, J = y[M + 1].position.dot(x) - _, V = y[M + 2].position.dot(x) - _; switch (S = Z > 0, b = J > 0, B = V > 0, R = (S ? 1 : 0) + (b ? 1 : 0) + (B ? 1 : 0), R) { case 0: { A.push(y[M]), A.push(y[M + 1]), A.push(y[M + 2]); break } case 1: { if (S && (E = y[M + 1], P = y[M + 2], L = v(y[M], E, x, _), z = v(y[M], P, x, _)), b) { E = y[M], P = y[M + 2], L = v(y[M + 1], E, x, _), z = v(y[M + 1], P, x, _), A.push(L), A.push(P.clone()), A.push(E.clone()), A.push(P.clone()), A.push(L.clone()), A.push(z); break } B && (E = y[M], P = y[M + 1], L = v(y[M + 2], E, x, _), z = v(y[M + 2], P, x, _)), A.push(E.clone()), A.push(P.clone()), A.push(L), A.push(z), A.push(L.clone()), A.push(P.clone()); break } case 2: { S || (E = y[M].clone(), P = v(E, y[M + 1], x, _), L = v(E, y[M + 2], x, _), A.push(E), A.push(P), A.push(L)), b || (E = y[M + 1].clone(), P = v(E, y[M + 2], x, _), L = v(E, y[M], x, _), A.push(E), A.push(P), A.push(L)), B || (E = y[M + 2].clone(), P = v(E, y[M], x, _), L = v(E, y[M + 1], x, _), A.push(E), A.push(P), A.push(L)); break } } } return A } function v(y, x, A, _) { const M = y.position.dot(A) - _, S = x.position.dot(A) - _, b = M / (M - S); return new h4(new D(y.position.x + b * (x.position.x - y.position.x), y.position.y + b * (x.position.y - y.position.y), y.position.z + b * (x.position.z - y.position.z)), new D(y.normal.x + b * (x.normal.x - y.normal.x), y.normal.y + b * (x.normal.y - y.normal.y), y.normal.z + b * (x.normal.z - y.normal.z))) } } } class h4 { constructor(e, t) { this.position = e, this.normal = t } clone() { return new this.constructor(this.position.clone(), this.normal.clone()) } } const _y = new WeakMap; class EU extends vi {
  constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, i, r) { const s = new ji(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => { const a = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(o, a).then(t).catch(r) }, i, r) } decodeDracoFile(e, t, i, r) { const s = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!i }; this.decodeGeometry(e, s).then(t) } decodeGeometry(e, t) { for (const l in t.attributeTypes) { const u = t.attributeTypes[l]; u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name) } const i = JSON.stringify(t); if (_y.has(e)) { const l = _y.get(e); if (l.key === i) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const s = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(s, o).then(l => (r = l, new Promise((u, h) => { r._callbacks[s] = { resolve: u, reject: h }, r.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { r && s && this._releaseTask(r, s) }), _y.set(e, { key: i, promise: a }), a } _createGeometry(e) { const t = new ut; e.index && t.setIndex(new It(e.index.array, 1)); for (let i = 0; i < e.attributes.length; i++) { const r = e.attributes[i], s = r.name, o = r.array, a = r.itemSize; t.setAttribute(s, new It(o, a)) } return t } _loadLibrary(e, t) { const i = new ji(this.manager); return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((r, s) => { i.load(e, r, void 0, s) }) } preload() { return this._initDecoder(), this } _initDecoder() {
    if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(i => {
      const r = i[0]; e || (this.decoderConfig.wasmBinary = i[1]); const s = bU.toString(), o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o]))
    }), this.decoderPending
  } _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const r = new Worker(this.workerSourceURL); r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function (s) { const o = s.data; switch (o.type) { case "decode": r._callbacks[o.id].resolve(o); break; case "error": r._callbacks[o.id].reject(o); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"') } }, this.workerPool.push(r) } else this.workerPool.sort(function (r, s) { return r._taskLoad > s._taskLoad ? -1 : 1 }); const i = this.workerPool[this.workerPool.length - 1]; return i._taskCosts[e] = t, i._taskLoad += t, i }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
} function bU() { let n, e; onmessage = function (o) { const a = o.data; switch (a.type) { case "init": n = a.decoderConfig, e = new Promise(function (h) { n.onModuleLoaded = function (d) { h({ draco: d }) }, DracoDecoderModule(n) }); break; case "decode": const l = a.buffer, u = a.taskConfig; e.then(h => { const d = h.draco, p = new d.Decoder, m = new d.DecoderBuffer; m.Init(new Int8Array(l), l.byteLength); try { const v = t(d, p, m, u), y = v.attributes.map(x => x.array.buffer); v.index && y.push(v.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: v }, y) } catch (v) { console.error(v), self.postMessage({ type: "error", id: a.id, error: v.message }) } finally { d.destroy(m), d.destroy(p) } }); break } }; function t(o, a, l, u) { const h = u.attributeIDs, d = u.attributeTypes; let p, m; const v = a.GetEncodedGeometryType(l); if (v === o.TRIANGULAR_MESH) p = new o.Mesh, m = a.DecodeBufferToMesh(l, p); else if (v === o.POINT_CLOUD) p = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, p); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg()); const y = { index: null, attributes: [] }; for (const x in h) { const A = self[d[x]]; let _, M; if (u.useUniqueIDs) M = h[x], _ = a.GetAttributeByUniqueId(p, M); else { if (M = a.GetAttributeId(p, o[h[x]]), M === -1) continue; _ = a.GetAttribute(p, M) } y.attributes.push(r(o, a, p, x, A, _)) } return v === o.TRIANGULAR_MESH && (y.index = i(o, a, p)), o.destroy(p), y } function i(o, a, l) { const h = l.num_faces() * 3, d = h * 4, p = o._malloc(d); a.GetTrianglesUInt32Array(l, d, p); const m = new Uint32Array(o.HEAPF32.buffer, p, h).slice(); return o._free(p), { array: m, itemSize: 1 } } function r(o, a, l, u, h, d) { const p = d.num_components(), v = l.num_points() * p, y = v * h.BYTES_PER_ELEMENT, x = s(o, h), A = o._malloc(y); a.GetAttributeDataArrayForAllPoints(l, d, x, y, A); const _ = new h(o.HEAPF32.buffer, A, v).slice(); return o._free(A), { name: u, array: _, itemSize: p } } function s(o, a) { switch (a) { case Float32Array: return o.DT_FLOAT32; case Int8Array: return o.DT_INT8; case Int16Array: return o.DT_INT16; case Int32Array: return o.DT_INT32; case Uint8Array: return o.DT_UINT8; case Uint16Array: return o.DT_UINT16; case Uint32Array: return o.DT_UINT32 } } } let Up; const wy = () => { if (Up) return Up; const n = "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", e = "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", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), i = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if (typeof WebAssembly != "object") return { supported: !1 }; let r = n; WebAssembly.validate(t) && (r = e); let s; const o = WebAssembly.instantiate(a(r), {}).then(d => { s = d.instance, s.exports.__wasm_call_ctors() }); function a(d) { const p = new Uint8Array(d.length); for (let v = 0; v < d.length; ++v) { const y = d.charCodeAt(v); p[v] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62 } let m = 0; for (let v = 0; v < d.length; ++v)p[m++] = p[v] < 60 ? i[p[v]] : (p[v] - 60) * 64 + p[++v]; return p.buffer.slice(0, m) } function l(d, p, m, v, y, x) { const A = s.exports.sbrk, _ = m + 3 & -4, M = A(_ * v), S = A(y.length), b = new Uint8Array(s.exports.memory.buffer); b.set(y, S); const B = d(M, m, v, S, y.length); if (B === 0 && x && x(M, _, v), p.set(b.subarray(M, M + m * v)), A(M - A(0)), B !== 0) throw new Error(`Malformed buffer data: ${B}`) } const u = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, h = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return Up = { ready: o, supported: !0, decodeVertexBuffer(d, p, m, v, y) { l(s.exports.meshopt_decodeVertexBuffer, d, p, m, v, s.exports[u[y]]) }, decodeIndexBuffer(d, p, m, v) { l(s.exports.meshopt_decodeIndexBuffer, d, p, m, v) }, decodeIndexSequence(d, p, m, v) { l(s.exports.meshopt_decodeIndexSequence, d, p, m, v) }, decodeGltfBuffer(d, p, m, v, y, x) { l(s.exports[h[y]], d, p, m, v, s.exports[u[x]]) } }, Up }, d4 = n => n === Object(n) && !Array.isArray(n) && typeof n != "function"; function HA(n, e) { const t = zi(r => r.gl), i = na(Ih, d4(n) ? Object.values(n) : n); if (U.useLayoutEffect(() => { e == null || e(i) }, [e]), U.useEffect(() => { (Array.isArray(i) ? i : [i]).forEach(t.initTexture) }, [t, i]), d4(n)) { const r = Object.keys(n), s = {}; return r.forEach(o => Object.assign(s, { [o]: i[r.indexOf(o)] })), s } else return i } HA.preload = n => na.preload(Ih, n); HA.clear = n => na.clear(Ih, n); function TU(n) { return Array.isArray(n) } function Sy(n = [0, 0, 0]) { return TU(n) ? n : n instanceof D || n instanceof ll ? [n.x, n.y, n.z] : [n, n, n] } function BU({ debug: n, mesh: e, children: t, position: i, rotation: r, scale: s, ...o }) { const a = U.useRef(null), l = U.useRef(null); return U.useLayoutEffect(() => { const u = (e == null ? void 0 : e.current) || a.current.parent, h = a.current; if (!(u instanceof Pn)) throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop'); const d = { position: new D, rotation: new ll, scale: new D(1, 1, 1) }; if (u) { To(d, { position: i, scale: s }); const p = u.matrixWorld.clone(); if (u.matrixWorld.identity(), !r || typeof r == "number") { const m = new bt; m.position.copy(d.position), m.lookAt(u.position), typeof r == "number" && m.rotateZ(r), To(d, { rotation: m.rotation }) } else To(d, { rotation: r }); return h.geometry = new CU(u, d.position, d.rotation, d.scale), l.current && To(l.current, d), u.matrixWorld = p, () => { h.geometry.dispose() } } }, [e, ...Sy(i), ...Sy(s), ...Sy(r)]), U.createElement("mesh", { ref: a }, t || U.createElement("meshStandardMaterial", yr({ transparent: !0, polygonOffset: !0, polygonOffsetFactor: -10 }, o)), n && U.createElement("mesh", { ref: l }, U.createElement("boxGeometry", null), U.createElement("meshNormalMaterial", { wireframe: !0 }), U.createElement("axesHelper", null))) } let Gp = null; function l6(n, e, t) { return i => { t && t(i), n && (Gp || (Gp = new EU), Gp.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"), i.setDRACOLoader(Gp)), e && i.setMeshoptDecoder(typeof wy == "function" ? wy() : wy) } } function H0(n, e = !0, t = !0, i) { return na(GA, n, l6(e, t, i)) } H0.preload = (n, e = !0, t = !0, i) => na.preload(GA, n, l6(e, t, i)); H0.clear = n => na.clear(GA, n); const VA = U.forwardRef(({ makeDefault: n, camera: e, regress: t, domElement: i, enableDamping: r = !0, onChange: s, onStart: o, onEnd: a, ...l }, u) => { const h = zi(b => b.invalidate), d = zi(b => b.camera), p = zi(b => b.gl), m = zi(b => b.events), v = zi(b => b.setEvents), y = zi(b => b.set), x = zi(b => b.get), A = zi(b => b.performance), _ = e || d, M = i || m.connected || p.domElement, S = U.useMemo(() => new Kz(_), [_]); return tu(() => { S.enabled && S.update() }, -1), U.useEffect(() => (S.connect(M), () => void S.dispose()), [M, t, S, h]), U.useEffect(() => { const b = E => { h(), t && A.regress(), s && s(E) }, B = E => { o && o(E) }, R = E => { a && a(E) }; return S.addEventListener("change", b), S.addEventListener("start", B), S.addEventListener("end", R), () => { S.removeEventListener("start", B), S.removeEventListener("end", R), S.removeEventListener("change", b) } }, [s, o, a, S, h, v]), U.useEffect(() => { if (n) { const b = x().controls; return y({ controls: S }), () => y({ controls: b }) } }, [n, S]), U.createElement("primitive", yr({ ref: u, object: S, enableDamping: r }, l)) }); class PU extends Ah {
  constructor(e) {
    super(e), this.onBeforeCompile = (t, i) => {
      const { isWebGL2: r } = i.capabilities; t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${r ? "#include <output_fragment>" : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `)
    }
  }
} const RU = U.forwardRef((n, e) => { const [t] = U.useState(() => new PU(null)); return U.createElement("primitive", yr({}, n, { object: t, ref: e, attach: "material" })) }), LU = U.forwardRef(({ children: n, speed: e = 1, rotationIntensity: t = 1, floatIntensity: i = 1, floatingRange: r = [-.1, .1], ...s }, o) => { const a = U.useRef(null), l = U.useRef(Math.random() * 1e4); return tu(u => { var h, d; const p = l.current + u.clock.getElapsedTime(); a.current.rotation.x = Math.cos(p / 4 * e) / 8 * t, a.current.rotation.y = Math.sin(p / 4 * e) / 8 * t, a.current.rotation.z = Math.sin(p / 4 * e) / 20 * t; let m = Math.sin(p / 4 * e) / 10; m = tA.mapLinear(m, -.1, .1, (h = r == null ? void 0 : r[0]) !== null && h !== void 0 ? h : -.1, (d = r == null ? void 0 : r[1]) !== null && d !== void 0 ? d : .1), a.current.position.y = m * i }), U.createElement("group", s, U.createElement("group", { ref: UA([a, o]) }, n)) }); let Ma, Xu; const IU = U.createContext(null), p4 = new st, m4 = new D, DU = U.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => { const s = U.useRef(null), [o, a] = U.useState([]), [[l, u, h]] = U.useState(() => [new Float32Array(t * 3), Float32Array.from({ length: t * 3 }, () => 1), Float32Array.from({ length: t }, () => 1)]); U.useEffect(() => { s.current.geometry.attributes.position.needsUpdate = !0 }), tu(() => { for (s.current.updateMatrix(), s.current.updateMatrixWorld(), p4.copy(s.current.matrixWorld).invert(), s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, o.length), Ma = 0; Ma < o.length; Ma++)Xu = o[Ma].current, Xu.getWorldPosition(m4).applyMatrix4(p4), m4.toArray(l, Ma * 3), s.current.geometry.attributes.position.needsUpdate = !0, Xu.matrixWorldNeedsUpdate = !0, Xu.color.toArray(u, Ma * 3), s.current.geometry.attributes.color.needsUpdate = !0, h.set([Xu.size], Ma), s.current.geometry.attributes.size.needsUpdate = !0 }); const d = U.useMemo(() => ({ getParent: () => s, subscribe: p => (a(m => [...m, p]), () => a(m => m.filter(v => v.current !== p.current))) }), []); return U.createElement("points", yr({ userData: { instances: o }, matrixAutoUpdate: !1, ref: UA([r, s]), raycast: () => null }, i), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", { attach: "attributes-position", count: l.length / 3, array: l, itemSize: 3, usage: Xa }), U.createElement("bufferAttribute", { attach: "attributes-color", count: u.length / 3, array: u, itemSize: 3, usage: Xa }), U.createElement("bufferAttribute", { attach: "attributes-size", count: h.length, array: h, itemSize: 1, usage: Xa })), U.createElement(IU.Provider, { value: d }, n)) }), FU = U.forwardRef(({ children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s }, o) => { const a = U.useRef(null); return tu(() => { const l = a.current.geometry.attributes; l.position.needsUpdate = !0, t && (l.color.needsUpdate = !0), i && (l.size.needsUpdate = !0) }), U.createElement("points", yr({ ref: UA([o, a]) }, s), U.createElement("bufferGeometry", null, U.createElement("bufferAttribute", { attach: "attributes-position", count: e.length / r, array: e, itemSize: r, usage: Xa }), t && U.createElement("bufferAttribute", { attach: "attributes-color", count: t.length / r, array: t, itemSize: 3, usage: Xa }), i && U.createElement("bufferAttribute", { attach: "attributes-size", count: i.length / r, array: i, itemSize: 1, usage: Xa })), n) }), kU = U.forwardRef((n, e) => n.positions instanceof Float32Array ? U.createElement(FU, yr({}, n, { ref: e })) : U.createElement(DU, yr({}, n, { ref: e }))); var jm = {}, NU = { get exports() { return jm }, set exports(n) { jm = n } }, OU = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", zU = OU, UU = zU; function c6() { } function u6() { } u6.resetWarningCache = c6; var GU = function () { function n(i, r, s, o, a, l) { if (l !== UU) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } n.isRequired = n; function e() { return n } var t = { array: n, bigint: n, bool: n, func: n, number: n, object: n, string: n, symbol: n, any: n, arrayOf: e, element: n, elementType: n, instanceOf: e, node: n, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: u6, resetWarningCache: c6 }; return t.PropTypes = t, t }; NU.exports = GU(); function V0({ all: n, scene: e, camera: t }) { const i = zi(({ gl: o }) => o), r = zi(({ camera: o }) => o), s = zi(({ scene: o }) => o); return U.useLayoutEffect(() => { const o = []; n && (e || s).traverse(u => { u.visible === !1 && (o.push(u), u.visible = !0) }), i.compile(e || s, t || r); const a = new aA(128); new oA(.01, 1e5, a).update(i, e || s), a.dispose(), o.forEach(u => u.visible = !1) }, []), null } const WA = () => { const { progress: n } = zz(); return it(Oz, { as: "div", center: !0, style: { display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" }, children: [ue("span", { className: "canvas-loader" }), it("p", { style: { fontSize: 14, color: "#F1F1F1", fontWeight: 800, marginTop: 40 }, children: [n.toFixed(2), "%"] })] }) }, HU = () => { const n = H0("./planet/scene.gltf"); return ue("primitive", { object: n.scene, scale: 2.5, "position-y": 0, "rotation-y": 0 }) }, VU = () => ue(G0, { shadows: !0, frameloop: "demand", dpr: [1, 2], gl: { preserveDrawingBuffer: !0 }, camera: { fov: 45, near: .1, far: 200, position: [-4, 3, 6] }, children: it(U.Suspense, { fallback: ue(WA, {}), children: [ue(VA, { autoRotate: !0, enableZoom: !1, maxPolarAngle: Math.PI / 2, minPolarAngle: Math.PI / 2 }), ue(HU, {}), ue(V0, { all: !0 })] }) }), WU = n => { const [e] = HA([n.imgUrl]); return it(LU, { speed: 1.75, rotationIntensity: 1, floatIntensity: 2, children: [ue("ambientLight", { intensity: .25 }), ue("directionalLight", { position: [0, 0, .05] }), it("mesh", { castShadow: !0, receiveShadow: !0, scale: 2.75, children: [ue("icosahedronGeometry", { args: [1, 1] }), ue("meshStandardMaterial", { color: "#fff8eb", polygonOffset: !0, polygonOffsetFactor: -5, flatShading: !0 }), ue(BU, { position: [0, 0, 1], rotation: [2 * Math.PI, 0, 6.25], flatShading: !0, map: e })] })] }) }, jU = ({ icon: n }) => it(G0, { frameloop: "demand", gl: { preserveDrawingBuffer: !0 }, children: [it(U.Suspense, { fallback: ue(WA, {}), children: [ue(VA, { enableZoom: !1 }), ue(WU, { imgUrl: n })] }), ue(V0, { all: !0 })] }), JU = ({ isMobile: n }) => { const e = H0("./desktop_pc/scene.gltf"); return it("mesh", { children: [ue("hemisphereLight", { intensity: .15, groundColor: "Ceder" }), ue("spotLight", { position: [-20, 50, 10], angle: .12, penumbra: 1, intensity: 1, castShadow: !0, "shadow-mapSize": 1024 }), ue("pointLight", { intensity: 1 }), ue("primitive", { object: e.scene, scale: n ? .7 : .75, position: n ? [0, -3, -2.2] : [0, -3.25, -1.5], rotation: [-.01, -.2, -.1] })] }) }, XU = () => { const [n, e] = U.useState(!1); return U.useEffect(() => { const t = window.matchMedia("(max-width: 500px)"); e(t.matches); const i = r => { e(r.matches) }; return t.addEventListener("change", i), () => { t.removeEventListener("change", i) } }, []), it(G0, { frameloop: "demand", shadows: !0, dpr: [1, 2], camera: { position: [20, 3, 5], fov: 25 }, gl: { preserveDrawingBuffer: !0 }, children: [it(U.Suspense, { fallback: ue(WA, {}), children: [ue(VA, { enableZoom: !1, maxPolarAngle: Math.PI / 2, minPolarAngle: Math.PI / 2 }), ue(JU, { isMobile: n })] }), ue(V0, { all: !0 })] }) }, QU = n => { const e = U.useRef(), [t] = U.useState(() => Jz(new Float32Array(5e3), { radius: 1.2 })); return tu((i, r) => { e.current.rotation.x -= r / 10, e.current.rotation.y -= r / 15 }), ue("group", { rotation: [0, 0, Math.PI / 4], children: ue(kU, { ref: e, positions: t, stride: 3, frustumCulled: !0, ...n, children: ue(RU, { transparent: !0, color: "#f272c8", size: .002, sizeAttenuation: !0, depthWrite: !1 }) }) }) }, KU = () => ue("div", { className: "w-full h-auto absolute inset-0 z-[-1]", children: it(G0, { camera: { position: [0, 0, 1] }, children: [ue(U.Suspense, { fallback: null, children: ue(QU, {}) }), ue(V0, { all: !0 })] }) }), f6 = U.createContext({ transformPagePoint: n => n, isStatic: !1, reducedMotion: "never" }), W0 = U.createContext({}), jA = U.createContext(null), j0 = typeof document < "u", g4 = j0 ? U.useLayoutEffect : U.useEffect, h6 = U.createContext({ strict: !1 }); function YU(n, e, t, i) { const { visualElement: r } = U.useContext(W0), s = U.useContext(h6), o = U.useContext(jA), a = U.useContext(f6).reducedMotion, l = U.useRef(); i = i || s.renderer, !l.current && i && (l.current = i(n, { visualState: e, parent: r, props: t, presenceContext: o, blockInitialAnimation: o ? o.initial === !1 : !1, reducedMotionConfig: a })); const u = l.current; return U.useInsertionEffect(() => { u && u.update(t, o) }), g4(() => { u && u.render() }), U.useEffect(() => { u && u.updateFeatures() }), (window.HandoffAppearAnimations ? g4 : U.useEffect)(() => { u && u.animationState && u.animationState.animateChanges() }), u } function hc(n) { return typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current") } function qU(n, e, t) { return U.useCallback(i => { i && n.mount && n.mount(i), e && (i ? e.mount(i) : e.unmount()), t && (typeof t == "function" ? t(i) : hc(t) && (t.current = i)) }, [e]) } function ih(n) { return typeof n == "string" || Array.isArray(n) } function J0(n) { return typeof n == "object" && typeof n.start == "function" } const JA = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], XA = ["initial", ...JA]; function X0(n) { return J0(n.animate) || XA.some(e => ih(n[e])) } function d6(n) { return Boolean(X0(n) || n.variants) } function ZU(n, e) { if (X0(n)) { const { initial: t, animate: i } = n; return { initial: t === !1 || ih(t) ? t : void 0, animate: ih(i) ? i : void 0 } } return n.inherit !== !1 ? e : {} } function $U(n) { const { initial: e, animate: t } = ZU(n, U.useContext(W0)); return U.useMemo(() => ({ initial: e, animate: t }), [y4(e), y4(t)]) } function y4(n) { return Array.isArray(n) ? n.join(" ") : n } const v4 = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, rh = {}; for (const n in v4) rh[n] = { isEnabled: e => v4[n].some(t => !!e[t]) }; function eG(n) { for (const e in n) rh[e] = { ...rh[e], ...n[e] } } function p6(n) { const e = U.useRef(null); return e.current === null && (e.current = n()), e.current } const yf = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let tG = 1; function nG() { return p6(() => { if (yf.hasEverUpdated) return tG++ }) } const m6 = U.createContext({}), g6 = U.createContext({}), iG = Symbol.for("motionComponentSymbol"); function rG({ preloadedFeatures: n, createVisualElement: e, useRender: t, useVisualState: i, Component: r }) { n && eG(n); function s(a, l) { let u; const h = { ...U.useContext(f6), ...a, layoutId: sG(a) }, { isStatic: d } = h, p = $U(a), m = d ? void 0 : nG(), v = i(a, d); if (!d && j0) { p.visualElement = YU(r, v, h, e); const y = U.useContext(g6), x = U.useContext(h6).strict; p.visualElement && (u = p.visualElement.loadFeatures(h, x, n, m, y)) } return U.createElement(W0.Provider, { value: p }, u && p.visualElement ? U.createElement(u, { visualElement: p.visualElement, ...h }) : null, t(r, a, m, qU(v, p.visualElement, l), v, d, p.visualElement)) } const o = U.forwardRef(s); return o[iG] = r, o } function sG({ layoutId: n }) { const e = U.useContext(m6).id; return e && n !== void 0 ? e + "-" + n : n } function oG(n) { function e(i, r = {}) { return rG(n(i, r)) } if (typeof Proxy > "u") return e; const t = new Map; return new Proxy(e, { get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)) }) } const aG = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function QA(n) { return typeof n != "string" || n.includes("-") ? !1 : !!(aG.indexOf(n) > -1 || /[A-Z]/.test(n)) } const Jm = {}; function lG(n) { Object.assign(Jm, n) } const Q0 = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], dl = new Set(Q0); function y6(n, { layout: e, layoutId: t }) { return dl.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!Jm[n] || n === "opacity") } const Pi = n => Boolean(n && n.getVelocity), cG = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, uG = Q0.length; function fG(n, { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 }, i, r) { let s = ""; for (let o = 0; o < uG; o++) { const a = Q0[o]; if (n[a] !== void 0) { const l = cG[a] || a; s += `${l}(${n[a]}) ` } } return e && !n.z && (s += "translateZ(0)"), s = s.trim(), r ? s = r(n, i ? "" : s) : t && i && (s = "none"), s } const v6 = n => e => typeof e == "string" && e.startsWith(n), x6 = v6("--"), P2 = v6("var(--"), hG = (n, e) => e && typeof n == "number" ? e.transform(n) : n, Hc = (n, e, t) => Math.min(Math.max(t, n), e), pl = { test: n => typeof n == "number", parse: parseFloat, transform: n => n }, vf = { ...pl, transform: n => Hc(0, 1, n) }, Hp = { ...pl, default: 1 }, xf = n => Math.round(n * 1e5) / 1e5, sh = /(-)?([\d]*\.?[\d])+/g, R2 = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, dG = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i; function kh(n) { return typeof n == "string" } const Nh = n => ({ test: e => kh(e) && e.endsWith(n) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${n}` }), go = Nh("deg"), os = Nh("%"), rt = Nh("px"), pG = Nh("vh"), mG = Nh("vw"), x4 = { ...os, parse: n => os.parse(n) / 100, transform: n => os.transform(n * 100) }, A4 = { ...pl, transform: Math.round }, A6 = { borderWidth: rt, borderTopWidth: rt, borderRightWidth: rt, borderBottomWidth: rt, borderLeftWidth: rt, borderRadius: rt, radius: rt, borderTopLeftRadius: rt, borderTopRightRadius: rt, borderBottomRightRadius: rt, borderBottomLeftRadius: rt, width: rt, maxWidth: rt, height: rt, maxHeight: rt, size: rt, top: rt, right: rt, bottom: rt, left: rt, padding: rt, paddingTop: rt, paddingRight: rt, paddingBottom: rt, paddingLeft: rt, margin: rt, marginTop: rt, marginRight: rt, marginBottom: rt, marginLeft: rt, rotate: go, rotateX: go, rotateY: go, rotateZ: go, scale: Hp, scaleX: Hp, scaleY: Hp, scaleZ: Hp, skew: go, skewX: go, skewY: go, distance: rt, translateX: rt, translateY: rt, translateZ: rt, x: rt, y: rt, z: rt, perspective: rt, transformPerspective: rt, opacity: vf, originX: x4, originY: x4, originZ: rt, zIndex: A4, fillOpacity: vf, strokeOpacity: vf, numOctaves: A4 }; function KA(n, e, t, i) { const { style: r, vars: s, transform: o, transformOrigin: a } = n; let l = !1, u = !1, h = !0; for (const d in e) { const p = e[d]; if (x6(d)) { s[d] = p; continue } const m = A6[d], v = hG(p, m); if (dl.has(d)) { if (l = !0, o[d] = v, !h) continue; p !== (m.default || 0) && (h = !1) } else d.startsWith("origin") ? (u = !0, a[d] = v) : r[d] = v } if (e.transform || (l || i ? r.transform = fG(n.transform, t, h, i) : r.transform && (r.transform = "none")), u) { const { originX: d = "50%", originY: p = "50%", originZ: m = 0 } = a; r.transformOrigin = `${d} ${p} ${m}` } } const YA = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function M6(n, e, t) { for (const i in e) !Pi(e[i]) && !y6(i, t) && (n[i] = e[i]) } function gG({ transformTemplate: n }, e, t) { return U.useMemo(() => { const i = YA(); return KA(i, e, { enableHardwareAcceleration: !t }, n), Object.assign({}, i.vars, i.style) }, [e]) } function yG(n, e, t) { const i = n.style || {}, r = {}; return M6(r, i, n), Object.assign(r, gG(n, e, t)), n.transformValues ? n.transformValues(r) : r } function vG(n, e, t) { const i = {}, r = yG(n, e, t); return n.drag && n.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (i.tabIndex = 0), i.style = r, i } const xG = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]); function Xm(n) { return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || xG.has(n) } let _6 = n => !Xm(n); function AG(n) { n && (_6 = e => e.startsWith("on") ? !Xm(e) : n(e)) } try { AG(require("@emotion/is-prop-valid").default) } catch { } function MG(n, e, t) { const i = {}; for (const r in n) r === "values" && typeof n.values == "object" || (_6(r) || t === !0 && Xm(r) || !e && !Xm(r) || n.draggable && r.startsWith("onDrag")) && (i[r] = n[r]); return i } function M4(n, e, t) { return typeof n == "string" ? n : rt.transform(e + t * n) } function _G(n, e, t) { const i = M4(e, n.x, n.width), r = M4(t, n.y, n.height); return `${i} ${r}` } const wG = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, SG = { offset: "strokeDashoffset", array: "strokeDasharray" }; function CG(n, e, t = 1, i = 0, r = !0) { n.pathLength = 1; const s = r ? wG : SG; n[s.offset] = rt.transform(-i); const o = rt.transform(e), a = rt.transform(t); n[s.array] = `${o} ${a}` } function qA(n, { attrX: e, attrY: t, originX: i, originY: r, pathLength: s, pathSpacing: o = 1, pathOffset: a = 0, ...l }, u, h, d) { if (KA(n, l, u, d), h) { n.style.viewBox && (n.attrs.viewBox = n.style.viewBox); return } n.attrs = n.style, n.style = {}; const { attrs: p, style: m, dimensions: v } = n; p.transform && (v && (m.transform = p.transform), delete p.transform), v && (i !== void 0 || r !== void 0 || m.transform) && (m.transformOrigin = _G(v, i !== void 0 ? i : .5, r !== void 0 ? r : .5)), e !== void 0 && (p.x = e), t !== void 0 && (p.y = t), s !== void 0 && CG(p, s, o, a, !1) } const w6 = () => ({ ...YA(), attrs: {} }), ZA = n => typeof n == "string" && n.toLowerCase() === "svg"; function EG(n, e, t, i) { const r = U.useMemo(() => { const s = w6(); return qA(s, e, { enableHardwareAcceleration: !1 }, ZA(i), n.transformTemplate), { ...s.attrs, style: { ...s.style } } }, [e]); if (n.style) { const s = {}; M6(s, n.style, n), r.style = { ...s, ...r.style } } return r } function bG(n = !1) { return (t, i, r, s, { latestValues: o }, a) => { const u = (QA(t) ? EG : vG)(i, o, a, t), d = { ...MG(i, typeof t == "string", n), ...u, ref: s }, { children: p } = i, m = U.useMemo(() => Pi(p) ? p.get() : p, [p]); return r && (d["data-projection-id"] = r), U.createElement(t, { ...d, children: m }) } } const $A = n => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); function S6(n, { style: e, vars: t }, i, r) { Object.assign(n.style, e, r && r.getProjectionStyles(i)); for (const s in t) n.style.setProperty(s, t[s]) } const C6 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function E6(n, e, t, i) { S6(n, e, void 0, i); for (const r in e.attrs) n.setAttribute(C6.has(r) ? r : $A(r), e.attrs[r]) } function e3(n, e) { const { style: t } = n, i = {}; for (const r in t) (Pi(t[r]) || e.style && Pi(e.style[r]) || y6(r, n)) && (i[r] = t[r]); return i } function b6(n, e) { const t = e3(n, e); for (const i in n) if (Pi(n[i]) || Pi(e[i])) { const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i; t[r] = n[i] } return t } function t3(n, e, t, i = {}, r = {}) { return typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), typeof e == "string" && (e = n.variants && n.variants[e]), typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), e } const Qm = n => Array.isArray(n), TG = n => Boolean(n && typeof n == "object" && n.mix && n.toValue), BG = n => Qm(n) ? n[n.length - 1] || 0 : n; function dm(n) { const e = Pi(n) ? n.get() : n; return TG(e) ? e.toValue() : e } function PG({ scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t }, i, r, s) { const o = { latestValues: RG(i, r, s, n), renderState: e() }; return t && (o.mount = a => t(i, a, o)), o } const T6 = n => (e, t) => { const i = U.useContext(W0), r = U.useContext(jA), s = () => PG(n, e, i, r); return t ? s() : p6(s) }; function RG(n, e, t, i) { const r = {}, s = i(n, {}); for (const p in s) r[p] = dm(s[p]); let { initial: o, animate: a } = n; const l = X0(n), u = d6(n); e && u && !l && n.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate)); let h = t ? t.initial === !1 : !1; h = h || o === !1; const d = h ? a : o; return d && typeof d != "boolean" && !J0(d) && (Array.isArray(d) ? d : [d]).forEach(m => { const v = t3(n, m); if (!v) return; const { transitionEnd: y, transition: x, ...A } = v; for (const _ in A) { let M = A[_]; if (Array.isArray(M)) { const S = h ? M.length - 1 : 0; M = M[S] } M !== null && (r[_] = M) } for (const _ in y) r[_] = y[_] }), r } const LG = { useVisualState: T6({ scrapeMotionValuesFromProps: b6, createRenderState: w6, onMount: (n, e, { renderState: t, latestValues: i }) => { try { t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { t.dimensions = { x: 0, y: 0, width: 0, height: 0 } } qA(t, i, { enableHardwareAcceleration: !1 }, ZA(e.tagName), n.transformTemplate), E6(e, t) } }) }, IG = { useVisualState: T6({ scrapeMotionValuesFromProps: e3, createRenderState: YA }) }; function DG(n, { forwardMotionProps: e = !1 }, t, i) { return { ...QA(n) ? LG : IG, preloadedFeatures: t, useRender: bG(e), createVisualElement: i, Component: n } } function ks(n, e, t, i = { passive: !0 }) { return n.addEventListener(e, t, i), () => n.removeEventListener(e, t) } const B6 = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1; function K0(n, e = "page") { return { point: { x: n[e + "X"], y: n[e + "Y"] } } } const FG = n => e => B6(e) && n(e, K0(e)); function zs(n, e, t, i) { return ks(n, e, FG(t), i) } const kG = (n, e) => t => e(n(t)), zo = (...n) => n.reduce(kG); function P6(n) { let e = null; return () => { const t = () => { e = null }; return e === null ? (e = n, t) : !1 } } const _4 = P6("dragHorizontal"), w4 = P6("dragVertical"); function R6(n) { let e = !1; if (n === "y") e = w4(); else if (n === "x") e = _4(); else { const t = _4(), i = w4(); t && i ? e = () => { t(), i() } : (t && t(), i && i()) } return e } function L6() { const n = R6(!0); return n ? (n(), !1) : !0 } class ia { constructor(e) { this.isMounted = !1, this.node = e } update() { } } const I6 = 1 / 60 * 1e3, NG = typeof performance < "u" ? () => performance.now() : () => Date.now(), D6 = typeof window < "u" ? n => window.requestAnimationFrame(n) : n => setTimeout(() => n(NG()), I6); function OG(n) { let e = [], t = [], i = 0, r = !1, s = !1; const o = new WeakSet, a = { schedule: (l, u = !1, h = !1) => { const d = h && r, p = d ? e : t; return u && o.add(l), p.indexOf(l) === -1 && (p.push(l), d && r && (i = e.length)), l }, cancel: l => { const u = t.indexOf(l); u !== -1 && t.splice(u, 1), o.delete(l) }, process: l => { if (r) { s = !0; return } if (r = !0, [e, t] = [t, e], t.length = 0, i = e.length, i) for (let u = 0; u < i; u++) { const h = e[u]; h(l), o.has(h) && (a.schedule(h), n()) } r = !1, s && (s = !1, a.process(l)) } }; return a } const Us = { delta: 0, timestamp: 0 }, zG = 40; let L2 = !0, oh = !1, I2 = !1; const Oh = ["read", "update", "preRender", "render", "postRender"], Y0 = Oh.reduce((n, e) => (n[e] = OG(() => oh = !0), n), {}), qt = Oh.reduce((n, e) => { const t = Y0[e]; return n[e] = (i, r = !1, s = !1) => (oh || GG(), t.schedule(i, r, s)), n }, {}), Xo = Oh.reduce((n, e) => (n[e] = Y0[e].cancel, n), {}), Cy = Oh.reduce((n, e) => (n[e] = () => Y0[e].process(Us), n), {}), UG = n => Y0[n].process(Us), F6 = n => { oh = !1, Us.delta = L2 ? I6 : Math.max(Math.min(n - Us.timestamp, zG), 1), Us.timestamp = n, I2 = !0, Oh.forEach(UG), I2 = !1, oh && (L2 = !1, D6(F6)) }, GG = () => { oh = !0, L2 = !0, I2 || D6(F6) }; function S4(n, e) { const t = "pointer" + (e ? "enter" : "leave"), i = "onHover" + (e ? "Start" : "End"), r = (s, o) => { if (s.type === "touch" || L6()) return; const a = n.getProps(); n.animationState && a.whileHover && n.animationState.setActive("whileHover", e), a[i] && qt.update(() => a[i](s, o)) }; return zs(n.current, t, r, { passive: !n.getProps()[i] }) } class HG extends ia { mount() { this.unmount = zo(S4(this.node, !0), S4(this.node, !1)) } unmount() { } } class VG extends ia { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = zo(ks(this.node.current, "focus", () => this.onFocus()), ks(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const k6 = (n, e) => e ? n === e ? !0 : k6(n, e.parentElement) : !1, pr = n => n; function Ey(n, e) { if (!e) return; const t = new PointerEvent("pointer" + n); e(t, K0(t)) } class WG extends ia { constructor() { super(...arguments), this.removeStartListeners = pr, this.removeEndListeners = pr, this.removeAccessibleListeners = pr, this.startPointerPress = (e, t) => { if (this.removeEndListeners(), this.isPressing) return; const i = this.node.getProps(), s = zs(window, "pointerup", (a, l) => { if (!this.checkPressEnd()) return; const { onTap: u, onTapCancel: h } = this.node.getProps(); qt.update(() => { k6(this.node.current, a.target) ? u && u(a, l) : h && h(a, l) }) }, { passive: !(i.onTap || i.onPointerUp) }), o = zs(window, "pointercancel", (a, l) => this.cancelPress(a, l), { passive: !(i.onTapCancel || i.onPointerCancel) }); this.removeEndListeners = zo(s, o), this.startPress(e, t) }, this.startAccessiblePress = () => { const e = s => { if (s.key !== "Enter" || this.isPressing) return; const o = a => { a.key !== "Enter" || !this.checkPressEnd() || Ey("up", (l, u) => { const { onTap: h } = this.node.getProps(); h && qt.update(() => h(l, u)) }) }; this.removeEndListeners(), this.removeEndListeners = ks(this.node.current, "keyup", o), Ey("down", (a, l) => { this.startPress(a, l) }) }, t = ks(this.node.current, "keydown", e), i = () => { this.isPressing && Ey("cancel", (s, o) => this.cancelPress(s, o)) }, r = ks(this.node.current, "blur", i); this.removeAccessibleListeners = zo(t, r) } } startPress(e, t) { this.isPressing = !0; const { onTapStart: i, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), i && qt.update(() => i(e, t)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !L6() } cancelPress(e, t) { if (!this.checkPressEnd()) return; const { onTapCancel: i } = this.node.getProps(); i && qt.update(() => i(e, t)) } mount() { const e = this.node.getProps(), t = zs(this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), i = ks(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = zo(t, i) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const D2 = new WeakMap, by = new WeakMap, jG = n => { const e = D2.get(n.target); e && e(n) }, JG = n => { n.forEach(jG) }; function XG({ root: n, ...e }) { const t = n || document; by.has(t) || by.set(t, {}); const i = by.get(t), r = JSON.stringify(e); return i[r] || (i[r] = new IntersectionObserver(JG, { root: n, ...e })), i[r] } function QG(n, e, t) { const i = XG(e); return D2.set(n, t), i.observe(n), () => { D2.delete(n), i.unobserve(n) } } const KG = { some: 0, all: 1 }; class YG extends ia { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: t, margin: i, amount: r = "some", once: s } = e, o = { root: t ? t.current : void 0, rootMargin: i, threshold: typeof r == "number" ? r : KG[r] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, s && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: h, onViewportLeave: d } = this.node.getProps(), p = u ? h : d; p && p(l) }; return QG(this.node.current, o, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(qG(e, t)) && this.startObserver() } unmount() { } } function qG({ viewport: n = {} }, { viewport: e = {} } = {}) { return t => n[t] !== e[t] } const ZG = { inView: { Feature: YG }, tap: { Feature: WG }, focus: { Feature: VG }, hover: { Feature: HG } }; function N6(n, e) { if (!Array.isArray(e)) return !1; const t = e.length; if (t !== n.length) return !1; for (let i = 0; i < t; i++)if (e[i] !== n[i]) return !1; return !0 } const $G = n => /^\-?\d*\.?\d+$/.test(n), eH = n => /^0[^.\s]+$/.test(n); function n3(n, e) { n.indexOf(e) === -1 && n.push(e) } function i3(n, e) { const t = n.indexOf(e); t > -1 && n.splice(t, 1) } class r3 { constructor() { this.subscriptions = [] } add(e) { return n3(this.subscriptions, e), () => i3(this.subscriptions, e) } notify(e, t, i) { const r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, t, i); else for (let s = 0; s < r; s++) { const o = this.subscriptions[s]; o && o(e, t, i) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } function s3(n, e) { return e ? n * (1e3 / e) : 0 } const tH = n => !isNaN(parseFloat(n)); class nH { constructor(e, t = {}) { this.version = "10.2.1", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (i, r = !0) => { this.prev = this.current, this.current = i; const { delta: s, timestamp: o } = Us; this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, qt.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.scheduleVelocityCheck = () => qt.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: i }) => { i !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity())) }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = tH(this.current), this.owner = t.owner } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new r3); const i = this.events[e].add(t); return e === "change" ? () => { i(), qt.read(() => { this.events.change.getSize() || this.stop() }) } : i } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, t, i) { this.set(t), this.prev = e, this.timeDelta = i } jump(e) { this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { return this.canTrackVelocity ? s3(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0 } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t) || null, this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { this.animation = null } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Vc(n, e) { return new nH(n, e) } const o3 = (n, e) => t => Boolean(kh(t) && dG.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e)), O6 = (n, e, t) => i => { if (!kh(i)) return i; const [r, s, o, a] = i.match(sh); return { [n]: parseFloat(r), [e]: parseFloat(s), [t]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, iH = n => Hc(0, 255, n), Ty = { ...pl, transform: n => Math.round(iH(n)) }, Ha = { test: o3("rgb", "red"), parse: O6("red", "green", "blue"), transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) => "rgba(" + Ty.transform(n) + ", " + Ty.transform(e) + ", " + Ty.transform(t) + ", " + xf(vf.transform(i)) + ")" }; function rH(n) { let e = "", t = "", i = "", r = ""; return n.length > 5 ? (e = n.substring(1, 3), t = n.substring(3, 5), i = n.substring(5, 7), r = n.substring(7, 9)) : (e = n.substring(1, 2), t = n.substring(2, 3), i = n.substring(3, 4), r = n.substring(4, 5), e += e, t += t, i += i, r += r), { red: parseInt(e, 16), green: parseInt(t, 16), blue: parseInt(i, 16), alpha: r ? parseInt(r, 16) / 255 : 1 } } const F2 = { test: o3("#"), parse: rH, transform: Ha.transform }, dc = { test: o3("hsl", "hue"), parse: O6("hue", "saturation", "lightness"), transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) => "hsla(" + Math.round(n) + ", " + os.transform(xf(e)) + ", " + os.transform(xf(t)) + ", " + xf(vf.transform(i)) + ")" }, di = { test: n => Ha.test(n) || F2.test(n) || dc.test(n), parse: n => Ha.test(n) ? Ha.parse(n) : dc.test(n) ? dc.parse(n) : F2.parse(n), transform: n => kh(n) ? n : n.hasOwnProperty("red") ? Ha.transform(n) : dc.transform(n) }, z6 = "${c}", U6 = "${n}"; function sH(n) { var e, t; return isNaN(n) && kh(n) && (((e = n.match(sh)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = n.match(R2)) === null || t === void 0 ? void 0 : t.length) || 0) > 0 } function Km(n) { typeof n == "number" && (n = `${n}`); const e = []; let t = 0, i = 0; const r = n.match(R2); r && (t = r.length, n = n.replace(R2, z6), e.push(...r.map(di.parse))); const s = n.match(sh); return s && (i = s.length, n = n.replace(sh, U6), e.push(...s.map(pl.parse))), { values: e, numColors: t, numNumbers: i, tokenised: n } } function G6(n) { return Km(n).values } function H6(n) { const { values: e, numColors: t, tokenised: i } = Km(n), r = e.length; return s => { let o = i; for (let a = 0; a < r; a++)o = o.replace(a < t ? z6 : U6, a < t ? di.transform(s[a]) : xf(s[a])); return o } } const oH = n => typeof n == "number" ? 0 : n; function aH(n) { const e = G6(n); return H6(n)(e.map(oH)) } const Qo = { test: sH, parse: G6, createTransformer: H6, getAnimatableNone: aH }, lH = new Set(["brightness", "contrast", "saturate", "opacity"]); function cH(n) { const [e, t] = n.slice(0, -1).split("("); if (e === "drop-shadow") return n; const [i] = t.match(sh) || []; if (!i) return n; const r = t.replace(i, ""); let s = lH.has(e) ? 1 : 0; return i !== t && (s *= 100), e + "(" + s + r + ")" } const uH = /([a-z-]*)\(.*?\)/g, k2 = { ...Qo, getAnimatableNone: n => { const e = n.match(uH); return e ? e.map(cH).join(" ") : n } }, fH = { ...A6, color: di, backgroundColor: di, outlineColor: di, fill: di, stroke: di, borderColor: di, borderTopColor: di, borderRightColor: di, borderBottomColor: di, borderLeftColor: di, filter: k2, WebkitFilter: k2 }, a3 = n => fH[n]; function l3(n, e) { let t = a3(n); return t !== k2 && (t = Qo), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0 } const V6 = n => e => e.test(n), hH = { test: n => n === "auto", parse: n => n }, W6 = [pl, rt, os, go, mG, pG, hH], Qu = n => W6.find(V6(n)), dH = [...W6, di, Qo], pH = n => dH.find(V6(n)); function mH(n) { const e = {}; return n.values.forEach((t, i) => e[i] = t.get()), e } function gH(n) { const e = {}; return n.values.forEach((t, i) => e[i] = t.getVelocity()), e } function q0(n, e, t) { const i = n.getProps(); return t3(i, e, t !== void 0 ? t : i.custom, mH(n), gH(n)) } function yH(n, e, t) { n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Vc(t)) } function vH(n, e) { const t = q0(n, e); let { transitionEnd: i = {}, transition: r = {}, ...s } = t ? n.makeTargetAnimatable(t, !1) : {}; s = { ...s, ...i }; for (const o in s) { const a = BG(s[o]); yH(n, o, a) } } function xH(n, e, t) { var i, r; const s = Object.keys(e).filter(a => !n.hasValue(a)), o = s.length; if (o) for (let a = 0; a < o; a++) { const l = s[a], u = e[l]; let h = null; Array.isArray(u) && (h = u[0]), h === null && (h = (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !== null && r !== void 0 ? r : e[l]), h != null && (typeof h == "string" && ($G(h) || eH(h)) ? h = parseFloat(h) : !pH(h) && Qo.test(u) && (h = l3(l, u)), n.addValue(l, Vc(h, { owner: n })), t[l] === void 0 && (t[l] = h), h !== null && n.setBaseTarget(l, h)) } } function AH(n, e) { return e ? (e[n] || e.default || e).from : void 0 } function MH(n, e, t) { const i = {}; for (const r in n) { const s = AH(r, e); if (s !== void 0) i[r] = s; else { const o = t.getValue(r); o && (i[r] = o.get()) } } return i } function Ym(n) { return Boolean(Pi(n) && n.add) } const _H = "framerAppearId", wH = "data-" + $A(_H); let SH = pr, qm = pr; const pm = n => n * 1e3, CH = { current: !1 }, c3 = n => e => e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2, u3 = n => e => 1 - n(1 - e), f3 = n => n * n, EH = u3(f3), h3 = c3(f3), rn = (n, e, t) => -t * n + t * e + n; function By(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n } function bH({ hue: n, saturation: e, lightness: t, alpha: i }) { n /= 360, e /= 100, t /= 100; let r = 0, s = 0, o = 0; if (!e) r = s = o = t; else { const a = t < .5 ? t * (1 + e) : t + e - t * e, l = 2 * t - a; r = By(l, a, n + 1 / 3), s = By(l, a, n), o = By(l, a, n - 1 / 3) } return { red: Math.round(r * 255), green: Math.round(s * 255), blue: Math.round(o * 255), alpha: i } } const Py = (n, e, t) => { const i = n * n; return Math.sqrt(Math.max(0, t * (e * e - i) + i)) }, TH = [F2, Ha, dc], BH = n => TH.find(e => e.test(n)); function C4(n) { const e = BH(n); let t = e.parse(n); return e === dc && (t = bH(t)), t } const j6 = (n, e) => { const t = C4(n), i = C4(e), r = { ...t }; return s => (r.red = Py(t.red, i.red, s), r.green = Py(t.green, i.green, s), r.blue = Py(t.blue, i.blue, s), r.alpha = rn(t.alpha, i.alpha, s), Ha.transform(r)) }; function J6(n, e) { return typeof n == "number" ? t => rn(n, e, t) : di.test(n) ? j6(n, e) : Q6(n, e) } const X6 = (n, e) => { const t = [...n], i = t.length, r = n.map((s, o) => J6(s, e[o])); return s => { for (let o = 0; o < i; o++)t[o] = r[o](s); return t } }, PH = (n, e) => { const t = { ...n, ...e }, i = {}; for (const r in t) n[r] !== void 0 && e[r] !== void 0 && (i[r] = J6(n[r], e[r])); return r => { for (const s in i) t[s] = i[s](r); return t } }, Q6 = (n, e) => { const t = Qo.createTransformer(e), i = Km(n), r = Km(e); return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? zo(X6(i.values, r.values), t) : o => `${o > 0 ? e : n}` }, ah = (n, e, t) => { const i = e - n; return i === 0 ? 1 : (t - n) / i }, E4 = (n, e) => t => rn(n, e, t); function RH(n) { return typeof n == "number" ? E4 : typeof n == "string" ? di.test(n) ? j6 : Q6 : Array.isArray(n) ? X6 : typeof n == "object" ? PH : E4 } function LH(n, e, t) { const i = [], r = t || RH(n[0]), s = n.length - 1; for (let o = 0; o < s; o++) { let a = r(n[o], n[o + 1]); if (e) { const l = Array.isArray(e) ? e[o] : e; a = zo(l, a) } i.push(a) } return i } function K6(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) { const s = n.length; qm(s === e.length), qm(!i || !Array.isArray(i) || i.length === s - 1), n[0] > n[s - 1] && (n = [...n].reverse(), e = [...e].reverse()); const o = LH(e, i, r), a = o.length, l = u => { let h = 0; if (a > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++); const d = ah(n[h], n[h + 1], u); return o[h](d) }; return t ? u => l(Hc(n[0], n[s - 1], u)) : l } function IH(n, e) { const t = n[n.length - 1]; for (let i = 1; i <= e; i++) { const r = ah(0, e, i); n.push(rn(t, 1, r)) } } function DH(n) { const e = [0]; return IH(e, n.length - 1), e } function FH(n, e) { return n.map(t => t * e) } const Y6 = (n, e, t) => (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n, kH = 1e-7, NH = 12; function OH(n, e, t, i, r) { let s, o, a = 0; do o = e + (t - e) / 2, s = Y6(o, i, r) - n, s > 0 ? t = o : e = o; while (Math.abs(s) > kH && ++a < NH); return o } function q6(n, e, t, i) { if (n === e && t === i) return pr; const r = s => OH(s, 0, 1, n, t); return s => s === 0 || s === 1 ? s : Y6(r(s), e, i) } const Z6 = n => 1 - Math.sin(Math.acos(n)), d3 = u3(Z6), zH = c3(d3), $6 = q6(.33, 1.53, .69, .99), p3 = u3($6), UH = c3(p3), GH = n => (n *= 2) < 1 ? .5 * p3(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))), HH = { linear: pr, easeIn: f3, easeInOut: h3, easeOut: EH, circIn: Z6, circInOut: zH, circOut: d3, backIn: p3, backInOut: UH, backOut: $6, anticipate: GH }, b4 = n => { if (Array.isArray(n)) { qm(n.length === 4); const [e, t, i, r] = n; return q6(e, t, i, r) } else if (typeof n == "string") return HH[n]; return n }, VH = n => Array.isArray(n) && typeof n[0] != "number"; function WH(n, e) { return n.map(() => e || h3).splice(0, n.length - 1) } function N2({ keyframes: n, ease: e = h3, times: t, duration: i = 300 }) { n = [...n]; const r = VH(e) ? e.map(b4) : b4(e), s = { done: !1, value: n[0] }, o = FH(t && t.length === n.length ? t : DH(n), i); function a() { return K6(o, n, { ease: Array.isArray(r) ? r : WH(n, r) }) } let l = a(); return { next: u => (s.value = l(u), s.done = u >= i, s), flipTarget: () => { n.reverse(), l = a() } } } const Ry = .001, jH = .01, T4 = 10, JH = .05, XH = 1; function QH({ duration: n = 800, bounce: e = .25, velocity: t = 0, mass: i = 1 }) { let r, s; SH(n <= T4 * 1e3); let o = 1 - e; o = Hc(JH, XH, o), n = Hc(jH, T4, n / 1e3), o < 1 ? (r = u => { const h = u * o, d = h * n, p = h - t, m = O2(u, o), v = Math.exp(-d); return Ry - p / m * v }, s = u => { const d = u * o * n, p = d * t + t, m = Math.pow(o, 2) * Math.pow(u, 2) * n, v = Math.exp(-d), y = O2(Math.pow(u, 2), o); return (-r(u) + Ry > 0 ? -1 : 1) * ((p - m) * v) / y }) : (r = u => { const h = Math.exp(-u * n), d = (u - t) * n + 1; return -Ry + h * d }, s = u => { const h = Math.exp(-u * n), d = (t - u) * (n * n); return h * d }); const a = 5 / n, l = YH(r, s, a); if (n = n * 1e3, isNaN(l)) return { stiffness: 100, damping: 10, duration: n }; { const u = Math.pow(l, 2) * i; return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n } } } const KH = 12; function YH(n, e, t) { let i = t; for (let r = 1; r < KH; r++)i = i - n(i) / e(i); return i } function O2(n, e) { return n * Math.sqrt(1 - e * e) } const qH = ["duration", "bounce"], ZH = ["stiffness", "damping", "mass"]; function B4(n, e) { return e.some(t => n[t] !== void 0) } function $H(n) { let e = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...n }; if (!B4(n, ZH) && B4(n, qH)) { const t = QH(n); e = { ...e, ...t, velocity: 0, mass: 1 }, e.isResolvedFromDuration = !0 } return e } const eV = 5; function e8({ keyframes: n, restDelta: e, restSpeed: t, ...i }) { let r = n[0], s = n[n.length - 1]; const o = { done: !1, value: r }, { stiffness: a, damping: l, mass: u, velocity: h, duration: d, isResolvedFromDuration: p } = $H(i); let m = tV, v = h ? -(h / 1e3) : 0; const y = l / (2 * Math.sqrt(a * u)); function x() { const A = s - r, _ = Math.sqrt(a / u) / 1e3, M = Math.abs(A) < 5; if (t || (t = M ? .01 : 2), e || (e = M ? .005 : .5), y < 1) { const S = O2(_, y); m = b => { const B = Math.exp(-y * _ * b); return s - B * ((v + y * _ * A) / S * Math.sin(S * b) + A * Math.cos(S * b)) } } else if (y === 1) m = S => s - Math.exp(-_ * S) * (A + (v + _ * A) * S); else { const S = _ * Math.sqrt(y * y - 1); m = b => { const B = Math.exp(-y * _ * b), R = Math.min(S * b, 300); return s - B * ((v + y * _ * A) * Math.sinh(R) + S * A * Math.cosh(R)) / S } } } return x(), { next: A => { const _ = m(A); if (p) o.done = A >= d; else { let M = v; if (A !== 0) if (y < 1) { const B = Math.max(0, A - eV); M = s3(_ - m(B), A - B) } else M = 0; const S = Math.abs(M) <= t, b = Math.abs(s - _) <= e; o.done = S && b } return o.value = o.done ? s : _, o }, flipTarget: () => { v = -v, [r, s] = [s, r], x() } } } e8.needsInterpolation = (n, e) => typeof n == "string" || typeof e == "string"; const tV = n => 0; function nV({ keyframes: n = [0], velocity: e = 0, power: t = .8, timeConstant: i = 350, restDelta: r = .5, modifyTarget: s }) { const o = n[0], a = { done: !1, value: o }; let l = t * e; const u = o + l, h = s === void 0 ? u : s(u); return h !== u && (l = h - o), { next: d => { const p = -l * Math.exp(-d / i); return a.done = !(p > r || p < -r), a.value = a.done ? h : h + p, a }, flipTarget: () => { } } } const iV = { decay: nV, keyframes: N2, tween: N2, spring: e8 }; function t8(n, e, t = 0) { return n - e - t } function rV(n, e = 0, t = 0, i = !0) { return i ? t8(e + -n, e, t) : e - (n - e) + t } function sV(n, e, t, i) { return i ? n >= e + t : n <= -t } const oV = n => { const e = ({ delta: t }) => n(t); return { start: () => qt.update(e, !0), stop: () => Xo.update(e) } }; function Zm({ duration: n, driver: e = oV, elapsed: t = 0, repeat: i = 0, repeatType: r = "loop", repeatDelay: s = 0, keyframes: o, autoplay: a = !0, onPlay: l, onStop: u, onComplete: h, onRepeat: d, onUpdate: p, type: m = "keyframes", ...v }) { const y = t; let x, A = 0, _ = n, M = !1, S = !0, b; const B = iV[o.length > 2 ? "keyframes" : m] || N2, R = o[0], E = o[o.length - 1]; let P = { done: !1, value: R }; const { needsInterpolation: L } = B; L && L(R, E) && (b = K6([0, 100], [R, E], { clamp: !1 }), o = [0, 100]); const z = B({ ...v, duration: n, keyframes: o }); function Z() { A++, r === "reverse" ? (S = A % 2 === 0, t = rV(t, _, s, S)) : (t = t8(t, _, s), r === "mirror" && z.flipTarget()), M = !1, d && d() } function J() { x && x.stop(), h && h() } function V(ee) { S || (ee = -ee), t += ee, M || (P = z.next(Math.max(0, t)), b && (P.value = b(P.value)), M = S ? P.done : t <= 0), p && p(P.value), M && (A === 0 && (_ = _ !== void 0 ? _ : t), A < i ? sV(t, _, s, S) && Z() : J()) } function K() { l && l(), x = e(V), x.start() } return a && K(), { stop: () => { u && u(), x && x.stop() }, set currentTime(ee) { t = y, V(ee) }, sample: (ee, le = !1) => { if (t = y, le) return V(ee), P; const N = n && typeof n == "number" ? Math.max(n * .5, 50) : 50; let H = 0; for (V(0); H <= ee;) { const W = ee - H; V(Math.min(W, N)), H += N } return P } } } function aV(n) { return !n || Array.isArray(n) || typeof n == "string" && n8[n] } const nf = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`, n8 = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: nf([0, .65, .55, 1]), circOut: nf([.55, 0, 1, .45]), backIn: nf([.31, .01, .66, -.59]), backOut: nf([.33, 1.53, .69, .99]) }; function lV(n) { if (n) return Array.isArray(n) ? nf(n) : n8[n] } function cV(n, e, t, { delay: i = 0, duration: r, repeat: s = 0, repeatType: o = "loop", ease: a, times: l } = {}) { const u = { [e]: t }; return l && (u.offset = l), n.animate(u, { delay: i, duration: r, easing: lV(a), fill: "both", iterations: s + 1, direction: o === "reverse" ? "alternate" : "normal" }) } const P4 = { waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate") }, Ly = {}, i8 = {}; for (const n in P4) i8[n] = () => (Ly[n] === void 0 && (Ly[n] = P4[n]()), Ly[n]); function uV(n, { repeat: e, repeatType: t = "loop" }) { const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1; return n[i] } const fV = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"]), Vp = 10, hV = (n, e) => e.type === "spring" || n === "backgroundColor" || !aV(e.ease); function dV(n, e, { onUpdate: t, onComplete: i, ...r }) { if (!(i8.waapi() && fV.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0)) return !1; let { keyframes: o, duration: a = 300, elapsed: l = 0, ease: u } = r; if (hV(e, r)) { const d = Zm({ ...r, repeat: 0, elapsed: 0 }); let p = { done: !1, value: o[0] }; const m = []; let v = 0; for (; !p.done && v < 2e4;)p = d.sample(v, !0), m.push(p.value), v += Vp; o = m, a = v - Vp, u = "linear" } const h = cV(n.owner.current, e, o, { ...r, delay: -l, duration: a, ease: u }); return h.onfinish = () => { n.set(uV(o, r)), qt.update(() => h.cancel()), i && i() }, { get currentTime() { return h.currentTime || 0 }, set currentTime(d) { h.currentTime = d }, stop: () => { const { currentTime: d } = h; if (d) { const p = Zm({ ...r, autoplay: !1 }); n.setWithVelocity(p.sample(d - Vp).value, p.sample(d).value, Vp) } qt.update(() => h.cancel()) } } } function r8(n, e) { const t = performance.now(), i = ({ timestamp: r }) => { const s = r - t; s >= e && (Xo.read(i), n(s - e)) }; return qt.read(i, !0), () => Xo.read(i) } function pV({ keyframes: n, elapsed: e, onUpdate: t, onComplete: i }) { const r = () => { t && t(n[n.length - 1]), i && i() }; return e ? { stop: r8(r, -e) } : r() } function mV({ keyframes: n, velocity: e = 0, min: t, max: i, power: r = .8, timeConstant: s = 750, bounceStiffness: o = 500, bounceDamping: a = 10, restDelta: l = 1, modifyTarget: u, driver: h, onUpdate: d, onComplete: p, onStop: m }) { const v = n[0]; let y; function x(S) { return t !== void 0 && S < t || i !== void 0 && S > i } function A(S) { return t === void 0 ? i : i === void 0 || Math.abs(t - S) < Math.abs(i - S) ? t : i } function _(S) { y && y.stop(), y = Zm({ keyframes: [0, 1], velocity: 0, ...S, driver: h, onUpdate: b => { d && d(b), S.onUpdate && S.onUpdate(b) }, onComplete: p, onStop: m }) } function M(S) { _({ type: "spring", stiffness: o, damping: a, restDelta: l, ...S }) } if (x(v)) M({ velocity: e, keyframes: [v, A(v)] }); else { let S = r * e + v; typeof u < "u" && (S = u(S)); const b = A(S), B = b === t ? -1 : 1; let R, E; const P = L => { R = E, E = L, e = s3(L - R, Us.delta), (B === 1 && L > b || B === -1 && L < b) && M({ keyframes: [L, b], velocity: e }) }; _({ type: "decay", keyframes: [v, 0], velocity: e, timeConstant: s, power: r, restDelta: l, modifyTarget: u, onUpdate: x(S) ? P : void 0 }) } return { stop: () => y && y.stop() } } const gV = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, yV = n => ({ type: "spring", stiffness: 550, damping: n === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), vV = { type: "keyframes", duration: .8 }, xV = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, AV = (n, { keyframes: e }) => e.length > 2 ? vV : dl.has(n) ? n.startsWith("scale") ? yV(e[1]) : gV : xV, z2 = (n, e) => n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && Qo.test(e) && !e.startsWith("url(")); function MV({ when: n, delay: e, delayChildren: t, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: u, ...h }) { return !!Object.keys(h).length } function R4(n) { return n === 0 || typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1 } function L4(n) { return typeof n == "number" ? 0 : l3("", n) } function s8(n, e) { return n[e] || n.default || n } function _V(n, e, t, i) { const r = z2(e, t); let s = i.from !== void 0 ? i.from : n.get(); return s === "none" && r && typeof t == "string" ? s = l3(e, t) : R4(s) && typeof t == "string" ? s = L4(t) : !Array.isArray(t) && R4(t) && typeof s == "string" && (t = L4(s)), Array.isArray(t) ? (t[0] === null && (t[0] = s), t) : [s, t] } const m3 = (n, e, t, i = {}) => r => { const s = s8(i, n) || {}, o = s.delay || i.delay || 0; let { elapsed: a = 0 } = i; a = a - pm(o); const l = _V(e, n, t, s), u = l[0], h = l[l.length - 1], d = z2(n, u), p = z2(n, h); let m = { keyframes: l, velocity: e.getVelocity(), ...s, elapsed: a, onUpdate: v => { e.set(v), s.onUpdate && s.onUpdate(v) }, onComplete: () => { r(), s.onComplete && s.onComplete() } }; if (!d || !p || CH.current || s.type === !1) return pV(m); if (s.type === "inertia") return mV(m); if (MV(s) || (m = { ...m, ...AV(n, m) }), m.duration && (m.duration = pm(m.duration)), m.repeatDelay && (m.repeatDelay = pm(m.repeatDelay)), e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) { const v = dV(e, n, m); if (v) return v } return Zm(m) }; function wV(n, e, t = {}) { n.notify("AnimationStart", e); let i; if (Array.isArray(e)) { const r = e.map(s => U2(n, s, t)); i = Promise.all(r) } else if (typeof e == "string") i = U2(n, e, t); else { const r = typeof e == "function" ? q0(n, e, t.custom) : e; i = o8(n, r, t) } return i.then(() => n.notify("AnimationComplete", e)) } function U2(n, e, t = {}) { const i = q0(n, e, t.custom); let { transition: r = n.getDefaultTransition() || {} } = i || {}; t.transitionOverride && (r = t.transitionOverride); const s = i ? () => o8(n, i, t) : () => Promise.resolve(), o = n.variantChildren && n.variantChildren.size ? (l = 0) => { const { delayChildren: u = 0, staggerChildren: h, staggerDirection: d } = r; return SV(n, e, u + l, h, d, t) } : () => Promise.resolve(), { when: a } = r; if (a) { const [l, u] = a === "beforeChildren" ? [s, o] : [o, s]; return l().then(u) } else return Promise.all([s(), o(t.delay)]) } function o8(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) { let { transition: s = n.getDefaultTransition(), transitionEnd: o, ...a } = n.makeTargetAnimatable(e); const l = n.getValue("willChange"); i && (s = i); const u = [], h = r && n.animationState && n.animationState.getState()[r]; for (const d in a) { const p = n.getValue(d), m = a[d]; if (!p || m === void 0 || h && EV(h, d)) continue; const v = { delay: t, elapsed: 0, ...s }; if (window.HandoffAppearAnimations && !p.hasAnimated) { const x = n.getProps()[wH]; x && (v.elapsed = window.HandoffAppearAnimations(x, d, p, qt)) } let y = p.start(m3(d, p, m, n.shouldReduceMotion && dl.has(d) ? { type: !1 } : v)); Ym(l) && (l.add(d), y = y.then(() => l.remove(d))), u.push(y) } return Promise.all(u).then(() => { o && vH(n, o) }) } function SV(n, e, t = 0, i = 0, r = 1, s) { const o = [], a = (n.variantChildren.size - 1) * i, l = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i; return Array.from(n.variantChildren).sort(CV).forEach((u, h) => { u.notify("AnimationStart", e), o.push(U2(u, e, { ...s, delay: t + l(h) }).then(() => u.notify("AnimationComplete", e))) }), Promise.all(o) } function CV(n, e) { return n.sortNodePosition(e) } function EV({ protectedKeys: n, needsAnimating: e }, t) { const i = n.hasOwnProperty(t) && e[t] !== !0; return e[t] = !1, i } const bV = [...JA].reverse(), TV = JA.length; function BV(n) { return e => Promise.all(e.map(({ animation: t, options: i }) => wV(n, t, i))) } function PV(n) { let e = BV(n); const t = LV(); let i = !0; const r = (l, u) => { const h = q0(n, u); if (h) { const { transition: d, transitionEnd: p, ...m } = h; l = { ...l, ...m, ...p } } return l }; function s(l) { e = l(n) } function o(l, u) { const h = n.getProps(), d = n.getVariantContext(!0) || {}, p = [], m = new Set; let v = {}, y = 1 / 0; for (let A = 0; A < TV; A++) { const _ = bV[A], M = t[_], S = h[_] !== void 0 ? h[_] : d[_], b = ih(S), B = _ === u ? M.isActive : null; B === !1 && (y = A); let R = S === d[_] && S !== h[_] && b; if (R && i && n.manuallyAnimateOnMount && (R = !1), M.protectedKeys = { ...v }, !M.isActive && B === null || !S && !M.prevProp || J0(S) || typeof S == "boolean") continue; const E = RV(M.prevProp, S); let P = E || _ === u && M.isActive && !R && b || A > y && b; const L = Array.isArray(S) ? S : [S]; let z = L.reduce(r, {}); B === !1 && (z = {}); const { prevResolvedValues: Z = {} } = M, J = { ...Z, ...z }, V = K => { P = !0, m.delete(K), M.needsAnimating[K] = !0 }; for (const K in J) { const ee = z[K], le = Z[K]; v.hasOwnProperty(K) || (ee !== le ? Qm(ee) && Qm(le) ? !N6(ee, le) || E ? V(K) : M.protectedKeys[K] = !0 : ee !== void 0 ? V(K) : m.add(K) : ee !== void 0 && m.has(K) ? V(K) : M.protectedKeys[K] = !0) } M.prevProp = S, M.prevResolvedValues = z, M.isActive && (v = { ...v, ...z }), i && n.blockInitialAnimation && (P = !1), P && !R && p.push(...L.map(K => ({ animation: K, options: { type: _, ...l } }))) } if (m.size) { const A = {}; m.forEach(_ => { const M = n.getBaseTarget(_); M !== void 0 && (A[_] = M) }), p.push({ animation: A }) } let x = Boolean(p.length); return i && h.initial === !1 && !n.manuallyAnimateOnMount && (x = !1), i = !1, x ? e(p) : Promise.resolve() } function a(l, u, h) { var d; if (t[l].isActive === u) return Promise.resolve(); (d = n.variantChildren) === null || d === void 0 || d.forEach(m => { var v; return (v = m.animationState) === null || v === void 0 ? void 0 : v.setActive(l, u) }), t[l].isActive = u; const p = o(h, l); for (const m in t) t[m].protectedKeys = {}; return p } return { animateChanges: o, setActive: a, setAnimateFunction: s, getState: () => t } } function RV(n, e) { return typeof e == "string" ? e !== n : Array.isArray(e) ? !N6(e, n) : !1 } function _a(n = !1) { return { isActive: n, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function LV() { return { animate: _a(!0), whileInView: _a(), whileHover: _a(), whileTap: _a(), whileDrag: _a(), whileFocus: _a(), exit: _a() } } class IV extends ia { constructor(e) { super(e), e.animationState || (e.animationState = PV(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); this.unmount(), J0(e) && (this.unmount = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { } } let DV = 0; class FV extends ia { constructor() { super(...arguments), this.id = DV++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: t, custom: i } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const s = this.node.animationState.setActive("exit", !e, { custom: i ?? this.node.getProps().custom }); t && !e && s.then(() => t(this.id)) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } const kV = { animation: { Feature: IV }, exit: { Feature: FV } }, I4 = (n, e) => Math.abs(n - e); function NV(n, e) { const t = I4(n.x, e.x), i = I4(n.y, e.y); return Math.sqrt(t ** 2 + i ** 2) } class a8 { constructor(e, t, { transformPagePoint: i } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const u = Dy(this.lastMoveEventInfo, this.history), h = this.startEvent !== null, d = NV(u.offset, { x: 0, y: 0 }) >= 3; if (!h && !d) return; const { point: p } = u, { timestamp: m } = Us; this.history.push({ ...p, timestamp: m }); const { onStart: v, onMove: y } = this.handlers; h || (v && v(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, u) }, this.handlePointerMove = (u, h) => { this.lastMoveEvent = u, this.lastMoveEventInfo = Iy(h, this.transformPagePoint), qt.update(this.updatePoint, !0) }, this.handlePointerUp = (u, h) => { if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const { onEnd: d, onSessionEnd: p } = this.handlers, m = Dy(u.type === "pointercancel" ? this.lastMoveEventInfo : Iy(h, this.transformPagePoint), this.history); this.startEvent && d && d(u, m), p && p(u, m) }, !B6(e)) return; this.handlers = t, this.transformPagePoint = i; const r = K0(e), s = Iy(r, this.transformPagePoint), { point: o } = s, { timestamp: a } = Us; this.history = [{ ...o, timestamp: a }]; const { onSessionStart: l } = t; l && l(e, Dy(s, this.history)), this.removeListeners = zo(zs(window, "pointermove", this.handlePointerMove), zs(window, "pointerup", this.handlePointerUp), zs(window, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), Xo.update(this.updatePoint) } } function Iy(n, e) { return e ? { point: e(n.point) } : n } function D4(n, e) { return { x: n.x - e.x, y: n.y - e.y } } function Dy({ point: n }, e) { return { point: n, delta: D4(n, l8(e)), offset: D4(n, OV(e)), velocity: zV(e, .1) } } function OV(n) { return n[0] } function l8(n) { return n[n.length - 1] } function zV(n, e) { if (n.length < 2) return { x: 0, y: 0 }; let t = n.length - 1, i = null; const r = l8(n); for (; t >= 0 && (i = n[t], !(r.timestamp - i.timestamp > pm(e)));)t--; if (!i) return { x: 0, y: 0 }; const s = (r.timestamp - i.timestamp) / 1e3; if (s === 0) return { x: 0, y: 0 }; const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function Ji(n) { return n.max - n.min } function G2(n, e = 0, t = .01) { return Math.abs(n - e) <= t } function F4(n, e, t, i = .5) { n.origin = i, n.originPoint = rn(e.min, e.max, n.origin), n.scale = Ji(t) / Ji(e), (G2(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1), n.translate = rn(t.min, t.max, n.origin) - n.originPoint, (G2(n.translate) || isNaN(n.translate)) && (n.translate = 0) } function Af(n, e, t, i) { F4(n.x, e.x, t.x, i ? i.originX : void 0), F4(n.y, e.y, t.y, i ? i.originY : void 0) } function k4(n, e, t) { n.min = t.min + e.min, n.max = n.min + Ji(e) } function UV(n, e, t) { k4(n.x, e.x, t.x), k4(n.y, e.y, t.y) } function N4(n, e, t) { n.min = e.min - t.min, n.max = n.min + Ji(e) } function Mf(n, e, t) { N4(n.x, e.x, t.x), N4(n.y, e.y, t.y) } function GV(n, { min: e, max: t }, i) { return e !== void 0 && n < e ? n = i ? rn(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? rn(t, n, i.max) : Math.min(n, t)), n } function O4(n, e, t) { return { min: e !== void 0 ? n.min + e : void 0, max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0 } } function HV(n, { top: e, left: t, bottom: i, right: r }) { return { x: O4(n.x, t, r), y: O4(n.y, e, i) } } function z4(n, e) { let t = e.min - n.min, i = e.max - n.max; return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i } } function VV(n, e) { return { x: z4(n.x, e.x), y: z4(n.y, e.y) } } function WV(n, e) { let t = .5; const i = Ji(n), r = Ji(e); return r > i ? t = ah(e.min, e.max - i, n.min) : i > r && (t = ah(n.min, n.max - r, e.min)), Hc(0, 1, t) } function jV(n, e) { const t = {}; return e.min !== void 0 && (t.min = e.min - n.min), e.max !== void 0 && (t.max = e.max - n.min), t } const H2 = .35; function JV(n = H2) { return n === !1 ? n = 0 : n === !0 && (n = H2), { x: U4(n, "left", "right"), y: U4(n, "top", "bottom") } } function U4(n, e, t) { return { min: G4(n, e), max: G4(n, t) } } function G4(n, e) { return typeof n == "number" ? n : n[e] || 0 } const H4 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), _f = () => ({ x: H4(), y: H4() }), V4 = () => ({ min: 0, max: 0 }), Sn = () => ({ x: V4(), y: V4() }); function es(n) { return [n("x"), n("y")] } function c8({ top: n, left: e, right: t, bottom: i }) { return { x: { min: e, max: t }, y: { min: n, max: i } } } function XV({ x: n, y: e }) { return { top: e.min, right: n.max, bottom: e.max, left: n.min } } function QV(n, e) { if (!e) return n; const t = e({ x: n.left, y: n.top }), i = e({ x: n.right, y: n.bottom }); return { top: t.y, left: t.x, bottom: i.y, right: i.x } } function Fy(n) { return n === void 0 || n === 1 } function V2({ scale: n, scaleX: e, scaleY: t }) { return !Fy(n) || !Fy(e) || !Fy(t) } function Ba(n) { return V2(n) || u8(n) || n.z || n.rotate || n.rotateX || n.rotateY } function u8(n) { return W4(n.x) || W4(n.y) } function W4(n) { return n && n !== "0%" } function $m(n, e, t) { const i = n - t, r = e * i; return t + r } function j4(n, e, t, i, r) { return r !== void 0 && (n = $m(n, r, i)), $m(n, t, i) + e } function W2(n, e = 0, t = 1, i, r) { n.min = j4(n.min, e, t, i, r), n.max = j4(n.max, e, t, i, r) } function f8(n, { x: e, y: t }) { W2(n.x, e.translate, e.scale, e.originPoint), W2(n.y, t.translate, t.scale, t.originPoint) } function KV(n, e, t, i = !1) { const r = t.length; if (!r) return; e.x = e.y = 1; let s, o; for (let a = 0; a < r; a++) { s = t[a], o = s.projectionDelta; const l = s.instance; l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && pc(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), o && (e.x *= o.x.scale, e.y *= o.y.scale, f8(n, o)), i && Ba(s.latestValues) && pc(n, s.latestValues)) } e.x = J4(e.x), e.y = J4(e.y) } function J4(n) { return Number.isInteger(n) || n > 1.0000000000001 || n < .999999999999 ? n : 1 } function Ao(n, e) { n.min = n.min + e, n.max = n.max + e } function X4(n, e, [t, i, r]) { const s = e[r] !== void 0 ? e[r] : .5, o = rn(n.min, n.max, s); W2(n, e[t], e[i], o, e.scale) } const YV = ["x", "scaleX", "originX"], qV = ["y", "scaleY", "originY"]; function pc(n, e) { X4(n.x, e, YV), X4(n.y, e, qV) } function h8(n, e) { return c8(QV(n.getBoundingClientRect(), e)) } function ZV(n, e, t) { const i = h8(n, t), { scroll: r } = e; return r && (Ao(i.x, r.offset.x), Ao(i.y, r.offset.y)), i } const $V = new WeakMap; class eW { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Sn(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { const { presenceContext: i } = this.visualElement; if (i && i.isPresent === !1) return; const r = l => { this.stopAnimation(), t && this.snapToCursor(K0(l, "page").point) }, s = (l, u) => { const { drag: h, dragPropagation: d, onDragStart: p } = this.getProps(); if (h && !d && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = R6(h), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), es(v => { let y = this.getAxisMotionValue(v).get() || 0; if (os.test(y)) { const { projection: x } = this.visualElement; if (x && x.layout) { const A = x.layout.layoutBox[v]; A && (y = Ji(A) * (parseFloat(y) / 100)) } } this.originPoint[v] = y }), p && qt.update(() => p(l, u)); const { animationState: m } = this.visualElement; m && m.setActive("whileDrag", !0) }, o = (l, u) => { const { dragPropagation: h, dragDirectionLock: d, onDirectionLock: p, onDrag: m } = this.getProps(); if (!h && !this.openGlobalLock) return; const { offset: v } = u; if (d && this.currentDirection === null) { this.currentDirection = tW(v), this.currentDirection !== null && p && p(this.currentDirection); return } this.updateAxis("x", u.point, v), this.updateAxis("y", u.point, v), this.visualElement.render(), m && m(l, u) }, a = (l, u) => this.stop(l, u); this.panSession = new a8(e, { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a }, { transformPagePoint: this.visualElement.getTransformPagePoint() }) } stop(e, t) { const i = this.isDragging; if (this.cancel(), !i) return; const { velocity: r } = t; this.startAnimation(r); const { onDragEnd: s } = this.getProps(); s && qt.update(() => s(e, t)) } cancel() { this.isDragging = !1; const { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: i } = this.getProps(); !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, i) { const { drag: r } = this.getProps(); if (!i || !Wp(e, r, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let o = this.originPoint[e] + i[e]; this.constraints && this.constraints[e] && (o = GV(o, this.constraints[e], this.elastic[e])), s.set(o) } resolveConstraints() { const { dragConstraints: e, dragElastic: t } = this.getProps(), { layout: i } = this.visualElement.projection || {}, r = this.constraints; e && hc(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = HV(i.layoutBox, e) : this.constraints = !1, this.elastic = JV(t), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && es(s => { this.getAxisMotionValue(s) && (this.constraints[s] = jV(i.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !hc(e)) return !1; const i = e.current, { projection: r } = this.visualElement; if (!r || !r.layout) return !1; const s = ZV(i, r.root, this.visualElement.getTransformPagePoint()); let o = VV(r.layout.layoutBox, s); if (t) { const a = t(XV(o)); this.hasMutatedConstraints = !!a, a && (o = c8(a)) } return o } startAnimation(e) { const { drag: t, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = es(h => { if (!Wp(h, t, this.currentDirection)) return; let d = l && l[h] || {}; o && (d = { min: 0, max: 0 }); const p = r ? 200 : 1e6, m = r ? 40 : 1e7, v = { type: "inertia", velocity: i ? e[h] : 0, bounceStiffness: p, bounceDamping: m, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...d }; return this.startAxisValueAnimation(h, v) }); return Promise.all(u).then(a) } startAxisValueAnimation(e, t) { const i = this.getAxisMotionValue(e); return i.start(m3(e, i, 0, t)) } stopAnimation() { es(e => this.getAxisMotionValue(e).stop()) } getAxisMotionValue(e) { const t = "_drag" + e.toUpperCase(), i = this.visualElement.getProps(), r = i[t]; return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0) } snapToCursor(e) { es(t => { const { drag: i } = this.getProps(); if (!Wp(t, i, this.currentDirection)) return; const { projection: r } = this.visualElement, s = this.getAxisMotionValue(t); if (r && r.layout) { const { min: o, max: a } = r.layout.layoutBox[t]; s.set(e[t] - rn(o, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: t } = this.getProps(), { projection: i } = this.visualElement; if (!hc(t) || !i || !this.constraints) return; this.stopAnimation(); const r = { x: 0, y: 0 }; es(o => { const a = this.getAxisMotionValue(o); if (a) { const l = a.get(); r[o] = WV({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), es(o => { if (!Wp(o, e, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: u } = this.constraints[o]; a.set(rn(l, u, r[o])) }) } addListeners() { if (!this.visualElement.current) return; $V.set(this.visualElement, this); const e = this.visualElement.current, t = zs(e, "pointerdown", l => { const { drag: u, dragListener: h = !0 } = this.getProps(); u && h && this.start(l) }), i = () => { const { dragConstraints: l } = this.getProps(); hc(l) && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, s = r.addEventListener("measure", i); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i(); const o = ks(window, "resize", () => this.scalePositionWithinConstraints()), a = r.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => { this.isDragging && u && (es(h => { const d = this.getAxisMotionValue(h); d && (this.originPoint[h] += l[h].translate, d.set(d.get() + l[h].translate)) }), this.visualElement.render()) }); return () => { o(), t(), s(), a && a() } } getProps() { const e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: i = !1, dragPropagation: r = !1, dragConstraints: s = !1, dragElastic: o = H2, dragMomentum: a = !0 } = e; return { ...e, drag: t, dragDirectionLock: i, dragPropagation: r, dragConstraints: s, dragElastic: o, dragMomentum: a } } } function Wp(n, e, t) { return (e === !0 || e === n) && (t === null || t === n) } function tW(n, e = 10) { let t = null; return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"), t } class nW extends ia { constructor(e) { super(e), this.removeGroupControls = pr, this.removeListeners = pr, this.controls = new eW(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || pr } unmount() { this.removeGroupControls(), this.removeListeners() } } const Q4 = n => (e, t) => { n && qt.update(() => n(e, t)) }; class iW extends ia { constructor() { super(...arguments), this.removePointerDownListener = pr } onPointerDown(e) { this.session = new a8(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: t, onPan: i, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Q4(e), onStart: Q4(t), onMove: i, onEnd: (s, o) => { delete this.session, r && qt.update(() => r(s, o)) } } } mount() { this.removePointerDownListener = zs(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function rW() { const n = U.useContext(jA); if (n === null) return [!0, null]; const { isPresent: e, onExitComplete: t, register: i } = n, r = U.useId(); return U.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0] } function K4(n, e) { return e.max === e.min ? 0 : n / (e.max - e.min) * 100 } const Ku = { correct: (n, e) => { if (!e.target) return n; if (typeof n == "string") if (rt.test(n)) n = parseFloat(n); else return n; const t = K4(n, e.target.x), i = K4(n, e.target.y); return `${t}% ${i}%` } }, d8 = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/; function sW(n) { const e = d8.exec(n); if (!e) return [,]; const [, t, i] = e; return [t, i] } function j2(n, e, t = 1) { const [i, r] = sW(n); if (!i) return; const s = window.getComputedStyle(e).getPropertyValue(i); return s ? s.trim() : P2(r) ? j2(r, e, t + 1) : r } function oW(n, { ...e }, t) { const i = n.current; if (!(i instanceof Element)) return { target: e, transitionEnd: t }; t && (t = { ...t }), n.values.forEach(r => { const s = r.get(); if (!P2(s)) return; const o = j2(s, i); o && r.set(o) }); for (const r in e) { const s = e[r]; if (!P2(s)) continue; const o = j2(s, i); o && (e[r] = o, t && t[r] === void 0 && (t[r] = s)) } return { target: e, transitionEnd: t } } const Y4 = "_$css", aW = { correct: (n, { treeScale: e, projectionDelta: t }) => { const i = n, r = n.includes("var("), s = []; r && (n = n.replace(d8, m => (s.push(m), Y4))); const o = Qo.parse(n); if (o.length > 5) return i; const a = Qo.createTransformer(n), l = typeof o[0] != "number" ? 1 : 0, u = t.x.scale * e.x, h = t.y.scale * e.y; o[0 + l] /= u, o[1 + l] /= h; const d = rn(u, h, .5); typeof o[2 + l] == "number" && (o[2 + l] /= d), typeof o[3 + l] == "number" && (o[3 + l] /= d); let p = a(o); if (r) { let m = 0; p = p.replace(Y4, () => { const v = s[m]; return m++, v }) } return p } }; class lW extends r0.Component { componentDidMount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: i, layoutId: r } = this.props, { projection: s } = e; lG(cW), s && (t.group && t.group.add(s), i && i.register && r && i.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), yf.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: t, visualElement: i, drag: r, isPresent: s } = this.props, o = i.projection; return o && (o.isPresent = s, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || qt.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove()) } componentWillUnmount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: i } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), i && i.deregister && i.deregister(r)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function p8(n) { const [e, t] = rW(), i = U.useContext(m6); return r0.createElement(lW, { ...n, layoutGroup: i, switchLayoutGroup: U.useContext(g6), isPresent: e, safeToRemove: t }) } const cW = { borderRadius: { ...Ku, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Ku, borderTopRightRadius: Ku, borderBottomLeftRadius: Ku, borderBottomRightRadius: Ku, boxShadow: aW }; function uW(n, e, t = {}) { const i = Pi(n) ? n : Vc(n); return i.start(m3("", i, e, t)), { stop: () => i.stop(), isAnimating: () => i.isAnimating() } } const m8 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], fW = m8.length, q4 = n => typeof n == "string" ? parseFloat(n) : n, Z4 = n => typeof n == "number" || rt.test(n); function hW(n, e, t, i, r, s) { r ? (n.opacity = rn(0, t.opacity !== void 0 ? t.opacity : 1, dW(i)), n.opacityExit = rn(e.opacity !== void 0 ? e.opacity : 1, 0, pW(i))) : s && (n.opacity = rn(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, i)); for (let o = 0; o < fW; o++) { const a = `border${m8[o]}Radius`; let l = $4(e, a), u = $4(t, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || Z4(l) === Z4(u) ? (n[a] = Math.max(rn(q4(l), q4(u), i), 0), (os.test(u) || os.test(l)) && (n[a] += "%")) : n[a] = u } (e.rotate || t.rotate) && (n.rotate = rn(e.rotate || 0, t.rotate || 0, i)) } function $4(n, e) { return n[e] !== void 0 ? n[e] : n.borderRadius } const dW = g8(0, .5, d3), pW = g8(.5, .95, pr); function g8(n, e, t) { return i => i < n ? 0 : i > e ? 1 : t(ah(n, e, i)) } function eC(n, e) { n.min = e.min, n.max = e.max } function ar(n, e) { eC(n.x, e.x), eC(n.y, e.y) } function tC(n, e, t, i, r) { return n -= e, n = $m(n, 1 / t, i), r !== void 0 && (n = $m(n, 1 / r, i)), n } function mW(n, e = 0, t = 1, i = .5, r, s = n, o = n) { if (os.test(e) && (e = parseFloat(e), e = rn(o.min, o.max, e / 100) - o.min), typeof e != "number") return; let a = rn(s.min, s.max, i); n === s && (a -= e), n.min = tC(n.min, e, t, a, r), n.max = tC(n.max, e, t, a, r) } function nC(n, e, [t, i, r], s, o) { mW(n, e[t], e[i], e[r], e.scale, s, o) } const gW = ["x", "scaleX", "originX"], yW = ["y", "scaleY", "originY"]; function iC(n, e, t, i) { nC(n.x, e, gW, t ? t.x : void 0, i ? i.x : void 0), nC(n.y, e, yW, t ? t.y : void 0, i ? i.y : void 0) } function rC(n) { return n.translate === 0 && n.scale === 1 } function y8(n) { return rC(n.x) && rC(n.y) } function J2(n, e) { return n.x.min === e.x.min && n.x.max === e.x.max && n.y.min === e.y.min && n.y.max === e.y.max } function sC(n) { return Ji(n.x) / Ji(n.y) } class vW { constructor() { this.members = [] } add(e) { n3(this.members, e), e.scheduleRender() } remove(e) { if (i3(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(e) { const t = this.members.findIndex(r => e === r); if (t === 0) return !1; let i; for (let r = t; r >= 0; r--) { const s = this.members[r]; if (s.isPresent !== !1) { i = s; break } } return i ? (this.promote(i), !0) : !1 } promote(e, t) { const i = this.lead; if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) { i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, t && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: r } = e.options; r === !1 && i.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: t, resumingFrom: i } = e; t.onExitComplete && t.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function oC(n, e, t) { let i = ""; const r = n.x.translate / e.x, s = n.y.translate / e.y; if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `), t) { const { rotate: l, rotateX: u, rotateY: h } = t; l && (i += `rotate(${l}deg) `), u && (i += `rotateX(${u}deg) `), h && (i += `rotateY(${h}deg) `) } const o = n.x.scale * e.x, a = n.y.scale * e.y; return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none" } const xW = (n, e) => n.depth - e.depth; class AW { constructor() { this.children = [], this.isDirty = !1 } add(e) { n3(this.children, e), this.isDirty = !0 } remove(e) { i3(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(xW), this.isDirty = !1, this.children.forEach(e) } } function MW(n) { window.MotionDebug && window.MotionDebug.record(n) } const aC = ["", "X", "Y", "Z"], lC = 1e3; let _W = 0; const Pa = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function v8({ attachResizeListener: n, defaultParent: e, measureScroll: t, checkIsScrollRoot: i, resetTransform: r }) { return class { constructor(o, a = {}, l = e == null ? void 0 : e()) { this.id = _W++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.potentialNodes = new Map, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { Pa.totalNodes = Pa.resolvedTargetDeltas = Pa.recalculatedProjection = 0, this.nodes.forEach(CW), this.nodes.forEach(BW), this.nodes.forEach(PW), this.nodes.forEach(EW), MW(Pa) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.elementId = o, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0, o && this.root.registerPotentialNode(o, this); for (let u = 0; u < this.path.length; u++)this.path[u].shouldResetTransform = !0; this.root === this && (this.nodes = new AW) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new r3), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } registerPotentialNode(o, a) { this.potentialNodes.set(o, a) } mount(o, a = !1) { if (this.instance) return; this.isSVG = o instanceof SVGElement && o.tagName !== "svg", this.instance = o; const { layoutId: l, layout: u, visualElement: h } = this.options; if (h && !h.current && h.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (u || l) && (this.isLayoutDirty = !0), n) { let d; const p = () => this.root.updateBlockedByResize = !1; n(o, () => { this.root.updateBlockedByResize = !0, d && d(), d = r8(p, 250), yf.hasAnimatedSinceResize && (yf.hasAnimatedSinceResize = !1, this.nodes.forEach(uC)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && h && (l || u) && this.addEventListener("didUpdate", ({ delta: d, hasLayoutChanged: p, hasRelativeTargetChanged: m, layout: v }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const y = this.options.transition || h.getDefaultTransition() || FW, { onLayoutAnimationStart: x, onLayoutAnimationComplete: A } = h.getProps(), _ = !this.targetLayout || !J2(this.targetLayout, v) || m, M = !p && m; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || M || p && (_ || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(d, M); const S = { ...s8(y, "layout"), onPlay: x, onComplete: A }; (h.shouldReduceMotion || this.options.layoutRoot) && (S.delay = 0, S.type = !1), this.startAnimation(S) } else !p && this.animationProgress === 0 && uC(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = v }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Xo.preRender(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(RW), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let h = 0; h < this.path.length; h++) { const d = this.path[h]; d.shouldResetTransform = !0, d.updateScroll("snapshot"), d.options.layoutRoot && d.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } didUpdate() { if (this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(cC); return } this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(kW), this.potentialNodes.clear()), this.nodes.forEach(TW), this.nodes.forEach(wW), this.nodes.forEach(SW), this.clearAllSnapshots(), Cy.update(), Cy.preRender(), Cy.render()) } clearAllSnapshots() { this.nodes.forEach(bW), this.sharedNodes.forEach(LW) } scheduleUpdateProjection() { qt.preRender(this.updateProjection, !1, !0) } scheduleCheckAfterUnmount() { qt.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Sn(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = Boolean(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = { animationId: this.root.animationId, phase: o, isRoot: i(this.instance), offset: t(this.instance) }) } resetTransform() { if (!r) return; const o = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !y8(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, h = u !== this.prevTransformTemplateValue; o && (a || Ba(this.latestValues) || h) && (r(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), NW(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: o } = this.options; if (!o) return Sn(); const a = o.measureViewportBox(), { scroll: l } = this.root; return l && (Ao(a.x, l.offset.x), Ao(a.y, l.offset.y)), a } removeElementScroll(o) { const a = Sn(); ar(a, o); for (let l = 0; l < this.path.length; l++) { const u = this.path[l], { scroll: h, options: d } = u; if (u !== this.root && h && d.layoutScroll) { if (h.isRoot) { ar(a, o); const { scroll: p } = this.root; p && (Ao(a.x, -p.offset.x), Ao(a.y, -p.offset.y)) } Ao(a.x, h.offset.x), Ao(a.y, h.offset.y) } } return a } applyTransform(o, a = !1) { const l = Sn(); ar(l, o); for (let u = 0; u < this.path.length; u++) { const h = this.path[u]; !a && h.options.layoutScroll && h.scroll && h !== h.root && pc(l, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }), Ba(h.latestValues) && pc(l, h.latestValues) } return Ba(this.latestValues) && pc(l, this.latestValues), l } removeTransform(o) { const a = Sn(); ar(a, o); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !Ba(u.latestValues)) continue; V2(u.latestValues) && u.updateSnapshot(); const h = Sn(), d = u.measurePageBox(); ar(h, d), iC(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h) } return Ba(this.latestValues) && iC(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } resolveTargetDelta() { var o; const a = this.getLead(); if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty), !((Boolean(this.resumingFrom) || this !== a) && this.isSharedProjectionDirty || this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; const { layout: h, layoutId: d } = this.options; if (!(!this.layout || !(h || d))) { if (!this.targetDelta && !this.relativeTarget) { const p = this.getClosestProjectingParent(); p && p.layout ? (this.relativeParent = p, this.relativeTarget = Sn(), this.relativeTargetOrigin = Sn(), Mf(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), ar(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = Sn(), this.targetWithTransforms = Sn()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? UV(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : ar(this.target, this.layout.layoutBox), f8(this.target, this.targetDelta)) : ar(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const p = this.getClosestProjectingParent(); p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target ? (this.relativeParent = p, this.relativeTarget = Sn(), this.relativeTargetOrigin = Sn(), Mf(this.relativeTargetOrigin, this.target, p.target), ar(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Pa.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || V2(this.parent.latestValues) || u8(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var o; const a = this.getLead(), l = Boolean(this.resumingFrom) || this !== a; let u = !0; if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), u) return; const { layout: h, layoutId: d } = this.options; if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || d)) return; ar(this.layoutCorrected, this.layout.layoutBox), KV(this.layoutCorrected, this.treeScale, this.path, l); const { target: p } = a; if (!p) return; this.projectionDelta || (this.projectionDelta = _f(), this.projectionDeltaWithTransform = _f()); const m = this.treeScale.x, v = this.treeScale.y, y = this.projectionTransform; Af(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = oC(this.projectionDelta, this.treeScale), (this.projectionTransform !== y || this.treeScale.x !== m || this.treeScale.y !== v) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), Pa.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), o) { const a = this.getStack(); a && a.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(o, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, h = { ...this.latestValues }, d = _f(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const p = Sn(), m = l ? l.source : void 0, v = this.layout ? this.layout.source : void 0, y = m !== v, x = this.getStack(), A = !x || x.members.length <= 1, _ = Boolean(y && !A && this.options.crossfade === !0 && !this.path.some(DW)); this.animationProgress = 0; let M; this.mixTargetDelta = S => { const b = S / 1e3; fC(d.x, o.x, b), fC(d.y, o.y, b), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Mf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), IW(this.relativeTarget, this.relativeTargetOrigin, p, b), M && J2(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = Sn()), ar(M, this.relativeTarget)), y && (this.animationValues = h, hW(h, u, this.latestValues, b, _, A)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = b }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Xo.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = qt.update(() => { yf.hasAnimatedSinceResize = !0, this.currentAnimation = uW(0, lC, { ...o, onUpdate: a => { this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a) }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(lC), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: h } = o; if (!(!a || !l || !u)) { if (this !== o && this.layout && u && x8(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || Sn(); const d = Ji(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + d; const p = Ji(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + p } ar(a, l), pc(a, h), Af(this.projectionDeltaWithTransform, this.layoutCorrected, a, h) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new vW), this.sharedNodes.get(o).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var o; const { layoutId: a } = this.options; return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this } getPrevLead() { var o; const { layoutId: a } = this.options; return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a) return; const u = {}; for (let h = 0; h < aC.length; h++) { const d = "rotate" + aC[h]; l[d] && (u[d] = l[d], o.setStaticValue(d, 0)) } o.render(); for (const h in u) o.setStaticValue(h, u[h]); o.scheduleRender() } getProjectionStyles(o = {}) { var a, l; const u = {}; if (!this.instance || this.isSVG) return u; if (this.isVisible) u.visibility = ""; else return { visibility: "hidden" }; const h = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, u.opacity = "", u.pointerEvents = dm(o.pointerEvents) || "", u.transform = h ? h(this.latestValues, "") : "none", u; const d = this.getLead(); if (!this.projectionDelta || !this.layout || !d.target) { const y = {}; return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = dm(o.pointerEvents) || ""), this.hasProjected && !Ba(this.latestValues) && (y.transform = h ? h({}, "") : "none", this.hasProjected = !1), y } const p = d.animationValues || d.latestValues; this.applyTransformsToTarget(), u.transform = oC(this.projectionDeltaWithTransform, this.treeScale, p), h && (u.transform = h(p, u.transform)); const { x: m, y: v } = this.projectionDelta; u.transformOrigin = `${m.origin * 100}% ${v.origin * 100}% 0`, d.animationValues ? u.opacity = d === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : u.opacity = d === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0; for (const y in Jm) { if (p[y] === void 0) continue; const { correct: x, applyTo: A } = Jm[y], _ = u.transform === "none" ? p[y] : x(p[y], d); if (A) { const M = A.length; for (let S = 0; S < M; S++)u[A[S]] = _ } else u[y] = _ } return this.options.layoutId && (u.pointerEvents = d === this ? dm(o.pointerEvents) || "" : "none"), u } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(cC), this.root.sharedNodes.clear() } } } function wW(n) { n.updateLayout() } function SW(n) { var e; const t = ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || n.snapshot; if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: r } = n.layout, { animationType: s } = n.options, o = t.source !== n.layout.source; s === "size" ? es(d => { const p = o ? t.measuredBox[d] : t.layoutBox[d], m = Ji(p); p.min = i[d].min, p.max = p.min + m }) : x8(s, t.layoutBox, i) && es(d => { const p = o ? t.measuredBox[d] : t.layoutBox[d], m = Ji(i[d]); p.max = p.min + m }); const a = _f(); Af(a, i, t.layoutBox); const l = _f(); o ? Af(l, n.applyTransform(r, !0), t.measuredBox) : Af(l, i, t.layoutBox); const u = !y8(a); let h = !1; if (!n.resumeFrom) { const d = n.getClosestProjectingParent(); if (d && !d.resumeFrom) { const { snapshot: p, layout: m } = d; if (p && m) { const v = Sn(); Mf(v, t.layoutBox, p.layoutBox); const y = Sn(); Mf(y, i, m.layoutBox), J2(v, y) || (h = !0), d.options.layoutRoot && (n.relativeTarget = y, n.relativeTargetOrigin = v, n.relativeParent = d) } } } n.notifyListeners("didUpdate", { layout: i, snapshot: t, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeTargetChanged: h }) } else if (n.isLead()) { const { onExitComplete: i } = n.options; i && i() } n.options.transition = void 0 } function CW(n) { Pa.totalNodes++, n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = Boolean(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty)) } function EW(n) { n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1 } function bW(n) { n.clearSnapshot() } function cC(n) { n.clearMeasurements() } function TW(n) { const { visualElement: e } = n.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), n.resetTransform() } function uC(n) { n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0 } function BW(n) { n.resolveTargetDelta() } function PW(n) { n.calcProjection() } function RW(n) { n.resetRotation() } function LW(n) { n.removeLeadSnapshot() } function fC(n, e, t) { n.translate = rn(e.translate, 0, t), n.scale = rn(e.scale, 1, t), n.origin = e.origin, n.originPoint = e.originPoint } function hC(n, e, t, i) { n.min = rn(e.min, t.min, i), n.max = rn(e.max, t.max, i) } function IW(n, e, t, i) { hC(n.x, e.x, t.x, i), hC(n.y, e.y, t.y, i) } function DW(n) { return n.animationValues && n.animationValues.opacityExit !== void 0 } const FW = { duration: .45, ease: [.4, 0, .1, 1] }; function kW(n, e) { let t = n.root; for (let s = n.path.length - 1; s >= 0; s--)if (Boolean(n.path[s].instance)) { t = n.path[s]; break } const r = (t && t !== n.root ? t.instance : document).querySelector(`[data-projection-id="${e}"]`); r && n.mount(r, !0) } function dC(n) { n.min = Math.round(n.min), n.max = Math.round(n.max) } function NW(n) { dC(n.x), dC(n.y) } function x8(n, e, t) { return n === "position" || n === "preserve-aspect" && !G2(sC(e), sC(t), .2) } const OW = v8({ attachResizeListener: (n, e) => ks(n, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), ky = { current: void 0 }, A8 = v8({ measureScroll: n => ({ x: n.scrollLeft, y: n.scrollTop }), defaultParent: () => { if (!ky.current) { const n = new OW(0, {}); n.mount(window), n.setOptions({ layoutScroll: !0 }), ky.current = n } return ky.current }, resetTransform: (n, e) => { n.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: n => Boolean(window.getComputedStyle(n).position === "fixed") }), zW = { pan: { Feature: iW }, drag: { Feature: nW, ProjectionNode: A8, MeasureLayout: p8 } }, UW = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]), M8 = n => UW.has(n), GW = n => Object.keys(n).some(M8), pC = n => n === pl || n === rt, mC = (n, e) => parseFloat(n.split(", ")[e]), gC = (n, e) => (t, { transform: i }) => { if (i === "none" || !i) return 0; const r = i.match(/^matrix3d\((.+)\)$/); if (r) return mC(r[1], e); { const s = i.match(/^matrix\((.+)\)$/); return s ? mC(s[1], n) : 0 } }, HW = new Set(["x", "y", "z"]), VW = Q0.filter(n => !HW.has(n)); function WW(n) { const e = []; return VW.forEach(t => { const i = n.getValue(t); i !== void 0 && (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0)) }), e.length && n.render(), e } const yC = { width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) => n.max - n.min - parseFloat(e) - parseFloat(t), height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) => n.max - n.min - parseFloat(e) - parseFloat(t), top: (n, { top: e }) => parseFloat(e), left: (n, { left: e }) => parseFloat(e), bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min), right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min), x: gC(4, 13), y: gC(5, 14) }, jW = (n, e, t) => { const i = e.measureViewportBox(), r = e.current, s = getComputedStyle(r), { display: o } = s, a = {}; o === "none" && e.setStaticValue("display", n.display || "block"), t.forEach(u => { a[u] = yC[u](i, s) }), e.render(); const l = e.measureViewportBox(); return t.forEach(u => { const h = e.getValue(u); h && h.jump(a[u]), n[u] = yC[u](l, s) }), n }, JW = (n, e, t = {}, i = {}) => { e = { ...e }, i = { ...i }; const r = Object.keys(e).filter(M8); let s = [], o = !1; const a = []; if (r.forEach(l => { const u = n.getValue(l); if (!n.hasValue(l)) return; let h = t[l], d = Qu(h); const p = e[l]; let m; if (Qm(p)) { const v = p.length, y = p[0] === null ? 1 : 0; h = p[y], d = Qu(h); for (let x = y; x < v; x++)m ? qm(Qu(p[x]) === m) : m = Qu(p[x]) } else m = Qu(p); if (d !== m) if (pC(d) && pC(m)) { const v = u.get(); typeof v == "string" && u.set(parseFloat(v)), typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === rt && (e[l] = p.map(parseFloat)) } else d != null && d.transform && (m != null && m.transform) && (h === 0 || p === 0) ? h === 0 ? u.set(m.transform(h)) : e[l] = d.transform(p) : (o || (s = WW(n), o = !0), a.push(l), i[l] = i[l] !== void 0 ? i[l] : e[l], u.jump(p)) }), a.length) { const l = a.indexOf("height") >= 0 ? window.pageYOffset : null, u = jW(e, n, a); return s.length && s.forEach(([h, d]) => { n.getValue(h).set(d) }), n.render(), j0 && l !== null && window.scrollTo({ top: l }), { target: u, transitionEnd: i } } else return { target: e, transitionEnd: i } }; function XW(n, e, t, i) { return GW(e) ? JW(n, e, t, i) : { target: e, transitionEnd: i } } const QW = (n, e, t, i) => { const r = oW(n, e, i); return e = r.target, i = r.transitionEnd, XW(n, e, t, i) }, X2 = { current: null }, _8 = { current: !1 }; function KW() { if (_8.current = !0, !!j0) if (window.matchMedia) { const n = window.matchMedia("(prefers-reduced-motion)"), e = () => X2.current = n.matches; n.addListener(e), e() } else X2.current = !1 } function YW(n, e, t) { const { willChange: i } = e; for (const r in e) { const s = e[r], o = t[r]; if (Pi(s)) n.addValue(r, s), Ym(i) && i.add(r); else if (Pi(o)) n.addValue(r, Vc(s, { owner: n })), Ym(i) && i.remove(r); else if (o !== s) if (n.hasValue(r)) { const a = n.getValue(r); !a.hasAnimated && a.set(s) } else { const a = n.getStaticValue(r); n.addValue(r, Vc(a !== void 0 ? a : s, { owner: n })) } } for (const r in t) e[r] === void 0 && n.removeValue(r); return e } const w8 = Object.keys(rh), qW = w8.length, vC = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], ZW = XA.length; class $W { constructor({ parent: e, props: t, presenceContext: i, reducedMotionConfig: r, visualState: s }, o = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => qt.render(this.render, !1, !0); const { latestValues: a, renderState: l } = s; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = t.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = o, this.isControllingVariants = X0(t), this.isVariantNode = d6(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(e && e.current); const { willChange: u, ...h } = this.scrapeMotionValuesFromProps(t, {}); for (const d in h) { const p = h[d]; a[d] !== void 0 && Pi(p) && (p.set(a[d], !1), Ym(u) && u.add(d)) } } scrapeMotionValuesFromProps(e, t) { return {} } mount(e) { this.current = e, this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, i) => this.bindToMotionValue(i, t)), _8.current || KW(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : X2.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), Xo.update(this.notifyUpdate), Xo.render(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) this.features[e].unmount(); this.current = null } bindToMotionValue(e, t) { const i = dl.has(e), r = t.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && qt.update(this.notifyUpdate, !1, !0), i && this.projection && (this.projection.isTransformDirty = !0) }), s = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), s() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } loadFeatures({ children: e, ...t }, i, r, s, o) { let a, l; for (let u = 0; u < qW; u++) { const h = w8[u], { isEnabled: d, Feature: p, ProjectionNode: m, MeasureLayout: v } = rh[h]; m && (a = m), d(t) && (!this.features[h] && p && (this.features[h] = new p(this)), v && (l = v)) } if (!this.projection && a) { this.projection = new a(s, this.latestValues, this.parent && this.parent.projection); const { layoutId: u, layout: h, drag: d, dragConstraints: p, layoutScroll: m, layoutRoot: v } = t; this.projection.setOptions({ layoutId: u, layout: h, alwaysMeasureLayout: Boolean(d) || p && hc(p), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof h == "string" ? h : "both", initialPromotionConfig: o, layoutScroll: m, layoutRoot: v }) } return l } updateFeatures() { for (const e in this.features) { const t = this.features[e]; t.isMounted ? t.update(this.props, this.prevProps) : (t.mount(), t.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Sn() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } makeTargetAnimatable(e, t = !0) { return this.makeTargetAnimatableFromInstance(e, this.props, t) } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let i = 0; i < vC.length; i++) { const r = vC[i]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); const s = e["on" + r]; s && (this.propEventSubscriptions[r] = this.on(r, s)) } this.prevMotionValues = YW(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const i = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (i.initial = this.props.initial), i } const t = {}; for (let i = 0; i < ZW; i++) { const r = XA[i], s = this.props[r]; (ih(s) || s === !1) && (t[r] = s) } return t } addVariantChild(e) { const t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { t !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, t)), this.values.set(e, t), this.latestValues[e] = t.get() } removeValue(e) { this.values.delete(e); const t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let i = this.values.get(e); return i === void 0 && t !== void 0 && (i = Vc(t, { owner: this }), this.addValue(e, i)), i } readValue(e) { return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options) } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; const { initial: i } = this.props, r = typeof i == "string" || typeof i == "object" ? (t = t3(this.props, i)) === null || t === void 0 ? void 0 : t[e] : void 0; if (i && r !== void 0) return r; const s = this.getBaseTargetFromProps(this.props, e); return s !== void 0 && !Pi(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, t) { return this.events[e] || (this.events[e] = new r3), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } } class S8 extends $W { sortInstanceNodePosition(e, t) { return e.compareDocumentPosition(t) & 2 ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: i }) { delete t[e], delete i[e] } makeTargetAnimatableFromInstance({ transition: e, transitionEnd: t, ...i }, { transformValues: r }, s) { let o = MH(i, e || {}, this); if (r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s) { xH(this, i, o); const a = QW(this, i, o, t); t = a.transitionEnd, i = a.target } return { transition: e, transitionEnd: t, ...i } } } function ej(n) { return window.getComputedStyle(n) } class tj extends S8 { readValueFromInstance(e, t) { if (dl.has(t)) { const i = a3(t); return i && i.default || 0 } else { const i = ej(e), r = (x6(t) ? i.getPropertyValue(t) : i[t]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return h8(e, t) } build(e, t, i, r) { KA(e, t, i, r.transformTemplate) } scrapeMotionValuesFromProps(e, t) { return e3(e, t) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Pi(e) && (this.childSubscription = e.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } renderInstance(e, t, i, r) { S6(e, t, i, r) } } class nj extends S8 { constructor() { super(...arguments), this.isSVGTag = !1 } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (dl.has(t)) { const i = a3(t); return i && i.default || 0 } return t = C6.has(t) ? t : $A(t), e.getAttribute(t) } measureInstanceViewportBox() { return Sn() } scrapeMotionValuesFromProps(e, t) { return b6(e, t) } build(e, t, i, r) { qA(e, t, i, this.isSVGTag, r.transformTemplate) } renderInstance(e, t, i, r) { E6(e, t, i, r) } mount(e) { this.isSVGTag = ZA(e.tagName), super.mount(e) } } const ij = (n, e) => QA(n) ? new nj(e, { enableHardwareAcceleration: !1 }) : new tj(e, { enableHardwareAcceleration: !0 }), rj = { layout: { ProjectionNode: A8, MeasureLayout: p8 } }, sj = { ...kV, ...ZG, ...zW, ...rj }, Xi = oG((n, e) => DG(n, e, sj, ij)), ri = { paddingX: "sm:px-16 px-6", paddingY: "sm:py-16 py-6", padding: "sm:px-16 px-6 sm:py-16 py-10", heroHeadText: "font-Ceder text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2", heroSubText: "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]", sectionHeadText: "text-white font-Ceder md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]", sectionSubText: "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider" }, e0 = "sharethis", oj = { display: "inline-block", width: "50px", height: "50px", position: "relative", overflow: "hidden", verticalAlign: "middle" }, C8 = { position: "absolute", top: "0", left: "0", width: "100%", height: "100%" }, aj = { ...C8, borderRadius: "50%", fillRule: "evenodd" }, xC = { transition: "fill 170ms ease-in-out", fill: "transparent" }, E8 = function () { let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []; return new RegExp("(?:[/.]|^)($SOCIALS)([.]|$|/)".replace("$SOCIALS", n.join("|").replace(/\./gu, "\\.")), "u") }, mm = new Map, AC = new Set; let b8 = E8(); function Ge(n, e) { return mm.set(n, e), AC.add(n), b8 = E8([...AC].sort((t, i) => i.length - t.length)), e } function lj(n) { var e; return n ? n.startsWith("mailto:") ? "mailto" : ((e = n.match(b8)) == null ? void 0 : e[1]) || e0 : e0 } const Ny = U.forwardRef(function (e, t) { const { as: i = "a", href: r, url: s, network: o, bgColor: a, fgColor: l, className: u, label: h, children: d, fallback: p, defaultSVG: m, ...v } = e, y = o || lj(s), x = h || e["aria-label"] || y, A = (typeof p == "string" ? mm.get(p) : p || m) || mm.get(e0), { color: _, path: M } = y === e0 ? A : mm.get(y) || {}; return U.createElement(i, { href: r || s, className: `social-icon${u ? ` ${u}` : ""}`, ...v, style: { ...oj, ...v.style }, "aria-label": x, ref: t }, U.createElement("span", { className: "social-container", style: C8 }, U.createElement("svg", { role: "img", "aria-label": `${x} social icon`, className: "social-svg", viewBox: "0 0 64 64", style: aj }, U.createElement("g", { className: "social-svg-icon", style: { ...xC, fill: l || "white" } }, U.createElement("path", { d: `M0,0H64V64H0Z${M}` })), U.createElement("g", { className: "social-svg-mask", style: { ...xC, fill: a || _ } }, U.createElement("path", { d: M })))), d) }); Ge("bandsintown", { color: "#1B8793", path: "M0 0v64h64V0zm32.6 24.7h5.6v7.8h-5.6zm-6.8 0h5.6v7.8h-5.6zM44.9 46H19.1V18h5.6v22.4h14.6v-1.1H25.8v-5.6h19V46zm0-13.4h-5.6V18h5.6z" }); Ge("behance", { color: "#007CFF", path: "M40.4 30.1q-.9 0-1.5.3c-.4.2-.7.4-.9.7s-.4.6-.5.9-.2.6-.2.9h6c-.1-.9-.4-1.6-.8-2.1-.5-.5-1.2-.7-2.1-.7m-14.9 2.7h-4.4v5.1h4.3c.4 0 .8 0 1.1-.1.4-.1.7-.2 1-.4s.5-.4.7-.7.2-.7.2-1.2c0-1-.3-1.6-.8-2-.5-.5-1.2-.7-2.1-.7m1.5-3.3c.5-.3.7-.9.7-1.7 0-.4-.1-.8-.2-1.1q-.3-.45-.6-.6-.45-.3-.9-.3c-.3-.1-.7-.1-1-.1h-3.8V30h4.1c.6.1 1.2-.1 1.7-.5M0 0v64h64V0zm36.6 23.8h7.5v1.8h-7.5zm-4.7 14.3c-.4.7-.9 1.2-1.5 1.7-.6.4-1.3.8-2.1 1q-1.2.3-2.4.3H17V22.6h8.7c.9 0 1.7.1 2.4.2.7.2 1.3.4 1.9.8.5.4.9.8 1.2 1.4s.4 1.3.4 2.2-.2 1.7-.6 2.3-1 1.1-1.9 1.5c1.1.3 2 .9 2.5 1.7.6.8.8 1.8.8 3 .1.9-.1 1.7-.5 2.4M47 35.3h-9.6c0 1.1.4 2.1.9 2.6s1.3.8 2.4.8c.7 0 1.4-.2 1.9-.6s.9-.8 1-1.2h3.2c-.5 1.6-1.3 2.8-2.4 3.4-1.1.7-2.4 1-3.9 1-1.1 0-2-.2-2.9-.5-.8-.3-1.6-.8-2.2-1.4s-1-1.4-1.4-2.2c-.3-.9-.5-1.8-.5-2.8s.2-1.9.5-2.8.8-1.6 1.4-2.2 1.3-1.1 2.2-1.5c.8-.4 1.8-.5 2.8-.5 1.1 0 2.1.2 3 .7q1.2.6 2.1 1.8c.5.7.9 1.6 1.2 2.5.3.8.3 1.8.3 2.9" }); Ge("bsky.app", { color: "#1185fe", path: "M0 0v64h64V0Zm45.498 17.766a2.84 2.84 0 0 1 1.354.312c.578.296.932.915 1.103 1.92.085.513.046 2.326-.086 3.666-.013.125-.038.494-.064.822-.02.322-.054.696-.067.82-.013.125-.039.434-.058.69-.027.25-.06.585-.073.736-.02.158-.046.408-.066.559-.099.92-.118 1.07-.13 1.104-.014.02-.041.244-.067.494-.171 1.662-1.354 3.376-2.938 4.263-1.261.703-2.667 1.045-4.336 1.051-.801.007-.927.041-.447.133.94.17 2.005.518 2.86.945 2.247 1.11 3.041 2.747 2.331 4.778-.118.322-.25.636-.302.695-.053.052-.092.131-.092.164 0 .066-.617 1.025-.8 1.242-.06.072-.219.264-.35.428-.355.434-1.004 1.097-1.346 1.373-.164.131-.31.25-.33.27-.184.203-1.333.946-1.938 1.261-.808.42-1.425.591-2.135.598-.722.006-.953-.033-1.439-.256-1.386-.63-2.418-2.34-3.39-5.586-.421-1.426-.54-1.826-.598-2.082-.066-.276-.131-.218-.256.223-.381 1.38-1.117 3.344-1.623 4.363-.92 1.853-1.927 2.937-3.11 3.357-.499.178-1.45.166-2.029-.025-1.452-.486-2.899-1.623-4.357-3.443-1.426-1.774-2.116-3.292-2.037-4.475.046-.69.118-.933.447-1.426.302-.453.841-.914 1.44-1.236.426-.23 1.28-.584 1.609-.676.111-.026.375-.099.592-.158.216-.066.453-.126.525-.139.867-.17 1.255-.255 1.295-.281.026-.02-.302-.04-.723-.047-.42 0-.947-.026-1.164-.053-.453-.059-1.445-.276-1.642-.36a6 6 0 0 0-.46-.17c-1.241-.441-2.378-1.33-3.087-2.427-.316-.486-.659-1.221-.73-1.576a10 10 0 0 1-.19-1.123c-.027-.217-.054-.466-.067-.558a33 33 0 0 1-.197-1.873c-.026-.29-.053-.632-.066-.756a72 72 0 0 1-.073-.756c-.02-.29-.05-.631-.064-.756-.164-1.938-.172-3.68-.008-4.238.302-1.019.73-1.466 1.623-1.715.29-.08 1.157-.078 1.531.008 1.183.25 3.576 1.655 5.008 2.93.072.065.237.21.361.322.927.828 2.543 2.522 3.358 3.521.23.29.447.553.486.592.033.04.139.17.23.289.093.118.196.25.23.29.098.104 1.065 1.43 1.486 2.042.492.71 1.201 1.847 1.378 2.229.138.282.256.387.256.236 0-.105.836-1.485 1.434-2.365 1.866-2.76 4.257-5.488 6.353-7.262.566-.473.769-.63 1.63-1.22 1.648-1.126 2.937-1.676 4.015-1.688" }); Ge("clubhouse", { color: "#1F1F1A", path: "M0 0v64.271h64.203V0zm32.694 15.453c1.277 0 2.24.566 2.804 1.842.824-.538 1.956-.738 2.92-.483 1.305.34 2.1 1.249 2.581 4.03.17.882.423 1.96.735 2.895.396 1.194.85 2.128 1.643 3.518.255.425.566.908.878 1.361l.256-.51c.764-1.562 2.268-3.093 4.45-3.093.937 0 1.956.34 2.522 1.305a3.04 3.04 0 0 1 .51 1.7c0 .737-.311 1.475-.566 2.042-.057.114-.084.17-.084.198-.652 1.36-1.53 3.066-1.53 5.05 0 5.76-2.127 8.71-3.77 10.242-1.674 1.562-4.28 2.893-7.313 2.893-2.152 0-4.393-.623-6.234-1.843-2.52-1.672-4.052-4.255-5.44-6.524-1.136-1.9-1.958-3.43-3.176-6.324-.708-1.617-1.36-3.293-1.897-5.079-.482-1.562-.228-2.696.393-3.433.625-.766 1.505-1.135 2.468-1.192.17 0 .34.001.51.03a6 6 0 0 1-.2-1.475c0-1.846 1.448-3.207 3.403-3.207.255 0 .51.028.736.085-.028-.312-.056-.567-.056-.822 0-2.016 1.644-3.206 3.457-3.206m0 1.704c-.822 0-1.812.424-1.812 1.502 0 .709.197 1.758.395 2.606.34.825.398 1.336.823 3.122.255 1.052.565 1.958.877 2.752.368.967.793 1.79 1.388 2.896.283.538.426.539 1.106.17.538-.284 1.33-.625 1.924-.824-1.02-2.211-1.869-4.057-2.294-5.616-.113-.454-.51-2.272-.623-3.066-.085-.794-.17-1.473-.368-2.21-.226-.908-.538-1.332-1.416-1.332m4.87 1.252c-.445-.004-.919.14-1.216.395-.312.283-.425.509-.34 1.132.142 1.364.368 2.414.623 3.406.595 2.325 1.585 4.142 2.095 5.22.17.368.313.511.596.483.397-.029.623-.058.878-.03.34.029.596.228.596.568 0 .283-.143.397-.653.51-1.048.227-2.38.595-3.684 1.333-1.107.626-2.07 1.392-2.948 2.498-.085.113-.172.17-.313.17-.198 0-.368-.227-.538-.454s-.283-.397-.283-.567c0-.199.085-.37.283-.624.312-.426.68-.737.68-.935 0-.142-.254-.482-.48-.879-.368-.68-.992-2.044-1.417-3.065-.651-1.56-1.105-3.546-1.36-4.766-.312-1.332-.794-1.702-1.53-1.702-1.02 0-1.698.595-1.698 1.503 0 .598.197 1.391.594 2.696.255.85.51 1.7.736 2.296a53 53 0 0 0 1.218 3.066c.368.822.906 1.787 1.16 2.269.142.255.397.68.397.935 0 .454-.338.708-.791.708-.255 0-.482-.113-.737-.51-.311-.457-.992-1.788-1.473-2.78-.369-.823-.992-2.3-1.304-3.32-.51-1.616-.85-2.24-1.727-2.213-.51.029-.936.2-1.247.568-.312.397-.339 1.02-.084 1.843.538 1.73 1.163 3.317 1.835 4.943 1.192 2.807 1.957 4.257 3.062 6.1 1.388 2.268 2.75 4.538 4.93 5.984 1.558 1.02 3.46 1.561 5.3 1.561 2.578 0 4.762-1.137 6.15-2.441 1.419-1.305 3.23-3.859 3.23-8.993 0-2.354 1.02-4.4 1.644-5.732.17-.34.537-1.049.537-1.56 0-.226-.055-.537-.197-.764-.255-.397-.652-.54-1.133-.54-1.504 0-2.468 1.136-3.006 2.128a7 7 0 0 0-.537 1.36c-.312 1.049-.624 1.475-1.53 2.212-.482.426-1.076.964-1.415 1.39-.567.767-.738 1.42-.88 2.44-.028.256-.51.369-1.104.369-.34 0-.453-.113-.453-.652 0-.567.198-1.418.623-2.183.595-1.05 1.246-1.617 1.898-2.156s.85-.765.963-1.105c-.595-.797-1.16-1.618-1.614-2.412-.822-1.446-1.36-2.526-1.784-3.83a25 25 0 0 1-.794-3.152c-.34-1.988-.679-2.497-1.33-2.667a1.8 1.8 0 0 0-.428-.054m-23.056.313c.206-.014.437.052.698.187.806.42 3.65 2.637 4.193 3.076.526.422.454.641.178 1.185-.275.544-.533.683-1.022.528-.978-.309-3.882-2.07-4.64-2.523-.684-.413-.773-.784-.296-1.689.264-.499.545-.742.889-.764m-1.79 9.45c.139-.014.296-.005.469.012.803.077 4.524.682 5.116.865.613.19.698.47.623 1.005-.095.696-.409.829-.81.841-.855.024-4.407-.129-5.218-.209-.706-.07-.992-.381-.915-1.404.062-.824.319-1.068.735-1.11m7.768 7.597c.308.018.54.218.713.653.255.637.08.89-.463 1.228-.6.372-3.78 2.04-4.499 2.305-.512.19-1.068.146-1.395-.824-.402-1.198.162-1.482.965-1.794.711-.275 3.66-1.344 4.345-1.53a1 1 0 0 1 .334-.038" }); Ge("codepen", { color: "#151515", path: "M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m.5-25.7q-.45-.3-.9 0l-9.1 5.9c-.2.2-.4.4-.4.7v6.2c0 .3.1.6.4.7l9.1 5.9q.45.3.9 0l9.1-5.9c.2-.2.4-.4.4-.7v-6.2c0-.3-.1-.6-.4-.7zm.3 2.2 6.8 4.5-3 2-3.7-2.5v-4zm-1.6 0v4L27.4 31l-3-2zm-7.4 6.1 2.1 1.4-2.1 1.4zm7.4 8.9L24.4 35l3-2 3.7 2.5v4zM32 34l-3-2 3-2 3 2zm.8 5.5v-4l3.7-2.5 3 2zm7.4-6.1L38.1 32l2.1-1.4z" }); Ge("developer.mozilla", { color: "#236ab4", path: "M0 0v64h64V0zm32 48.35h-3.69v-32.7l-10.15 32.7h-4.15l10.11-32.7H32zm18 0h-3.69v-32.7l-10.12 32.7h-4.15l10.11-32.7H50z" }); Ge("discord", { color: "#5865F2", path: "M0 0v64h64V0zm36.903 18.5a29.6 29.6 0 0 1 7.374 2.269c4.045 5.914 6.055 12.585 5.313 20.283a29.6 29.6 0 0 1-9.05 4.537 21.7 21.7 0 0 1-1.936-3.12 19.3 19.3 0 0 0 3.055-1.46 11 11 0 0 1-.747-.562 21.25 21.25 0 0 1-18.082 0c-.242.186-.492.377-.748.562a19 19 0 0 0 3.05 1.457 22 22 0 0 1-1.937 3.123 29.7 29.7 0 0 1-9.043-4.54c-.633-6.638.632-13.37 5.299-20.275a29.8 29.8 0 0 1 7.38-2.274q.522.935.944 1.92a27.5 27.5 0 0 1 8.183 0q.422-.985.945-1.92m-10.97 18.467c-1.762 0-3.218-1.6-3.218-3.568s1.405-3.581 3.213-3.581c1.807 0 3.252 1.614 3.222 3.581-.031 1.968-1.42 3.568-3.216 3.568m11.875 0c-1.765 0-3.216-1.6-3.216-3.568s1.406-3.581 3.216-3.581 3.244 1.614 3.213 3.581c-.03 1.968-1.417 3.568-3.213 3.568" }); Ge("dribbble", { color: "#ea4c89", path: "M34.3 34.3c-7.7 2.7-10.5 8-10.7 8.5 2.3 1.8 5.2 2.9 8.4 2.9 1.9 0 3.7-.4 5.3-1.1-.2-1.2-1-5.4-3-10.3.1-.1.1 0 0 0m-3-6.7c-2.3-4-4.7-7.4-5.1-7.9-3.8 1.8-6.7 5.3-7.6 9.6.6-.1 6.3 0 12.7-1.7m1.7 4.5c.2-.1.4-.1.5-.2-.3-.8-.7-1.6-1.1-2.3-6.8 2-13.4 2-14 1.9v.4c0 3.5 1.3 6.7 3.5 9.1.3-.4 4-6.6 11.1-8.9m8.1-10.3c-2.4-2.1-5.6-3.4-9.1-3.4-1.1 0-2.2.1-3.2.4.4.5 2.9 3.9 5.1 8 4.9-1.9 6.9-4.7 7.2-5m-6.2 7c.3.7.6 1.3.9 2 .1.2.2.5.3.7 4.5-.6 9.1.3 9.5.4 0-3.2-1.2-6.2-3.1-8.5-.2.4-2.5 3.3-7.6 5.4m2.1 4.8c1.8 4.9 2.5 8.9 2.7 9.7 3.1-2.1 5.2-5.4 5.9-9.2-.6-.1-4.3-1.2-8.6-.5M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16" }); Ge("dropbox", { color: "#1081DE", path: "M0 0v64h64V0zm41.5 41.2L32 46.9l-9.4-5.7v-2.1l2.8 1.8 6.6-5.5 6.6 5.5 2.8-1.8v2.1zm6.5-7.5-9.4 6.1-6.6-5.5-6.6 5.5-9.4-6.1 6.5-5.2-6.5-5.2 9.4-6.1 6.6 5.5 6.6-5.5 9.4 6.1-6.5 5.2zm-25.5-5.2 9.5 5.9 9.5-5.9-9.5-5.9z" }); Ge("email", { color: "#7f7f7f", path: "M41.1 25H22.9l9.1 7.1zm2.9 1.6-12 9.3-12-9.3V39h24zM0 0v64h64V0zm47 42H17V22h30z" }); Ge("facebook", { color: "#3b5998", path: "M0 0v64h64V0zm39.6 22h-2.8c-2.2 0-2.6 1.1-2.6 2.6V28h5.3l-.7 5.3h-4.6V47h-5.5V33.3H24V28h4.6v-4c0-4.6 2.8-7 6.9-7 2 0 3.6.1 4.1.2z" }); Ge("fivehundredpix", { color: "#222222", path: "M33.3 31.3c-.4-.2-.7-.4-1.1-.6-.3-.1-.8-.1-.9-.1-1.1 0-1.9.6-2.2 2.1v.9c0 .1.1.4.2.7.3.9 1.4 1.3 2.1 1.3s1.2-.2 1.9-.6c.5-.3 1-.7 1.4-1.1.2-.2.5-.5.5-.6.1-.5-1.5-1.7-1.9-2m9.5-.7c-1.3 0-2.4 1-3.8 2.6 1.3 1.5 2.6 2.3 3.9 2.3 1.5 0 2.2-1.1 2.2-2.4.1-1.4-.8-2.5-2.3-2.5M0 0v64h64V0zm42.9 38.5c-2 0-3.8-1-5.7-3.3-2.2 2.4-3.7 3.3-5.7 3.3-1.8 0-3.7-.7-4.8-3.1-1.2 2.5-3.3 3.2-5.1 3.2-1.6 0-3.8-.4-5-2.5-.1-.1-.6-1.3-.6-1.6v-.7h3c.1 1.6 1.3 2.2 2.4 2.2 1.3 0 2.4-.9 2.6-2.6v-.7c-.2-1.8-1.3-2.4-2.6-2.4-.8 0-1.6.2-2.3 1.2h-2.7v-.2l1.5-8h8.4v2.5h-6.2l-.6 3.3c1-.9 2-1.1 2.9-1.1 1.4 0 3.2.6 4.1 2.6 1-2.4 3-3.2 4.7-3.2 2 0 3.9 1 5.8 3.5 2.1-2.6 3.7-3.5 5.8-3.5 3.3 0 5.1 2.4 5.1 5.4.1 3.1-1.7 5.7-5 5.7" }); Ge("flickr", { color: "#0063db", path: "M38 27c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m-6-21c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5" }); Ge("foursquare", { color: "#0072b1", path: "M39.7 20.4H26.4c-.6 0-1 .5-1 1v20.5c0 .1 0 .1.1 0 0 0 4.9-5.9 5.4-6.5.5-.7.8-.8 1.6-.8H37c.6 0 1-.5 1-.8.1-.3.6-3 .7-3.6.1-.5-.4-1.1-.9-1.1h-5.5c-.7 0-1.2-.5-1.2-1.2v-.8c0-.7.5-1.2 1.2-1.2h6.4c.5 0 .9-.4 1-.8l.7-3.6c.2-.6-.2-1.1-.7-1.1M0 0v64h64V0zm44 20.9-1 5.2c-.8 4.2-1.8 9-1.9 9.5-.2.9-.6 2.4-2.7 2.4h-5.1c-.2 0-.2 0-.4.2-.1.1-7.9 9.2-7.9 9.2-.6.7-1.6.6-2 .4-.4-.1-1-.6-1-1.8V19.7c0-1.1.7-2.8 3-2.8h16.5c2.4.1 3.1 1.5 2.5 4" }); Ge("github", { color: "#24292e", path: "M0 0v64h64V0zm37.1 47.2c-.8.2-1.1-.3-1.1-.8V42c0-1.5-.5-2.5-1.1-3 3.6-.4 7.3-1.7 7.3-7.9 0-1.7-.6-3.2-1.6-4.3.2-.4.7-2-.2-4.2 0 0-1.3-.4-4.4 1.6-1.3-.4-2.6-.5-4-.5s-2.7.2-4 .5c-3.1-2.1-4.4-1.6-4.4-1.6-.9 2.2-.3 3.8-.2 4.2-1 1.1-1.6 2.5-1.6 4.3 0 6.1 3.7 7.5 7.3 7.9-.5.4-.9 1.1-1 2.1-.9.4-3.2 1.1-4.7-1.3 0 0-.8-1.5-2.5-1.6 0 0-1.6 0-.1 1 0 0 1 .5 1.8 2.3 0 0 .9 3.1 5.4 2.1v2.7c0 .4-.3.9-1.1.8-6.3-2-10.9-8-10.9-15.1 0-8.8 7.2-16 16-16s16 7.2 16 16c0 7.1-4.6 13.1-10.9 15.2" }); Ge("gitlab", { color: "#f96424", path: "M0 0v64h64V0zm50.402 32.559-1.969-6.066v.007-.011L44.52 14.454a1.54 1.54 0 0 0-1.476-1.055c-.68.004-1.25.422-1.461 1.062l-3.715 11.426h-11.72l-3.722-11.426a1.52 1.52 0 0 0-1.46-1.062h-.009c-.664 0-1.257.422-1.472 1.062L15.58 26.488v.004s0 .004-.004.008q.005-.007.004-.008l-1.98 6.067c-.297.914.027 1.91.805 2.476l17.082 12.402q.006-.001.007.004c.008.004.016.012.024.016-.008-.004-.012-.012-.02-.016l.004.004h.004q.035.028.082.051l.008.008h.004l.004.004h.008q0 .005.003.004c.004 0 .004.004.008.004q.024.009.047.02.022.006.043.015v.004h.008q.006.004.012.003h.004c0 .004.007.004.011.004h.004q.03.011.063.016.012.007.023.008h.004l.008.004h.015q.004-.001.008.004h.004q.061.006.121.007h.004q.061 0 .121-.007h.004q.006-.005.012-.004h.012q.007-.002.007-.004h.004l.028-.008.062-.016h.004q.006.001.012-.004h.004s.004 0 .008-.003h.007v-.004c.016-.004.032-.012.047-.016l.043-.02.008-.003h.004q.004-.005.008-.004l.008-.004.011-.008q.042-.023.082-.05.002.001.004-.005h.004q.004-.005.008-.004L49.6 35.035a2.21 2.21 0 0 0 .8-2.476zm-7.352-16.98 3.352 10.309h-6.7zm2.766 12.051-1.367 1.75-10.086 12.91 4.77-14.66zM31.171 47.001q.005.004.004.008.001-.004-.004-.008m-1.527-4.707L18.199 27.63h6.68zm-8.688-26.715 3.356 10.309h-6.703zm-5.523 18.047a.47.47 0 0 1-.172-.527l1.473-4.512 10.773 13.805zM31.46 47.415q-.006-.007-.012-.008v-.004q-.013-.008-.02-.015-.022-.018-.039-.036c.004 0 .004.004.004.004s.004 0 .004.004c.028.024.051.047.078.067h.004s0 .004.004.004c-.008-.004-.015-.012-.023-.016m.543-3.504-2.805-8.625-2.484-7.656H37.3zm.574 3.477q-.013.008-.02.015-.004-.001-.003.004a.01.01 0 0 0-.008.008c-.008.004-.016.012-.024.016 0 0 0-.004.004-.004a1 1 0 0 0 .078-.067l.004-.004s.004 0 .004-.003zm15.996-13.762-12.074 8.761L47.28 28.59l1.465 4.508a.47.47 0 0 1-.172.528" }); Ge("google", { color: "#dd4b39", path: "M0 0v64h64V0zm31.3 19.1q.45.45.9 1.2c.3.4.5.9.7 1.5q.3.9.3 2.1c0 1.4-.3 2.6-.9 3.4l-.9 1.2c-.4.4-.8.7-1.2 1.1-.2.2-.5.5-.7.8s-.4.7-.4 1.1.1.8.4 1c.2.3.4.5.6.7l1.4 1.1c.8.7 1.6 1.5 2.2 2.3s.9 2 .9 3.3c0 1.9-.9 3.7-2.6 5.2-1.8 1.6-4.3 2.4-7.7 2.4q-4.2 0-6.3-1.8-2.1-1.65-2.1-3.9c0-.7.2-1.6.7-2.5q.6-1.35 2.4-2.4c1.3-.7 2.7-1.2 4.1-1.5 1.4-.2 2.6-.3 3.5-.4-.3-.4-.5-.8-.8-1.2s-.4-.9-.4-1.5c0-.4 0-.6.2-.9.1-.2.2-.5.2-.7-.5.1-.9.1-1.3.1-2.1 0-3.8-.7-4.9-2-1.2-1.2-1.8-2.7-1.8-4.3 0-2 .8-3.8 2.5-5.4 1.1-.9 2.3-1.6 3.5-1.8s2.3-.4 3.4-.4h8L33 18.4h-2.5c.2.2.5.4.8.7M48 32h-4.3v4.2h-2.5V32H37v-2.5h4.2v-4.3h2.5v4.3H48zM27.1 19.1c-.6-.5-1.4-.7-2.2-.7-1.1 0-2 .5-2.7 1.3q-.9 1.35-.9 3c0 1.5.4 3 1.3 4.5.4.7.9 1.4 1.6 1.9.6.5 1.4.8 2.2.8 1.1 0 1.9-.4 2.6-1.1.3-.5.6-1 .7-1.6.1-.5.1-1 .1-1.4q0-2.4-1.2-4.8c-.4-.8-.9-1.5-1.5-1.9m-.2 17.1c-.2 0-.7 0-1.6.1-.8.1-1.7.3-2.5.6-.2.1-.5.2-.9.4s-.7.4-1.1.7q-.6.45-.9 1.2c-.3.5-.4 1.1-.4 1.8 0 1.4.6 2.6 1.9 3.5 1.2.9 2.9 1.4 5 1.4 1.9 0 3.3-.4 4.3-1.3 1-.8 1.5-1.8 1.5-3.1 0-1-.3-1.9-1-2.7-.7-.7-1.8-1.6-3.3-2.6z" }); Ge("google_play", { color: "#40BBC1", path: "M0 0v64h64V0zm40.4 27.1-3.6 3.6-12.3-12.3zM22 44.5V19.4c0-.4.1-.7.2-.9L35.6 32 22.2 45.4c-.1-.2-.2-.5-.2-.9m2.4 1.1 12.4-12.4 3.6 3.6zm22.7-12.4-5 2.8-4-4 3.9-3.9 5.1 2.8c1.2.5 1.2 1.6 0 2.3" }); Ge("groupme", { color: "#00aff0", path: "M0 0v64h64V0zm40.321 39.434a10.4 9.517 0 0 1-16.64 0 2.6 2.38 0 1 0-4.161 2.856 15.6 14.276 0 0 0 24.961 0 2.6 2.38 0 0 0-4.16-2.856m-17.42-12.848a2.6 2.38 0 0 0 0 4.759h1.3v1.19a2.6 2.38 0 0 0 5.2 0v-1.19h5.2v1.19a2.6 2.38 0 0 0 5.2 0v-1.19h1.3a2.6 2.38 0 0 0 0-4.759h-1.3v-4.758h1.3a2.6 2.38 0 0 0 0-4.759h-1.3v-1.19a2.6 2.38 0 0 0-5.2 0v1.19h-5.2v-1.19a2.6 2.38 0 0 0-5.2 0v1.19h-1.3a2.6 2.38 0 0 0 0 4.759h1.3v4.758zm6.5-4.758h5.2v4.758h-5.2z" }); Ge("instagram", { color: "#e94475", path: "M0 0v64h64V0zm39.88 25.89c.98 0 1.77-.79 1.77-1.77s-.79-1.77-1.77-1.77-1.77.79-1.77 1.77.79 1.77 1.77 1.77M32 24.42c-4.18 0-7.58 3.39-7.58 7.58s3.4 7.58 7.58 7.58 7.58-3.4 7.58-7.58-3.4-7.58-7.58-7.58m0 12.5c-2.72 0-4.92-2.2-4.92-4.92s2.2-4.92 4.92-4.92 4.92 2.2 4.92 4.92-2.2 4.92-4.92 4.92m0-17.02c3.94 0 4.41.02 5.96.09 1.45.06 2.23.3 2.75.51.69.27 1.18.58 1.7 1.1.51.52.83 1.01 1.1 1.7.2.52.44 1.3.51 2.74.07 1.56.09 2.02.09 5.97 0 3.94-.02 4.4-.09 5.96-.07 1.44-.31 2.22-.51 2.74-.27.69-.59 1.19-1.1 1.7-.52.52-1.01.84-1.7 1.1-.52.2-1.3.45-2.75.51-1.55.07-2.02.09-5.96.09s-4.41-.02-5.96-.09c-1.45-.06-2.23-.3-2.75-.51-.69-.27-1.18-.58-1.7-1.1-.51-.51-.83-1.01-1.1-1.7-.2-.52-.44-1.3-.51-2.74-.07-1.56-.09-2.02-.09-5.96 0-3.95.02-4.41.09-5.97.07-1.44.31-2.22.51-2.74.27-.69.59-1.18 1.1-1.7.52-.52 1.01-.84 1.7-1.1.52-.2 1.3-.45 2.75-.51 1.55-.08 2.02-.09 5.96-.09m0-2.66c-4.01 0-4.51.02-6.09.09-1.57.07-2.64.32-3.58.68-.97.38-1.79.89-2.61 1.71s-1.33 1.65-1.71 2.61c-.36.94-.61 2.01-.68 3.59-.07 1.57-.09 2.07-.09 6.08s.02 4.51.09 6.09c.07 1.57.32 2.64.68 3.58.38.98.89 1.8 1.71 2.62s1.65 1.32 2.61 1.7c.94.37 2.01.62 3.59.69 1.57.07 2.07.09 6.09.09 4.01 0 4.51-.02 6.08-.09s2.65-.32 3.59-.69c.97-.37 1.79-.88 2.61-1.7s1.33-1.65 1.71-2.62c.36-.93.61-2.01.68-3.58.07-1.58.09-2.08.09-6.09s-.02-4.51-.09-6.09c-.07-1.57-.32-2.64-.68-3.58-.38-.98-.89-1.8-1.71-2.62a7.3 7.3 0 0 0-2.61-1.7c-.94-.37-2.01-.62-3.59-.69-1.58-.06-2.08-.08-6.09-.08" }); Ge("itch.io", { color: "#fa5c5c", path: "M0 0v64h64V0zm32 16c4.482 0 7.49.028 11.828.197 1.396.921 4.146 4.435 4.172 5.356v1.523c0 1.933-1.624 3.631-3.1 3.631-1.771 0-3.248-1.631-3.248-3.568 0 1.937-1.425 3.568-3.197 3.568-1.771 0-3.152-1.631-3.152-3.568 0 1.937-1.516 3.568-3.287 3.568h-.032c-1.771 0-3.287-1.631-3.287-3.568 0 1.937-1.38 3.568-3.152 3.568s-3.197-1.631-3.197-3.568c0 1.937-1.477 3.568-3.248 3.568-1.476 0-3.1-1.698-3.1-3.63v-1.524c.026-.921 2.776-4.434 4.172-5.356C21.407 16.077 27.518 16 32 16m-3.326 9.797a3.65 4.058 0 0 0 .619.892 3.716 4.13 0 0 0 2.602 1.178q.053 0 .105-.002l.107.002a3.716 4.13 0 0 0 2.602-1.178 3.65 4.058 0 0 0 .617-.892 3.655 4.063 0 0 0 .623.892c.669.727 1.585 1.178 2.596 1.178a3.714 4.129 0 0 0 2.601-1.178c.243-.263.427-.546.596-.875.169.33.404.611.647.875a3.717 4.132 0 0 0 2.601 1.178c.122 0 .25-.037.352-.076a66 66 0 0 1 .222 4.373l.002.006.008 1.73c-.027 3.46.307 11.21-1.373 13.116-2.603.674-7.395.982-12.201.984-4.806-.002-9.598-.31-12.201-.984-1.68-1.905-1.344-9.657-1.371-13.116.002-.666.005-1.147.008-1.73v-.006c.02-1.149.08-2.724.222-4.373.103.04.23.076.352.076a3.717 4.132 0 0 0 2.601-1.178c.243-.264.478-.545.647-.875.168.329.353.612.596.875a3.714 4.129 0 0 0 2.601 1.178c1.01 0 1.927-.45 2.596-1.178a3.655 4.063 0 0 0 .623-.892m9.324 3.84v.002h-.002c-1.058.002-1.997 0-3.162 1.414a24 24 0 0 0-2.834-.16 24 24 0 0 0-2.834.16c-1.165-1.413-2.104-1.412-3.162-1.414h-.002c-.5 0-2.5 0-3.893 4.35l-1.496 5.966c-1.109 4.44.354 4.549 2.18 4.553 2.708-.112 4.209-2.298 4.209-4.485 1.5.274 3.249.41 4.998.41s3.499-.136 4.998-.41c0 2.187 1.499 4.373 4.207 4.485 1.826-.004 3.29-.113 2.182-4.553l-1.496-5.967c-1.394-4.35-3.393-4.351-3.893-4.351M32 33.057s2.851 2.91 3.363 3.945l-1.865-.082v1.809c0 .084-.749.05-1.498.011-.75.039-1.498.073-1.498-.011v-1.81l-1.865.083c.512-1.034 3.36-3.943 3.363-3.945" }); Ge("itunes", { color: "#E049D1", path: "M0 0v64h64V0zm42.5 40c0 2.2-1.8 4-4 4h-2c-1.9 0-3.4-1.5-3.4-3.4s1.5-3.4 3.4-3.4h2.8c.8 0 1.4-.6 1.4-1.4v-11c0-.5-.4-.9-.9-.9h-.2l-12.1 2.4c-.4.1-.7.4-.7.9V43c0 2.2-1.8 4-4 4h-2c-1.9 0-3.4-1.5-3.4-3.4s1.5-3.4 3.4-3.4h2.8c.8 0 1.4-.6 1.4-1.4V21.3c0-.7.5-1.2 1.1-1.4l14.7-3h.3c.8 0 1.4.6 1.4 1.4z" }); Ge("leetcode", { color: "#E7A41F", path: "M0 0h64v64H0zm42.05 42.07a2.12 2.12 0 0 0-3.069-.005l-3.77 3.885a4.65 4.65 0 0 1-6.616.06l-6.758-6.84c-1.824-1.846-2.143-4.74-.56-6.49l6.21-6.625c1.664-1.84 5.04-2.061 6.97-.45l5.508 4.596c.932.779 2.299.628 3.052-.336s.607-2.377-.326-3.156l-5.507-4.596c-1.204-1.005-2.649-1.641-4.161-1.917L36.5 16.5c.85-.91.947-2.264.04-3.116a2.245 2.245 0 0 0-3.181.107l-9.043 9.499-6.063 6.7c-3.252 3.594-2.908 9.19.548 12.688l6.79 6.871a8.887 8.887 0 0 0 12.685-.12l3.77-3.886a2.3 2.3 0 0 0 .005-3.173m-14.396-6.016c0 1.24.971 2.244 2.17 2.244H45.83c1.198 0 2.17-1.005 2.17-2.244s-.972-2.244-2.17-2.244H29.824c-1.199 0-2.17 1.005-2.17 2.244" }); Ge("line.me", { color: "#4cc764", path: "M0 0h64v64H0Zm27.54 13.171a26 26 0 0 1 6.17-.319c3.058.196 5.992.9 8.776 2.19 3.394 1.572 6.257 3.797 8.336 6.945 1.942 2.94 2.79 6.171 2.425 9.69-.286 2.758-1.398 5.185-3.046 7.382s-3.614 4.082-5.734 5.811c-3.558 2.901-7.32 5.505-11.32 7.758-.463.26-.954.469-1.437.69a2.4 2.4 0 0 1-.457.14c-.9.212-1.32-.166-1.184-1.077.099-.663.247-1.32.322-1.986.062-.558.074-1.124.062-1.686-.01-.494-.3-.862-.747-1.026-.574-.211-1.166-.405-1.767-.504-4.812-.789-9.1-2.66-12.59-6.137-2.247-2.238-3.792-4.89-4.423-8.028-.762-3.794-.064-7.333 1.949-10.61 1.868-3.044 4.503-5.257 7.642-6.896 2.205-1.15 4.545-1.912 7.023-2.337m4.31 18.669v-2.078c.126.159.192.239.254.323 1.294 1.747 2.59 3.492 3.875 5.244.176.24.369.352.67.335.392-.022.787-.004 1.181-.006.414-.002.54-.12.541-.529q.003-4.543 0-9.085c0-.4-.133-.531-.542-.538-.394-.006-.788-.002-1.182-.001-.512.002-.618.107-.618.621v5.291c-.149-.192-.234-.299-.316-.409-1.28-1.73-2.563-3.458-3.837-5.193-.153-.209-.324-.318-.585-.313-.426.01-.852-.004-1.278.004-.369.008-.503.14-.504.51q-.006 4.575 0 9.15c.001.362.143.488.516.491q.639.005 1.279 0c.428-.002.545-.118.546-.555.002-1.066 0-2.132 0-3.263m12.106 1.473h-1.79v-1.558h.366q1.79.001 3.58-.001c.39 0 .52-.125.527-.514.008-.405.004-.81.001-1.216-.002-.507-.11-.614-.627-.614l-3.484-.002c-.123 0-.245-.012-.355-.018v-1.54h.38q1.773.001 3.546-.001c.409 0 .533-.124.539-.535q.01-.656-.001-1.312c-.006-.35-.137-.493-.486-.494q-2.925-.009-5.849 0c-.353 0-.48.14-.48.489q-.003 4.59 0 9.18c0 .356.125.479.484.48q2.907.003 5.816 0c.383 0 .51-.13.516-.525q.007-.624 0-1.248c-.003-.447-.122-.568-.574-.57-.681-.005-1.363-.002-2.109-.002m-26.32 1.893c.006.32.178.454.488.454 1.949-.002 3.898 0 5.847-.002.35 0 .476-.13.482-.486.006-.395.002-.79.002-1.184 0-.585-.087-.674-.66-.674l-3.451-.001c-.113 0-.226-.01-.365-.018v-7.159c0-.519-.106-.627-.612-.63q-.56-.003-1.118 0c-.515.001-.613.101-.613.622zm10.432-1.51v-7.606c0-.465-.117-.581-.589-.585q-.543-.002-1.085 0c-.58 0-.68.103-.681.693v8.756c0 .086-.004.171.002.256.024.286.163.451.468.45.468-.003.936.003 1.405-.002.34-.004.475-.144.478-.492.004-.468.001-.937.001-1.47z" }); Ge("linkedin", { color: "#007fb1", path: "M0 0v64h64V0zm25.8 44h-5.4V26.6h5.4zm-2.7-19.7c-1.7 0-3.1-1.4-3.1-3.1s1.4-3.1 3.1-3.1 3.1 1.4 3.1 3.1-1.4 3.1-3.1 3.1M46 44h-5.4v-8.4c0-2 0-4.6-2.8-4.6s-3.2 2.2-3.2 4.5V44h-5.4V26.6h5.2V29h.1c.7-1.4 2.5-2.8 5.1-2.8 5.5 0 6.5 3.6 6.5 8.3V44z" }); Ge("linktree", { color: "#39e09b", path: "M0 0v64h64V0zm27.436 19.386c-.6-.948-2.162-.948-2.762 0L14.344 35.83c-.48.843.24 1.792 1.322 1.792h6.966v6.218c0 .633.6 1.16 1.321 1.16h4.083c.721 0 1.321-.527 1.321-1.16v-6.218h-1.921c-.84 0-1.441-.527-1.562-1.16 0-.21 0-.421.12-.635l5.766-9.17zm9.128 0c.6-.948 2.162-.948 2.762 0l10.33 16.444c.48.843-.24 1.792-1.322 1.792h-6.846v6.218c0 .633-.6 1.16-1.322 1.16h-4.323c-.72 0-1.32-.527-1.32-1.16v-6.218h1.921c.84 0 1.441-.527 1.561-1.16 0-.21 0-.421-.12-.635L32.12 26.66z" }); Ge("mailto", { color: "#7f7f7f", path: "M41.1 25H22.9l9.1 7.1zm2.9 1.6-12 9.3-12-9.3V39h24zM0 0v64h64V0zm47 42H17V22h30z" }); Ge("mastodon", { color: "#17063B", path: "M-.135-.135v64.541h64.678V-.134ZM31.91 16c4.394-.016 8.82.462 11.213 1.488 0 0 4.875 2.042 4.875 8.992 0 0 .064 5.126-.684 8.688-.477 2.26-4.218 4.734-8.515 5.213-1.54.17-7.13 1.013-13.686-.48q-.002.5.069.995c.507 3.546 3.767 3.76 6.861 3.86 3.123.093 5.646-.723 5.646-.723l.13 2.639s-1.924 1.093-5.815 1.295c-2.144.113-4.811-.05-7.912-.815C15.994 45.143 16 34.754 16 26.48c0-6.95 4.883-8.992 4.883-8.992 2.27-.96 6.633-1.472 11.027-1.488m-4.703 5.3c-1.505-.036-3.027.51-4.016 1.532-1.802 1.918-1.406 3.174-1.406 11.816h3.569v-7.513c0-3.518 4.882-3.651 4.882.49v4.354h3.537v-4.354c0-4.141 4.887-4.006 4.887-.488v7.515h3.56v-.004c0-8.636.404-9.883-1.406-11.816-1.962-2.032-6.087-2.196-7.927.43l-.883 1.383-.887-1.383c-.916-1.306-2.405-1.924-3.91-1.961" }); Ge("matrix", { color: "#000000", path: "M0 0v64h64V0zm16 16h3.04v.732h-2.198v30.536h2.197V48H16zm28.96 0H48v32h-3.04v-.732h2.198V16.732h-2.197zM29.769 26.104c.72 0 1.377.143 1.974.42.598.277 1.046.775 1.36 1.476q.509-.749 1.378-1.322.87-.574 2.061-.574.904 0 1.68.222c.517.147.955.382 1.324.707.368.327.652.745.861 1.268q.306.783.307 1.89v7.637h-3.131V31.36q0-.573-.043-1.082a2.3 2.3 0 0 0-.24-.88 1.5 1.5 0 0 0-.584-.596q-.39-.222-1.047-.223-.665 0-1.07.252a1.84 1.84 0 0 0-.641.666 2.6 2.6 0 0 0-.309.928 7.4 7.4 0 0 0-.08 1.047v6.357h-3.132v-6.4c0-.339-.005-.67-.024-1.002a2.8 2.8 0 0 0-.191-.918 1.4 1.4 0 0 0-.553-.67c-.259-.167-.635-.254-1.139-.254q-.224 0-.586.1a2 2 0 0 0-.705.375q-.344.277-.586.793-.24.519-.24 1.36v6.622H23.28v-11.42h2.953v1.541h.045a4.4 4.4 0 0 1 1.49-1.365c.578-.327 1.249-.486 2-.486" }); Ge("medium", { color: "#000000", path: "M0 0v64h64V0zm25.025 22.914c4.985 0 9.026 4.068 9.026 9.086s-4.041 9.086-9.026 9.086S16 37.018 16 32s4.041-9.086 9.025-9.086m14.413.531c2.492 0 4.511 3.83 4.511 8.555h.002c0 4.724-2.021 8.555-4.514 8.555-2.492 0-4.511-3.831-4.511-8.555s2.02-8.555 4.511-8.555m6.974.89C47.288 24.336 48 27.768 48 32c0 4.231-.711 7.664-1.588 7.664S44.826 36.232 44.826 32s.71-7.664 1.586-7.664" }); Ge("meetup", { color: "#E51937", path: "M0 0v64h64V0zm47.8 44.3c-.4.2-2.5.9-3.9 1-.6.1-1.1-.6-1.4-1.5C41 39.2 39 32 37.3 27.2c0 3.7-.3 10.8-.4 12-.1 1.7-.4 3.7-1.8 3.9-1.1.2-2.4.4-4 .4-1.3 0-1.8-.9-2.4-1.8-1-1.4-3.1-4.8-4.1-6.9.3 2.3.7 4.7.9 5.8.1.8 0 1.5-.6 1.9-1 .7-3.2 1.4-4.1 1.4-.8 0-1.5-.8-1.6-1.6-.7-3.4-1.2-8-1.1-11.1 0-2.8 0-5.9.2-8.3 0-.7.3-1.1.9-1.4 1.2-.5 3-.6 4.7-.3.8.1 1 .8 1.4 1.4 1.7 2.8 3.8 6.7 5.7 10.6 0-6.3 1.9-11.9 3.5-15.3.5-1.1.9-1.4 1.9-1.4 1.3 0 2.9.2 4.1.4 1.1.2 1.5 1.6 1.7 2.5 1.2 4.5 4.7 18.7 5.5 22.4.1 1 .6 2.2.1 2.5" }); Ge("misskey", { color: "#86b300", path: "M0 0h64v64H0Zm16.97 18.07c-.57 0-1.13.1-1.66.29-.94.33-1.72.93-2.32 1.78-.58.83-.87 1.75-.87 2.78v18.16c0 1.33.47 2.47 1.41 3.44.97.94 2.12 1.41 3.44 1.41 1.36 0 2.5-.47 3.44-1.41.97-.97 1.45-2.12 1.45-3.44v-3.3c.01-.72.75-.53 1.12 0 .7 1.21 2.33 2.24 3.9 2.24s3.15-.86 3.9-2.24c.28-.33 1.08-.9 1.16 0v3.3c0 1.33.47 2.47 1.41 3.44.97.94 2.12 1.41 3.44 1.41 1.35 0 2.5-.47 3.44-1.41.97-.97 1.45-2.12 1.45-3.44V22.92c0-1.02-.3-1.95-.91-2.78-.58-.86-1.34-1.45-2.28-1.78-.55-.19-1.11-.29-1.66-.29-1.49 0-2.75.58-3.77 1.74l-4.92 5.76c-.11.08-.48.72-1.26.72s-1.1-.63-1.21-.72l-4.96-5.76c-1-1.16-2.24-1.74-3.74-1.74m30.68 0c-1.16 0-2.16.41-2.98 1.24q-1.2 1.2-1.2 2.94c0 1.16.4 2.16 1.2 2.98.83.8 1.82 1.2 2.98 1.2s2.16-.4 2.99-1.2c.83-.83 1.24-1.82 1.24-2.98s-.41-2.14-1.24-2.94c-.84-.83-1.83-1.24-2.99-1.24m.04 9.2c-1.16 0-2.16.41-2.99 1.24s-1.24 1.82-1.24 2.99v10.24c0 1.16.41 2.16 1.24 2.98.83.8 1.82 1.2 2.99 1.2q1.74 0 2.94-1.2c.83-.83 1.24-1.82 1.24-2.98V31.5c0-1.16-.41-2.16-1.24-2.99-.8-.82-1.78-1.24-2.94-1.24" }); Ge("opensea", { color: "#2081E2", path: "M0 0h64v64H0Zm33 12.8c.5 0 .956.204 1.281.536.326.332.528.787.528 1.293v3.101l.375.106q.046.014.086.043c.092.069.222.172.39.297.132.105.275.232.445.363.34.273.744.627 1.188 1.031.118.102.235.208.34.313a27 27 0 0 1 1.824 1.847c.171.194.337.391.508.598.17.21.354.418.512.625.207.276.427.56.62.86.093.14.2.288.29.43.25.377.469.768.68 1.16.088.18.178.376.257.57a8.5 8.5 0 0 1 .54 1.59c.035.115.06.24.074.351v.027c.039.158.053.326.066.496a5.3 5.3 0 0 1-.094 1.641c-.05.234-.112.454-.191.688-.08.223-.16.455-.262.675-.197.457-.43.913-.707 1.34a8 8 0 0 1-.297.485c-.115.167-.234.326-.34.48a10 10 0 0 1-.457.59 6 6 0 0 1-.445.559c-.22.26-.428.505-.648.742a7 7 0 0 1-.418.453c-.142.158-.287.298-.418.43-.22.22-.404.393-.559.535l-.363.332a.3.3 0 0 1-.196.07h-2.8v3.594h3.527c.789 0 1.536-.28 2.14-.793.208-.181 1.112-.96 2.18-2.14a.3.3 0 0 1 .137-.083l9.734-2.816a.287.287 0 0 1 .364.277v2.059c0 .118-.07.223-.176.27-.644.275-2.852 1.29-3.77 2.566-2.34 3.258-4.127 7.918-8.125 7.918H24.14c-5.91 0-10.699-4.808-10.699-10.739v-.191c0-.158.128-.285.286-.285h9.296c.184 0 .318.17.301.351a3.17 3.17 0 0 0 .332 1.785 3.27 3.27 0 0 0 2.934 1.82h4.605v-3.593h-4.55a.294.294 0 0 1-.239-.46c.05-.077.105-.154.164-.243a33 33 0 0 0 1.657-2.645c.417-.73.822-1.506 1.148-2.289a5 5 0 0 0 .172-.43c.089-.25.18-.48.246-.714.066-.198.12-.404.172-.598a9.3 9.3 0 0 0 .219-2.098 10 10 0 0 0-.04-.87c-.013-.313-.05-.626-.09-.938a10 10 0 0 0-.128-.836 14 14 0 0 0-.266-1.25l-.035-.156c-.079-.286-.146-.562-.238-.848a32 32 0 0 0-.871-2.59c-.115-.325-.248-.637-.38-.949-.193-.47-.393-.896-.574-1.3a18 18 0 0 1-.25-.524 17 17 0 0 0-.269-.574c-.066-.142-.143-.271-.195-.403l-.563-1.039a.183.183 0 0 1 .207-.265l3.52.953h.008l.011.004.465.128.512.145.187.05v-2.09c0-1.008.805-1.827 1.805-1.827m-8.488 6.903a.28.28 0 0 1 .238.168c1.39 3.117 2.59 6.993 2.027 9.406-.24.993-.897 2.34-1.636 3.582q-.145.272-.313.528a.28.28 0 0 1-.234.125H16.03a.284.284 0 0 1-.242-.438l.137-.215 8.324-13.023a.28.28 0 0 1 .262-.133" }); Ge("patreon", { color: "#000000", path: "M0 0h64v64H0Zm52.853 23.459c-.008-5.72-4.462-10.41-9.69-12.1-6.492-2.1-15.053-1.796-21.252 1.127-7.511 3.546-9.871 11.312-9.959 19.055-.07 6.369.564 23.139 10.022 23.259 7.03.088 8.077-8.969 11.328-13.33 2.314-3.104 5.294-3.979 8.96-4.886 6.303-1.562 10.6-6.536 10.591-13.125m0 0" }); Ge("pinterest", { color: "#cb2128", path: "M0 0v64h64V0zm32 48c-1.6 0-3.1-.2-4.5-.7.6-1 1.3-2.2 1.6-3.4.2-.7 1.1-4.4 1.1-4.4.6 1.1 2.2 2 3.9 2 5.1 0 8.6-4.7 8.6-11 0-4.7-4-9.2-10.1-9.2-7.6 0-11.4 5.5-11.4 10 0 2.8 1 5.2 3.3 6.1.4.1.7 0 .8-.4.1-.3.2-1 .3-1.3.1-.4.1-.5-.2-.9-.6-.8-1.1-1.7-1.1-3.1 0-4 3-7.7 7.9-7.7 4.3 0 6.7 2.6 6.7 6.1 0 4.6-2 8.5-5.1 8.5-1.7 0-2.9-1.4-2.5-3.1.5-2 1.4-4.2 1.4-5.7 0-1.3-.7-2.4-2.2-2.4-1.7 0-3.1 1.8-3.1 4.1 0 1.5.5 2.5.5 2.5s-1.8 7.4-2.1 8.7c-.3 1.2-.3 2.6-.3 3.7C19.9 44.2 16 38.6 16 32c0-8.8 7.2-16 16-16s16 7.2 16 16-7.2 16-16 16" }); Ge("pixiv", { color: "#0097fa", path: "M0 0v64h64V0zm33.553 16.469c-11.844 0-19.903 9.146-19.903 9.146l2.27 3.606s1.26.106.592-2.018c.573-1.086 1.698-2.545 3.892-4.232v24.008c-.946.268-2.194.768-1.34 1.623h6.518c.86-.861-.493-1.38-1.32-1.623v-5.663s4.469 1.756 9.29 1.756c4.234 0 8.088-1.26 10.954-3.537 2.869-2.264 4.712-5.642 4.703-9.506a12.75 12.75 0 0 0-4.41-9.709c-2.793-2.438-6.705-3.847-11.246-3.847zm-.397 2.027c3.601.003 6.425 1.36 8.338 3.43 1.907 2.075 2.948 4.83 2.957 8.04-.012 3.126-1.124 5.698-3.107 7.673-1.98 1.959-4.864 3.195-8.188 3.195h-.021c-3.699 0-6.816-.72-8.873-1.732V21.088c2.261-1.605 5.928-2.598 8.894-2.592" }); Ge("ravelry", { color: "#EE6E62", path: "M0 0h64v64H0Zm42.692 28.943s-2.184-.397-3.752-.397c-3.584 0-4.424 1.987-4.424 4.939v12.488H24.83V20.542h9.687v4.257c1.176-3.576 3.528-4.825 8.176-4.825z" }); Ge("rdio", { color: "#0475C5", path: "M0 0v64h64V0zm43.9 30.5c.1.5.1 1 .1 1.5 0 6.4-5.1 11.6-12 11.6s-12-5.1-12-11.5V32c0-6.4 5.1-11.6 12-11.6 1.2 0 2.3.2 3.4.5v6.8l-.6-.3c-3-1-6.2.4-7.7 2.9v.1c-1.5 2.5-.8 5.3 2.1 6.3 3 1 6.2-.4 7.7-2.9v-.1c.5-.8.8-1.7.8-2.6v-9.3c.2.1.3.2.5.3.1.1.3.2.4.2 1.5 1 5.4 3.5 8.7 3.4 1.7.1.2 3.8-3.4 4.8" }); Ge("reddit", { color: "#FF4500", path: "M0 0v64h64V0zm53.344 32a4.67 4.67 0 0 0-7.903-3.2 22.77 22.77 0 0 0-12.32-3.937L35.2 14.88l6.848 1.441a3.2 3.2 0 0 0 3.02 2.852 3.2 3.2 0 1 0-2.602-4.805l-7.84-1.566a1 1 0 0 0-.754.136.98.98 0 0 0-.43.63l-2.37 11.105a22.8 22.8 0 0 0-12.477 3.937 4.672 4.672 0 1 0-5.152 7.648q-.06.704 0 1.407c0 7.168 8.351 12.992 18.656 12.992 10.3 0 18.656-5.824 18.656-12.992a9.4 9.4 0 0 0 0-1.406A4.68 4.68 0 0 0 53.344 32m-32 3.2a3.198 3.198 0 1 1 6.398 0 3.195 3.195 0 0 1-3.199 3.198c-1.766 0-3.2-1.43-3.2-3.199M39.938 44a12.3 12.3 0 0 1-7.907 2.465A12.3 12.3 0 0 1 24.13 44a.87.87 0 0 1 .055-1.16.87.87 0 0 1 1.16-.055A10.48 10.48 0 0 0 32 44.801a10.5 10.5 0 0 0 6.688-1.953.9.9 0 0 1 1.265.015.9.9 0 0 1-.016 1.266Zm-.579-5.473a3.2 3.2 0 0 1-3.199-3.199 3.198 3.198 0 1 1 6.398 0 3.2 3.2 0 0 1-3.23 3.328Zm0 0" }); Ge("rss", { color: "#EF8733", path: "M0 0v64h64V0zm24 44c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4m11-1c-1.1 0-2-.9-2-2 0-5.5-4.5-10-10-10-1.1 0-2-.9-2-2s.9-2 2-2c7.7 0 14 6.3 14 14 0 1.1-.9 2-2 2m9 0c-1.1 0-2-.9-2-2 0-10.5-8.5-19-19-19-1.1 0-2-.9-2-2s.9-2 2-2c12.7 0 23 10.3 23 23 0 1.1-.9 2-2 2" }); Ge("sharethis", { color: "#00BF00", path: "M0 0h64v64H0zm28.388 32c0 .084-.02.163-.025.247l8.802 4.4a4.3 4.3 0 0 1 2.782-1.037 4.335 4.335 0 0 1 4.335 4.335 4.335 4.335 0 1 1-8.67 0c0-.086.02-.163.025-.247l-8.802-4.4a4.3 4.3 0 0 1-2.782 1.034 4.335 4.335 0 0 1 0-8.67c1.065 0 2.027.402 2.782 1.037l8.802-4.4c-.005-.083-.024-.162-.024-.249a4.333 4.333 0 0 1 4.334-4.332 4.335 4.335 0 0 1 0 8.67 4.28 4.28 0 0 1-2.782-1.04l-8.802 4.403c.005.084.024.163.024.25" }); Ge("slack", { color: "#4A164A", path: "M0 0v64h64V0Zm12.636 37.56c0 5.066 8 5.066 8 0v-3.8h-4c-2.209 0-4 1.7-4 3.8m25.28-6.346c2.21 0 4-1.702 4-3.8V17.287c0-5.066-8-5.066-8 0v10.127c0 2.113 1.815 3.82 4.04 3.8zm14.64-3.8c0-5.067-8-5.067-8 0v3.8h4c2.24.042 4.08-1.672 4.08-3.8zm-25.24 6.345c-2.209 0-4 1.702-4 3.8v10.127c0 5.067 8 5.067 8 0V37.559c0-2.098-1.79-3.8-4-3.8m10.64 10.127h-4v3.8c0 3.386 4.309 5.08 6.829 2.687s.735-6.487-2.829-6.487m10.68-10.127h-10.68c-5.324.009-5.324 7.592 0 7.6h10.68c5.325-.008 5.325-7.591 0-7.6m-21.32-10.145h-10.68c-5.342-.008-5.342 7.608 0 7.6h10.68c5.325-.009 5.325-7.592 0-7.6m0-10.127c-5.324.008-5.324 7.592 0 7.6h4v-3.8c0-2.126-1.804-3.8-4-3.8" }); Ge("smugmug", { color: "#8cca1e", path: "M0 0v64h64V0zm36.1 19.8c.2-1.3 1.3-2.6 3.2-2.8 2.4-.2 3.8 1.3 3.8 2.8 0 1.3-1.2 2.6-3.8 2.8-2.4.1-3.4-1.3-3.2-2.8m-13.6.4c.2-1.4 1.4-2.8 3.3-2.8 2.3 0 3.5 1.1 3.6 2.4.2 1.5-1.1 3.1-3.9 3.1-2.4.1-3.2-1.3-3-2.7M28.8 47c-10.9 0-12-17.5-6.9-17.5 12.1-.3 12.5-.3 19-1C51.7 27.4 39.2 47 28.8 47m11.5-15.4c-3.9 0-6.8.5-17.8.9-1.6.1-2.9 11.4 6.6 11.4 7.5 0 15.2-12.3 11.2-12.3" }); Ge("snapchat", { color: "#FFC91B", path: "M0 0v64h64V0zm47.927 39.545c-.326.76-1.702 1.318-4.21 1.707-.083.113-.17.511-.223.754a11 11 0 0 1-.183.743c-.104.357-.367.554-.74.554h-.037a4 4 0 0 1-.723-.089 8.5 8.5 0 0 0-1.706-.181c-.397 0-.809.034-1.222.103-.809.135-1.496.62-2.293 1.184-1.139.805-2.43 1.718-4.392 1.718-.088 0-.171-.003-.234-.006a2 2 0 0 1-.162.006c-1.962 0-3.253-.912-4.393-1.718-.796-.562-1.483-1.048-2.292-1.183a7.5 7.5 0 0 0-1.223-.103c-.716 0-1.288.112-1.706.193-.278.055-.519.102-.723.102-.505 0-.701-.308-.776-.565-.077-.262-.131-.51-.183-.751-.053-.244-.14-.644-.224-.758-2.507-.389-3.884-.948-4.21-1.711a.9.9 0 0 1-.071-.298.664.664 0 0 1 .555-.692c4.349-.716 6.308-5.181 6.389-5.371l.015-.032c.232-.471.284-.866.154-1.172-.251-.592-1.177-.885-1.789-1.08-.17-.054-.331-.105-.464-.157-1.482-.585-1.688-1.258-1.601-1.719.122-.64.903-1.07 1.555-1.07q.284 0 .507.104c.557.261 1.053.394 1.472.394.314 0 .513-.075.622-.136l-.048-.779c-.136-2.173-.307-4.877.403-6.469 2.111-4.732 6.585-5.1 7.905-5.1l.554-.005.078-.001h.001c1.324 0 5.807.368 7.919 5.103.711 1.593.54 4.299.403 6.474l-.006.092-.042.685c.099.055.272.121.537.134.4-.018.863-.149 1.379-.391.219-.103.454-.124.613-.124.232 0 .468.045.667.128l.002.001c.592.212.965.638.974 1.117.011.609-.533 1.135-1.617 1.564-.132.052-.293.103-.465.158-.612.194-1.538.488-1.788 1.079-.13.306-.079.701.154 1.172l.015.032c.081.189 2.038 4.654 6.389 5.371a.664.664 0 0 1 .555.691.9.9 0 0 1-.071.298" }); Ge("soundcloud", { color: "#FF5700", path: "M0 0v64h64V0zm18.5 36.3c0 .7-.6 1.2-1.2 1.2-.7 0-1.2-.6-1.2-1.2v-4.9c0-.6.6-1.1 1.2-1.1.7 0 1.2.5 1.2 1.1zm4.9 1.2c0 .7-.6 1.2-1.2 1.2s-1.2-.5-1.2-1.2V29c0-.6.6-1.1 1.2-1.1s1.2.5 1.2 1.1zm5 0c0 .7-.6 1.2-1.2 1.2-.7 0-1.2-.6-1.2-1.2V26.2c0-.6.6-1.1 1.2-1.1.7 0 1.2.5 1.2 1.1zm15.2 1.2H31.4c-.3 0-.5-.2-.5-.5V24.3c0-.3.1-.4.4-.5.9-.3 1.8-.5 2.8-.5 4 0 7.4 3.1 7.7 7.1.5-.2 1.1-.3 1.7-.3 2.4 0 4.4 2 4.4 4.4.1 2.3-1.9 4.2-4.3 4.2" }); Ge("spotify", { color: "#2EBD59", path: "M39 37.7c-4.2-2.6-9.4-3.2-15.5-1.8-.5.1-.9.7-.8 1.2s.7.9 1.2.7q8.4-1.95 14.1 1.5c.5.3 1.1.1 1.4-.3.2-.4.1-1-.4-1.3m1.9-4.7c-4.9-3-12.2-3.9-18-2.1-.7.2-1 .9-.8 1.6s.9 1 1.6.8c5.1-1.5 11.6-.8 15.9 1.9.6.4 1.4.2 1.7-.4.4-.7.2-1.4-.4-1.8M0 0v64h64V0zm32 48c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16m11-20.4c-5.9-3.5-15.3-3.9-21-2.1-.8.2-1.2 1.1-1 1.9s1.1 1.2 1.9 1c4.9-1.5 13.4-1.2 18.6 1.9.7.4 1.6.2 2.1-.5.3-.8.1-1.8-.6-2.2" }); Ge("squarespace", { color: "#1C1C1C", path: "M0 0v64h64V0zm39.6 21.1c.6.6.6 1.6 0 2.2s-1.6.6-2.2 0c-1.2-1.2-3.2-1.2-4.4 0l-9.8 9.8c-.6.6-1.6.6-2.2 0s-.6-1.6 0-2.2l9.8-9.8c2.5-2.4 6.4-2.4 8.8 0M17.8 36.4c-2.4-2.4-2.4-6.3 0-8.7l7.5-7.5c1.2-1.2 3.2-1.2 4.4 0L20 29.8c-1.2 1.2-1.2 3.2 0 4.4s3.2 1.2 4.4 0l9.8-9.8c.6-.6 1.6-.6 2.2 0s.6 1.6 0 2.2l-9.8 9.8c-2.5 2.4-6.4 2.4-8.8 0m6.6 6.5c-.6-.6-.6-1.6 0-2.2s1.6-.6 2.2 0c1.2 1.2 3.2 1.2 4.4 0l9.8-9.8c.6-.6 1.6-.6 2.2 0s.6 1.6 0 2.2l-9.8 9.8c-2.5 2.4-6.4 2.4-8.8 0m21.8-6.5-7.5 7.5c-1.2 1.2-3.2 1.2-4.4 0l9.6-9.6c1.2-1.2 1.2-3.2 0-4.4s-3.2-1.2-4.4 0l-9.8 9.8c-.6.6-1.6.6-2.2 0s-.6-1.6 0-2.2l9.8-9.8c2.4-2.4 6.3-2.4 8.7 0 2.6 2.3 2.6 6.3.2 8.7" }); Ge("stackoverflow", { color: "#ed803d", path: "M64 0v64H0V0zM46.145 37.265H42.8v10.038H19.376V37.265H16.03V50.65h30.115zm-6.688 2.46L23.023 36.27l.69-3.287 16.435 3.456zm.964-4.234-15.224-7.09 1.418-3.045 15.224 7.09zm1.895-3.811L29.41 20.932l2.15-2.58 12.906 10.747zm-7.27-16.688 2.695-2.004 10.022 13.476-2.695 2.004zm4.407 28.965H22.722v-3.346h16.73z" }); Ge("t.me", { color: "#49a9e9", path: "M0 0v64h64V0zm11.887 33.477c3.73-2.055 7.894-3.77 11.785-5.497 6.695-2.824 13.414-5.597 20.203-8.18 1.324-.44 3.695-.87 3.93 1.087-.13 2.773-.653 5.527-1.012 8.281-.914 6.055-1.969 12.094-2.996 18.133-.356 2.008-2.875 3.05-4.488 1.761-3.871-2.613-7.778-5.207-11.598-7.882-1.254-1.274-.094-3.102 1.027-4.012 3.188-3.145 6.575-5.816 9.598-9.121.816-1.973-1.594-.313-2.39.2-4.368 3.007-8.63 6.202-13.235 8.847-2.352 1.297-5.094.187-7.445-.535-2.11-.871-5.2-1.75-3.38-3.082m0 0" }); Ge("telegram", { color: "#49a9e9", path: "M0 0v64h64V0zm11.887 33.477c3.73-2.055 7.894-3.77 11.785-5.497 6.695-2.824 13.414-5.597 20.203-8.18 1.324-.44 3.695-.87 3.93 1.087-.13 2.773-.653 5.527-1.012 8.281-.914 6.055-1.969 12.094-2.996 18.133-.356 2.008-2.875 3.05-4.488 1.761-3.871-2.613-7.778-5.207-11.598-7.882-1.254-1.274-.094-3.102 1.027-4.012 3.188-3.145 6.575-5.816 9.598-9.121.816-1.973-1.594-.313-2.39.2-4.368 3.007-8.63 6.202-13.235 8.847-2.352 1.297-5.094.187-7.445-.535-2.11-.871-5.2-1.75-3.38-3.082m0 0" }); Ge("threads", { color: "#000000", path: "M0 0v64h64V0zm32.28 15.75h.02c3.718.026 6.827.982 9.241 2.84 2.272 1.75 3.872 4.238 4.753 7.404l-2.763.771c-1.495-5.362-5.278-8.102-11.245-8.145-3.94.03-6.918 1.267-8.855 3.678-1.81 2.259-2.747 5.523-2.783 9.702.036 4.18.971 7.443 2.785 9.702 1.937 2.415 4.918 3.652 8.857 3.678 3.552-.026 5.902-.855 7.855-2.77 2.23-2.184 2.19-4.864 1.476-6.496-.42-.962-1.184-1.76-2.214-2.368-.26 1.83-.843 3.311-1.74 4.43-1.199 1.49-2.898 2.306-5.05 2.423-1.628.088-3.198-.295-4.414-1.085-1.44-.933-2.28-2.355-2.372-4.013-.088-1.612.553-3.094 1.801-4.173 1.193-1.03 2.87-1.636 4.852-1.75 1.46-.081 2.827-.016 4.088.192-.169-1.004-.506-1.803-1.013-2.378-.696-.793-1.77-1.196-3.194-1.206h-.04c-1.144 0-2.697.315-3.685 1.787l-2.379-1.595c1.326-1.97 3.477-3.056 6.064-3.056h.058c4.326.026 6.904 2.676 7.16 7.297q.22.093.435.19c2.018.95 3.494 2.387 4.271 4.159 1.079 2.466 1.18 6.486-2.097 9.694-2.505 2.45-5.543 3.559-9.852 3.588h-.02c-4.85-.033-8.577-1.63-11.083-4.75-2.226-2.78-3.377-6.644-3.416-11.486v-.024c.04-4.846 1.19-8.706 3.42-11.485 2.502-3.123 6.233-4.722 11.079-4.755m1.368 16.669q-.49 0-1.001.03c-2.487.14-4.038 1.28-3.95 2.901.091 1.7 1.967 2.49 3.771 2.393 1.658-.088 3.816-.735 4.18-5.025-.917-.198-1.92-.3-3-.3" }); Ge("tiktok", { color: "#000000", path: "M0 0v64h64V0zm32.781 16h5.494c-.008 0-.064.526.075 1.34h-.008c.166.98.617 2.381 1.824 3.762a8.857 8.858 0 0 0 1.617 1.375 7 7 0 0 0 .631.367c1.405.7 2.777.913 3.453.84v5.457s-1.93-.081-3.361-.461c-1.996-.534-3.276-1.354-3.276-1.354s-.888-.587-.955-.627v11.274c0 .626-.164 2.194-.662 3.502a10.6 10.6 0 0 1-1.843 3.062s-1.227 1.52-3.381 2.541c-1.943.92-3.652.9-4.162.92 0 0-2.951.119-5.612-1.69l-.013-.013v.014a11.2 11.2 0 0 1-2.381-2.246c-.842-1.074-1.36-2.348-1.492-2.721v-.014c-.212-.634-.657-2.168-.59-3.648.106-2.609.983-4.216 1.215-4.616a10.8 10.8 0 0 1 2.351-2.902 10.2 10.2 0 0 1 7.867-2.3l-.006 5.595a4.6 4.6 0 0 0-1.427-.227c-2.56 0-4.637 2.09-4.637 4.668s2.076 4.666 4.637 4.666a4.6 4.6 0 0 0 2.273-.6 4.67 4.67 0 0 0 2.348-3.704v-.012a.2.2 0 0 0 .004-.047q.005-.054.006-.103c.012-.279.011-.563.011-.848z" }); Ge("tumblr", { color: "#2c4762", path: "M0 0v64h64V0zm35.4 47c-6.5.1-9-4.7-9-8v-9.8h-3v-3.9c4.6-1.6 5.6-5.7 5.9-8.1 0-.2.1-.2.2-.2h4.4v7.6h6v4.5h-6v9.3c0 1.3.5 3 2.9 3 .8 0 1.9-.3 2.4-.5l1.4 4.3c-.5.8-3 1.8-5.2 1.8" }); Ge("twitch", { color: "#6441A5", path: "M0 0v64h64V0zm47 35.8-7.6 7.6h-5.7l-3.8 3.8H26v-3.8h-7V23.1l1.9-5.1H47zm-17.8 7L33 39h7l4.5-4.5v-14h-21V39h5.7zm8.3-17.2H40v7.6h-2.5zm-7 0H33v7.6h-2.5z" }); Ge("twitter", { color: "#00aced", path: "M0 0v64h64V0zm44.7 25.5v.8C44.7 35 38.1 45 26.1 45c-3.7 0-7.2-1.1-10.1-2.9.5.1 1 .1 1.6.1 3.1 0 5.9-1 8.2-2.8-2.9-.1-5.3-2-6.1-4.6.4.1.8.1 1.2.1.6 0 1.2-.1 1.7-.2-3-.6-5.3-3.3-5.3-6.4v-.1c.9.5 1.9.8 3 .8-1.8-1.2-2.9-3.2-2.9-5.5q0-1.8.9-3.3c3.2 4 8.1 6.6 13.5 6.9-.1-.5-.2-1-.2-1.5 0-3.6 2.9-6.6 6.6-6.6 1.9 0 3.6.8 4.8 2.1 1.5-.3 2.9-.8 4.2-1.6-.5 1.5-1.5 2.8-2.9 3.6 1.3-.2 2.6-.5 3.8-1-1 1.3-2.1 2.4-3.4 3.4" }); Ge("upwork", { color: "#3da800", path: "M0 0h64v64H0Zm24.938 17.111h5.6c1.1 3.8 3.099 8.2 5.599 12.1 1.6-5.5 5.6-9 10.9-9 6.1 0 11.1 5.002 11.1 11.102 0 6.4-5 11.398-11.1 11.398-3 0-5.5-.8-7.7-2.2l-2.4 11.901h-5.7l3.5-16.3c-1.5-2.1-2.9-4.5-4-6.7v2.5c0 6.1-4.9 11-10.9 11s-10.9-4.9-10.9-11V17.211h5.4v14.602c0 2.9 2.4 5.298 5.3 5.298s5.3-2.398 5.3-5.298zm22.199 8.801c-4.1 0-5.4 4-5.8 6.4v.1l-.6 2.2c1.8 1.5 4.1 2.5 6.3 2.5 2.9 0 5.6-2.5 5.7-5.6 0-3.1-2.5-5.6-5.6-5.6" }); Ge("vevo", { color: "#ED1A3B", path: "M0 0v64h64V0zm34.2 41.9c-1.4 2.1-2.9 3.1-5 3.1 0 0-3 .2-4.1-3.4L20 21h8.1l3 12.3c1.4-2.1 5.1-7.7 5.1-7.7 1.4-1.9 2.2-4.6 6.8-4.6h5z" }); Ge("vimeo", { color: "#1ab7ea", path: "M0 0v64h64V0zm40.9 37c-4.1 5.3-7.5 8-10.4 8-1.7 0-3.2-1.6-4.4-4.8-.8-3-1.6-5.9-2.4-8.9-.9-3.2-1.9-4.8-2.9-4.8-.2 0-1 .5-2.4 1.4L17 26c1.5-1.3 2.9-2.6 4.4-3.9 2-1.7 3.5-2.6 4.4-2.7 2.3-.2 3.8 1.4 4.3 4.8q.9 5.55 1.2 6.9c.7 3.1 1.4 4.6 2.2 4.6.6 0 1.6-1 2.8-3 1.3-2 1.9-3.5 2-4.5.2-1.7-.5-2.6-2-2.6-.7 0-1.5.2-2.2.5 1.5-4.8 4.3-7.2 8.4-7 3.1.1 4.5 2.1 4.4 6 0 2.8-2.1 6.8-6 11.9" }); Ge("vine", { color: "#00BF8F", path: "M0 0v64h64V0zm38.4 21.5c-1.2 0-2.1 1.2-2.1 3.4 0 4.6 2.9 7.2 6.7 7.2.7 0 1.4-.1 2.2-.3v3.6c-1.3.3-2.5.4-3.6.4-2.5 5.3-7 9.8-8.6 10.7-1 .5-1.9.6-2.9-.1-1.9-1.1-8.9-6.9-11.2-25H24c1.3 10.9 4.4 16.5 7.9 20.7 1.9-1.9 3.7-4.4 5.2-7.3-3.4-1.7-5.5-5.5-5.5-10s2.6-7.9 7-7.9c4.3 0 6.6 2.7 6.6 7.3 0 1.7-.4 3.7-1 5.2-3.2.6-4.4-1.4-4.4-1.4.2-.8.6-2.1.6-3.3-.1-2.1-.9-3.2-2-3.2" }); Ge("vk", { color: "#45668e", path: "M0 0v64h64V0zm44.94 44.84h-.2c-2.17-.36-3.66-1.92-4.92-3.37-.72-.81-1.82-2.66-3.12-2.47-1.85.3-.93 3.52-1.71 4.9-.62 1.11-3.29.91-5.12.71-5.79-.62-8.75-3.77-11.35-7.14A64 64 0 0 1 11.6 26a10.6 10.6 0 0 1-1.51-4.49c.91-.81 2.47-.51 4.02-.51 1.31 0 3.36-.29 4.32.2.57.26 1.14 1.8 1.57 2.8a37 37 0 0 0 3.31 5.82c.56.81 1.41 2.35 2.41 2.14s1.06-2.63 1.1-4.18c0-1.77 0-4-.5-4.9S25 22 24.15 21.47c.73-1.49 2.72-1.63 5.12-1.63 2 0 4.84-.23 5.62 1.12s.25 3.85.2 5.71c-.06 2.09-.41 4.25 1 5.21 1.09-.12 1.68-1.2 2.31-2A28 28 0 0 0 41.72 24c.44-1 .91-2.65 1.71-3 1.21-.47 3.15-.1 4.92-.1 1.46 0 4.05-.41 4.52.61.39.85-.75 3-1.1 3.57a62 62 0 0 1-4.12 5.61c-.58.78-1.78 2-1.71 3.27.05.94 1 1.67 1.71 2.35a33 33 0 0 1 3.92 4.18c.47.62 1.5 2 1.4 2.76-.31 2.56-6.09.99-8.03 1.59" }); Ge("vsco", { color: "#83878A", path: "M0 0v64h64V0zm18.5 34.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5S21 30.6 21 32c-.1 1.4-1.2 2.5-2.5 2.5m6.6 6.6c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m.1-13.4c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5M32 48c-1.4 0-2.5-1.1-2.5-2.5S30.6 43 32 43s2.5 1.1 2.5 2.5S33.4 48 32 48m-2.5-16.1c0-1.4 1.1-2.5 2.5-2.5s2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5m2.5-11c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m6.7 1.8c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5 1.1-2.5 2.5-2.5m.1 18.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c-.1 1.4-1.2 2.5-2.5 2.5m6.7-6.7c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5S48 30.6 48 32s-1.1 2.5-2.5 2.5" }); Ge("wechat", { color: "#00c80f", path: "M65.6 65.6H-1.6V-1.6h67.2zM49.738 46.043c2.846-2.061 4.662-5.107 4.662-8.498 0-6.207-6.043-11.244-13.492-11.244-7.453 0-13.494 5.037-13.494 11.244 0 6.213 6.041 11.246 13.494 11.246 1.537 0 3.025-.221 4.402-.615l.395-.059c.262 0 .498.078.717.207l2.955 1.707.26.082a.45.45 0 0 0 .451-.449l-.074-.328-.605-2.271-.047-.287a.9.9 0 0 1 .376-.735M25.793 13.887C16.85 13.887 9.6 19.93 9.6 27.383c0 4.066 2.182 7.723 5.596 10.197.275.195.453.518.453.879l-.055.344-.732 2.725-.086.393c0 .301.24.541.539.541l.311-.1 3.545-2.049c.27-.152.551-.248.861-.248l.475.068a19 19 0 0 0 5.287.742l.891-.021a10.3 10.3 0 0 1-.543-3.309c0-6.793 6.611-12.305 14.768-12.305l.879.021c-1.225-6.443-7.918-11.374-15.996-11.374m10.615 21.859a1.798 1.798 0 1 1-.001-3.6 1.798 1.798 0 0 1 .001 3.6m8.996 0a1.798 1.798 0 1 1-.001-3.6 1.798 1.798 0 0 1 .001 3.6M20.395 25.221a2.16 2.16 0 1 1 .002-4.318 2.16 2.16 0 0 1-.002 4.318m10.796 0c-1.193 0-2.158-.965-2.158-2.158s.965-2.158 2.158-2.158 2.158.965 2.158 2.158-.964 2.158-2.158 2.158" }); Ge("whatsapp", { color: "#25D366", path: "M0 0v64h64V0zm48 31.59c0 8.605-7.031 15.586-15.71 15.586-2.755 0-5.34-.703-7.595-1.942L16 48l2.836-8.363a15.43 15.43 0 0 1-2.254-8.047c0-8.61 7.031-15.59 15.707-15.59C40.97 16 48 22.98 48 31.59M32.29 18.484c-7.282 0-13.208 5.88-13.208 13.106 0 2.867.938 5.52 2.516 7.68l-1.649 4.867 5.074-1.61a13.2 13.2 0 0 0 7.27 2.164c7.281 0 13.207-5.875 13.207-13.101s-5.926-13.106-13.21-13.106m7.933 16.696c-.098-.16-.352-.258-.739-.45-.382-.187-2.277-1.113-2.629-1.242-.355-.125-.613-.191-.867.192-.258.383-.996 1.242-1.218 1.5-.227.254-.45.285-.836.093-.387-.191-1.625-.593-3.098-1.894-1.145-1.012-1.918-2.262-2.14-2.645-.223-.382-.024-.59.167-.78.176-.173.387-.446.578-.669.196-.223.258-.383.387-.637.129-.257.063-.48-.035-.671-.094-.192-.867-2.07-1.188-2.836s-.64-.637-.863-.637c-.226 0-.484-.031-.738-.031a1.4 1.4 0 0 0-1.027.476c-.356.383-1.348 1.309-1.348 3.188s1.379 3.695 1.57 3.949c.196.258 2.664 4.238 6.578 5.77 3.914 1.53 3.914 1.019 4.621.956.707-.066 2.278-.925 2.602-1.816.32-.894.32-1.66.223-1.816m0 0" }); Ge("x", { color: "#000000", path: "M0 0v64h64V0zm16 17.537h10.125l6.992 9.242 8.084-9.242h4.908L35.39 29.79 48 46.463h-9.875l-7.734-10.111-8.85 10.11h-4.908l11.465-13.105zm5.73 2.783 17.75 23.205h2.72L24.647 20.32z" }); Ge("xiaohongshu", { color: "#ff2741", path: "M8.494-.006h47.784c4.552 0 8.596 3.953 8.715 8.5V56.28a8.91 8.91 90 0 1-8.717 8.702H8.509A8.92 8.92 90 0 1 .004 56.26V8.514C.114 4.038 4.018.12 8.494-.006m4.247 23.213c-.033 5.045-.016 10.092-.041 15.138a.533.533 90 0 1-.54.66c-.607.036-1.217.015-1.826.02a61 61 0 0 0 1.307 2.978c1.148-.038 2.458.201 3.438-.55.88-.656 1.162-1.82 1.145-2.87 0-5.125 0-10.253-.023-15.378a263 263 0 0 0-3.46.002m14.236-.228q-1.29 2.963-2.63 5.9c-.254.586-.56 1.363-.028 1.893.683.62 1.686.381 2.524.437-.581 1.467-1.346 2.861-1.836 4.364-.271.741.407 1.495 1.148 1.503 1.343.091 2.69 0 4.036.035.44-.982.881-1.962 1.313-2.95-.785 0-1.577.056-2.348-.099.835-2.096 1.825-4.125 2.71-6.196-1.083-.127-2.31.226-3.3-.196.483-1.625 1.361-3.115 1.98-4.696-1.192-.005-2.38-.013-3.568.005zm18.469.013v1.322h-2.33v3.536c.779 0 1.556 0 2.332.016q.03 1.523 0 3.066c-1.167.023-2.338 0-3.506.018a149 149 0 0 0 0 3.529c1.17.013 2.344 0 3.514 0v7.512h3.516v-7.507c1.711 0 3.42-.025 5.13 0 .602-.05 1.29.37 1.27 1.033a28 28 90 0 1 0 2.813.574.574 90 0 1-.538.607c-.978.07-1.958 0-2.938.033.432 1.015.85 2.03 1.34 3.033 1.613-.083 3.583.323 4.812-1.015 1.167-1.082.817-2.793.865-4.204-.073-1.485.29-3.163-.632-4.463-.784-1.102-2.198-1.401-3.473-1.424-.076-1.777.348-3.856-.96-5.3-1.218-1.367-3.18-1.372-4.866-1.306v-1.32c-1.193.013-2.366.015-3.536.02zM32.9 24.317v3.534h2.206v10.596c-1.053.018-2.11 0-3.163.013a315 315 0 0 0-1.61 3.528c3.93.016 7.87 0 11.79 0V38.46c-1.13 0-2.262 0-3.392-.013V27.843h2.214v-3.536c-2.676.005-5.36 0-8.045.01m23.19.325c-.985.746-.662 2.112-.705 3.175.657 0 1.317.036 1.975-.022 1.056-.097 1.85-1.328 1.426-2.323-.332-1.092-1.807-1.567-2.696-.83M6.86 27.848c-.178 2.315-.358 4.628-.526 6.943a5.6 5.6 90 0 1-.335 1.539 156 156 0 0 0 1.823 4.061c1.421-1.901 1.95-4.298 2.097-6.625.124-1.98.345-3.958.416-5.94-1.165.04-2.323.012-3.476.022m11.71 0 .508 6.44c.185 2.153.741 4.347 2.056 6.093a172 172 0 0 0 1.82-4.062 5.5 5.5 90 0 1-.355-1.546c-.167-2.307-.35-4.615-.528-6.923q-1.757-.01-3.508-.002zm4.357 13.884c1.797.53 3.7.167 5.546.266a295 295 0 0 0 1.612-3.536c-1.845-.071-3.724.193-5.534-.272q-.83 1.765-1.632 3.542zM48.94 27.86c.762.109 1.777-.31 2.359.304.096.927.025 1.859.035 2.793h-2.37q-.024-1.549-.024-3.097" }); Ge("xing", { color: "#0698A0", path: "M1.008 0C.45 0 0 .45 0 1.01v62.11c0 .56.45 1.01 1.008 1.01h62.02c.56 0 1.009-.45 1.009-1.01V1.01c0-.56-.45-1.01-1.009-1.01ZM41.72 16.032h5.482c.327 0 .585.106.723.296.143.197.139.459-.012.714L35.898 35.145a.025.025 0 0 0 0 .032l7.65 11.91c.152.257.156.517.012.715-.138.19-.394.295-.721.295h-5.42c-.83 0-1.247-.47-1.516-.88l-7.71-12.056c.386-.58 12.074-18.248 12.074-18.248.291-.446.642-.88 1.452-.88m-22.794 6.334h5.425c.832 0 1.24.456 1.51.867l3.731 5.544-5.857 8.828c-.277.427-.668.893-1.48.893h-5.426c-.326 0-.571-.125-.71-.315-.142-.198-.15-.453 0-.709l5.766-8.672c.006-.01.006-.015 0-.025l-3.668-5.413c-.152-.258-.175-.513-.032-.71.138-.192.414-.288.74-.288" }); Ge("yelp", { color: "#B90C04", path: "M0 0v64h64V0zm22.4 37.9q-.6 0-.9-.6c-.1-.3-.2-.7-.3-1.3-.2-1.7 0-4.2.5-5 .2-.4.6-.6 1-.6.3 0 .5.1 5.5 2.1l1.5.6c.5.2.9.7.8 1.4 0 .6-.4 1.1-.9 1.2l-2.1.7c-4.7 1.5-4.8 1.5-5.1 1.5M33 41c0 4.9 0 5-.1 5.3-.1.4-.4.6-.9.7-1.2.2-5.1-1.2-6-2.2q-.3-.3-.3-.6c0-.2 0-.3.1-.4.1-.2.2-.4 3.7-4.5l1-1.2c.3-.4 1-.6 1.5-.4.6.2.9.7.9 1.2.1-.1.1 2.1.1 2.1m-.8-10.2c-.3.1-1 .3-2-1.2 0 0-6.4-10.1-6.5-10.4s0-.7.3-1.1c1-1 6.1-2.4 7.5-2.1.4.1.7.4.9.8.1.4.7 9.8.8 11.9 0 1.8-.8 2-1 2.1m3.2.5 1.3-1.8c2.8-3.9 3-4.1 3.2-4.2.3-.2.7-.2 1.1 0 1.1.5 3.4 3.9 3.5 5.2 0 .4-.1.8-.5 1-.2.1-.4.2-5.7 1.5-.8.2-1.3.3-1.6.4-.5.1-1.1-.1-1.4-.6-.2-.5-.2-1.1.1-1.5m9.3 8.3c-.2 1.3-2.7 4.5-3.9 5-.4.2-.8.1-1.1-.1-.2-.2-.4-.5-3.2-5l-.8-1.3c-.3-.5-.3-1.1.1-1.6s.9-.6 1.4-.5l2.1.7c4.6 1.5 4.8 1.6 5 1.7.4.3.5.7.4 1.1" }); Ge("youtube", { color: "#ff3333", path: "M0 0v64h64V0zm47 33.1c0 2.4-.3 4.9-.3 4.9s-.3 2.1-1.2 3c-1.1 1.2-2.4 1.2-3 1.3-4.2.2-10.5.3-10.5.3s-7.8-.1-10.2-.3c-.7-.1-2.2-.1-3.3-1.3-.9-.9-1.2-3-1.2-3s-.3-2.4-.3-4.9v-2.3c0-2.4.3-4.9.3-4.9s.3-2.1 1.2-3c1.1-1.2 2.4-1.2 3-1.3 4.2-.3 10.5-.3 10.5-.3s6.3 0 10.5.3c.6.1 1.9.1 3 1.3.9.9 1.2 3 1.2 3s.3 2.4.3 4.9zm-18.1 2.8 8.1-4.2-8.1-4.2z" }); const cj = () => it("section", { className: "relative w-full h-screen mx-auto", children: [it("div", { className: `${ri.paddingX} absolute inset-0 top-[120px] max-w-7xl mx-auto flex flex-row items-start gap-5`, children: [it("div", { className: "flex flex-col justify-center items-center mt-5", children: [ue("div", { className: "w-5 h-5 rounded-full bg-[#919eff]" }), ue("div", { className: "w-1 sm:h-80 h-40 violet-gradient" })] }), it("div", { children: [it("h1", { className: `${ri.heroHeadText} text-white`, children: ["HI!, I'm ", ue("span", { className: "text-[#919eff]", children: "Jerome Cano" }), " "] }), it("p", { children: [ue("h1", { style: { fontSize: "x-large" }, children: "Senior Full stack & Blockchain Developer" }), ue("br", { className: "sm:block hidden" }), " ", "DevOps", ue("br", { className: "sm:block hidden" }), " ", "Intuitive and User-friendly-interface", ue("br", { className: "sm:block hidden" }), " ", "SEO", ue("br", { className: "sm:block hidden" }), " ", "High speed backend", ue("br", { className: "sm:block hidden" }), " ", "Database"] })] })] }), ue(XU, {}), ue("div", { className: "absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center", children: ue("a", { href: "#about", children: ue("div", { className: "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2", children: ue(Xi.div, { animate: { y: [0, 24, 0] }, transition: { duration: 1.5, repeat: 1 / 0, repeatType: "loop" }, className: "w-3 h-3 rounded-full bg-secondary" }) }) }) })] }), uj = "" + new URL("logo-5d95862e.svg", import.meta.url).href, fj = "" + new URL("backend-565fc01f.png", import.meta.url).href, hj = "" + new URL("creator-dbbffaec.png", import.meta.url).href, dj = "" + new URL("mobile-896ef2f5.png", import.meta.url).href, pj = "" + new URL("web-0d05165f.png", import.meta.url).href, mj = "" + new URL("menu-b5599218.svg", import.meta.url).href, gj = "" + new URL("close-54702a70.svg", import.meta.url).href, yj = "" + new URL("docker-602a695a.png", import.meta.url).href, vj = "data:image/png;base64,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", xj = "" + new URL("mongodb-54000b2b.png", import.meta.url).href, Aj = "" + new URL("nodejs-d83eb6dd.png", import.meta.url).href, Mj = "" + new URL("reactjs-966214a8.png", import.meta.url).href, _j = "" + new URL("redux-171787ca.png", import.meta.url).href, wj = "data:image/png;base64,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", Sj = "" + new URL("threejs-fe160e71.svg", import.meta.url).href, Cj = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBwgHBgkIBwgKCgkLDRYPDQwMDRsUFRAWIB0iIiAdHx8kKDQsJCYxJx8fLT0tMTU3Ojo6Iys/RD84QzQ5OjcBCgoKDQwNGg8PGjclHyU3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3N//AABEIAJQAlAMBEQACEQEDEQH/xAAcAAEAAgIDAQAAAAAAAAAAAAAAAQcFBgMECAL/xABHEAABAwICBAgMAwYEBwAAAAABAAIDBAUGERIhMVEHE0FhgZGT0RUWFyIyUlNUVXGSoWLB4QgjQrHC8DNDorIUJERjZHKC/8QAGgEBAQEBAQEBAAAAAAAAAAAAAAIDAQQFBv/EACoRAQEAAgADBwUAAwEAAAAAAAABAgMEEVIFEhQxUWGhExUhQZFC0fCB/9oADAMBAAIRAxEAPwC8UBAQEEZoNTxVwiYawwXRV1cJasf9NTjTf08jekhBVV94ebnOXssVsgpGfwy1B4x/VqA+6DR7hwi4vuWl/wAVf6wA8kJEQ/0gIMDU3Ovq9dVW1Ux/7sznfzKDrxyyRnON72ne12SDK0eKb/QuDqS9XCLLYG1DsuolBtVn4Y8X254FRWRXCL1KmJuf1NyPXmgsbDfDnZq4tiv1HLbpNhlZnLF9hmOooLRt1xorpSMqrdVRVNO/0ZIXhwKDtICAgICAgICDFYjxDbMNW91dd6pkEI1NB9KR2Wei0cpQefMdcL15v5kpbQX2y3HVkx376QficNnyHWUFa6ROZJ1lBCAgICAgIJzQZTD2IrthytFVZq2SmkPpButrxuc06igv7g94XrfiB0dBfBFb7k7JrH6WUU52aifRPMegoLQQEBAQEBBrOPMZ27BtoNXWnjKmTMU1K12TpXfk0cp5PnkEHl3FWJ7nim6Pr7tMXu1iOIamQt9Vo5EGEQEBAQEBAQEBAQSNiC5uCjhXkpJILJiicvpTkynrZHa4tgDXn1efk5dWwL7aQ4Ag5g7DvQSgICDFYmv1Hhqy1N1uL8oYG5hoI0pHcjW58pQeTMXYkr8VXma53F/nPOUcQPmws5Gt/vWgwiAgICAgICAgICAgIJ5kF7cB3CE+fi8L3mYmQD/kZ3u9ID/LOfLu6tyC7EBBBQeaOG7GJv8AiE2ukkzt9ucWDI6pJdjndGwdO9BWiAgkDNBsWFsNSXkumnc+Kjbq027XncO9ejRouz83yeXiOImqcp+a2XxDtft6v6m9y9F4TH1eG9obfSJ8QrX7xV/U3uU+Fx9UXtLdP1DxCtfvFX9Te5T4fFF7U3T9RPiDa/eKv6m9ym6Im9rb/SHiBa/eKv6m9ym6cWd7Y3z9T5T5P7X7xV/U3uU/TiL21xE/xnynyf2v3ms+pvcuXBF7c4jpnz/s8n1r95rPqb3KLim9vcT0z5/2wOL8O22xUsRpqqV1TI//AApCD5mvN2oateQU19PsvtDfxeWXfxndk856tSO1H2X3Tzy008c8D3RyxuD2Paci1w1ghB604NcVsxdhinrnECri/dVTBySDl+RGR6UG1oNT4T8SHDGD62thfo1Ug4mm/wDd2rPoGZ6EHkk7UEIJQZzC9hkvNXm/SZSRn97Jv/COc/Zenh+Hu3L2Y7tv057rRgijp4WQwMDImDJrRsAX1e7MZyj5OfPK865FxjYkKLGViVFjLLFIKixlYlZ2MrEqLGVxSosZWMbf71T2ShM82T5XZiKLP0z3b1nl+G/B8Fnxezu4+X7vp/36VJcq6ouFW+qq5NOWQ6zyDmG4LF+006MNGEw1zlI6iNRBY/AdiQ2TGEdFK/KkuYEL8+R4zLD15j/6Qem0Hn/9o28me82+zRv8yliM0rfxv2dQH3QU6gIOejjilqoY6iXioXPaHyZZ6Lc9ZVYyXKS+Tl8loUV1sNDTR01NXUrIoxk0CT7nnX28NujDHu45R4c9ezK87HP4ftHxGm+sJd+rqjK6M/RPh+0fEqbtAou7V1RldGzpqfGCz/EqbtApu7X1RneH2dNT4fs/xKl7QKLt1+rO8Nt6anw/Z/idL2gU3Zr9Wd4Td01IxBZ/idL2gUXZh6srwe/oqfGCz/E6XtAoueHqzvB7+i/xxVmKLPS0z5RWxTOaNUUTtJzju5lGWePIw7O4jZlMe7y96rC83Wou1bJU1R846mtGxjdwXmttvN+n4fh8OH1zDBj1xuICD7hlfBMyaJxZJG4OY4bQRrBQezcNXRt7w/b7mzZVQMkOW8jX980HljhQr/CWPr3UZ5gVJiBz5GAM/pQasgIJzKAu/kFwF0Ne5cDWuhr3LgeduKHMyduKHM1jkKHMPOghAQEEjag9JcBV5jOAIaeZ+ulqZYhr2AnT/rQed7tUGrulZU+2nfIelxKDqICDmpJzTVUM4Y15ieHhrhmDkc8iqwy7uUoti01tHdaNlTTNbkdTmEDNjtxX6PVsw3Yd7F58sbHe4qP2bPpCu4T0Y2UEcfs2fSFFwnoysqeLj9mz6VFxnoyvNIjj9mzqUXGM7zTxcfqN6lncYyvNIjj9mzqU3GMrzfXFx+zb1KLjGV5uGroaWtp309VAx8TxkRlrHODyFZ5YTKcqnDZnry72N/KqsR2KeyVhY86cD8zFLl6Q3HnXg2YXC8n6TheJx4jDnPP9xiFD0iAgIN1wXih1ltctM05B05k62tH5INOmYY5Xsdta4g9CDjQEBBkrFeJ7PWcdF5zHapYzseO/cVvw+/LTnzjlnNadBWwXClZU0r9KN/WDuPOv0WvZjtwmWPk8+WLspWVxSCorHKJUWM7ErOxlYlTWViVFjK4pUWMssXVudvp7pRPpKtubHDURtaeQjnWWeEynKmrbnpzmeKpr5aaiz1ppqgZjayQDVI3eF8/PC43lX6bRvx34d/FjlLYQEHfoKCaqhL4mkgOy1dCDs4vpDQ4pu9K4ZcXWSgDm0jl9kGHQEBAQZawX2pssznRDjIX+nE45A7jzFenh+Jy0XnPKuWc2f8f3/Dh236L2fdL0/LO6oeUCT4c3tv0XPuV6flN0e6fKBJ8Ob236KfuN6flF4aep5QJPhre2Pcp8fen5TeEl/Z5QZPhre2PcueOvp8pvAy/tPlBk+Gs7Y9ynxl9EXs+X/L4PKFJ8NZ2x7lzxfsm9mzq+DyhyfDWdse5T4q+iftc6vhi8RYpdfKSOB9FHFoSaYfp6Tth1bP7yWWzb355N+F4Lw+VymXNriye4QSNqC6OBzDQueFZqqSMHSrHhpI5A1n55oNY4dLUbdwgVc4blFXRsnZ89HRd92k9KCvUBAQEHdtdsqrpUcRSR6TgM3EnINHOVtp057su7hBmPEm6+tTdoe5ev7Zu9v65zT4kXX1qbtD3Ln23d7Od+HiRdvWpu0Pcufb9vt/3/AIn6uKfEe7b6btD3KbwG72Td+B4j3ffTdoe5cvA7vZPicDxGu++m7Q9y54Pa54vWeI14303a/ouXhNqfGak+I13/APG7X9Fzwmxy8fpnq6N3w3X2ilbUVbYuKc8MBY/PXt/IrLPTnhOdaaeK17cu7j5sKs3oEEhB6y4JLU6z8H9pgkblLLGZ5M97yXD7EDoQap+0NYDXYdpr1EzOW3yaMhHs3kD7Oy6yg88IIQEHbttBPcatlNTN0pHb9jRyk8y106stucwx83ZOd/C0bNa4LRRNp4NbtskhGRe7ev1PD8Njow7sad3k74K0sZWJUWMsokFRYysSFFjOxIUWMbilRYzsSFFjKxx1VTDSU8lRUyBkUY0nOPIFllZjOdRNdyvdx81WYlvst6q9IgspmE8TFnsG885Xydu27Lz/AE+xw/D46cfdhVk9AgzWDrHJiPE1vtUYOVRKA8jkYNbj1AoPY0cbYo2xxt0WMAa1o2ADkQcF0oKe6W6poKxgfT1Ebo5G7wQg8d4osdVhy/VdprBnJTvyDssg9u1rh8xkgxSDlpoJKmeKGEaUkjg1o3kqsMLnlMZ512TneS0LBZobRS6DcnTv1yybzuHMv1nB8Fjw+HvfN7MdXcjKBeqxFiVFjLKJCixlcUqLGWUSFFjKx9KLGVgFFjKxEkjIo3SSvDI2DNznbAFGX4nOs7jbeUVlirEL7xNxUJcyjjPmNO159Y/kvicRvuy8p5PoaNE1znfNry870CCckF+fs9YVNNRz4krI8n1I4mkBGsMB853SRl0ILmQEFX8N2BjiC1C8W2MuuVCw6TGjMzRbSOcjaOkIPNpGpBLHljg5pIcDmCDlkV2XkO14VuHv1T2ru9a+J3dd/qu/l6p8LXH36p7Vy74nd1X+072XqeF7l7/Vds7vTxO7qv8AXOdPC9y9/qu2cueJ3dV/rifC9y9/qu2d3p4jb1X+ucjwvcvf6rtXd6eI29V/pyh4YuXv9V2zlz6+3qp3Z6Hhi5/EKrtXJ9fZ1VzuY+j4nuVbURmOoq55WHa18hIU5bM8pytJjjPKOoVChACDaeDvCFRjHEMVCzSZSR5SVcwHoR57M/WOwdJ5EHrOipIKGkhpaSNsUELBHGxo1NaBkAg50BAQUHwzcGj6SWbEdggzpnkvrKZg/wAI7TI0D+Hfu27NgUyRr1IIQEBAQEBAQEBAQEGWwzh644mu8NttUJkmk1ud/DG3lc48gCD1ZgjCdDhCyR2+ibpPPnzzkedK/lJ5tw5EGwoCAgIIc0OBDgCDtBQUpwmcD3HyS3bCMbRIc3z0GwO549x/D1bkFGVEEtNM+GojfFKw6L2PaWuadxB2IONAQEBAQEBAQAg2jBOBrxjGr0LfFxdIwjjqyVp4tm8D1ncw+yD03g3CFrwhbBR2yPN7sjNUPHnyu3k7ubYEGwICAgICAgINUxlwf2HF0ZdcKbiqwDJtXBk2QfP1h80FHYr4HsSWQuloIxdaQfx04ykHzYdfVmgruaKSCV0U0bo5GHJzHjIg84KD5yQQgIJyQMkGZw9hW+4jl0LNbZ6kZ5GQDRY35uOodaC48HcBtNTOZVYqqG1TxkRRwEhgP4nbXdGXSgt+ipKehpo6ajgjggjGiyONoa1o5gEHOgICAgICAgICCCEGMvGHrPe2aF2ttNVjfLGC4fI7UGh33gbwgYXS0sNZSHdDUkgfXpIKhxdhKgsry2lmqXge0c0/yaEGs22ijqqgRyOeATl5pCC2sKcFWH7m1klXPcHZjMtErQP9qCyrPwZYPtDhJT2eKaUf5lS50p6nHIdAQbbHGyJjY4mNYxuprWjID5IPtAQEBAQEH//Z", Ej = "data:image/png;base64,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", bj = "data:image/png;base64,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", Tj = "" + new URL("nft-4baf68d3.jpg", import.meta.url).href, Bj = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACUCAMAAAAqEXLeAAAAw1BMVEX///8AXs4AbfC92/8kiP8Aa/AAafDB3v8AV8wmiv8AW80AZvAAZO/D4P8AYu8AWc0AU8sBYtYAUMoAfP8AX+8BZt8AXO8AgP8cgfsDbOoAVu6u0Pn3+//H5P/R4f+11fzx9v/p8P6ixvWTufBvnuWawPMdaNJej+B+pvaoyv8OdPRelfff6/9FgvIAd/83ctWBrOtrmfWOr/dUjPO0zPszd/GYufedxP9+sP9ipP89kv+Luf/G1/tMmP87ethvn/VShdv4wt/9AAAMCElEQVR4nMWcaVvqPBCGbTFpoZsCIshWFkG2F9nd9f//qjcFIWmSNpOKnrmu8+UcxPvMZJ5MJsvFxXks7Eynrdx6tNvttsvldrdutaadsHGmb/+5NVrt3dPze/62VLqNbOwTK1cqzmz1uVy/hf+a76LR3D2/XF5Wb6uX1JC5N4Sx42Bzs3po/TvQxnT9VC3F8A5msoYQ9iuVyaj1L0Lf2T3nJYDE8mNkcoacsjnZTv+WMHx7vq1KCSPIkgC5D77jrNadP0Oc7t5LSYSRVWWQkeHKZtv6E8Tw9UUeZjUkwXTGD78f9enTf7ephELm8GF37ybTX02izms+HTEfWSokMRd//p43G6OXBMT8Aa56Wd1brZZOiZzxNvwdxtZLSQoYjcLb29KYSCI6/Lk2iF1f39QSaVF5/PYLiI3XS0m6EP9Vx+OIj0W4MY52HaFKMTF+CM/NaImI+wDv/cdnM4U82E1Nku/IweuzIja2onQTwpIp8EkhiUdl/sTuOZ3ZeeYRiRNvzUQ5FCEjThETuauzpXmb151oICYLdgIkMTGPHOdMIR/xE0yEmMaYCElGpxByf3sGZW+88m68VCCmQYqYyP0Mf8oYPpc4xJIKMR1SHJvl1Q9ro/A57kcSaRWhCpJgch93f0bZeb/VjDQEUoi5M/5BkvOM1WTV0YM0ONl0qpkpOXnMj4GMAEh+ZOJZxoiHMT+SUMMIYZB8yJ1NmIWx8RRnhLoRY/MaAslR+ossehnTx3zKJMgxTiYYBslluf+gT7mLMwIRScVRryMYIz8wy0tdxlY2RtNdeM3PKyilwVIiX7MOnuazMeJNO5drDwrZKMd66112oiHjEWx4aeVy1qMNhoxF3FnpDMvdbSY/ErkjjiQ2h7vSYH/ef4IzWuyATFnqC+aPvIjRuy/CIWM57oKHZbigMw2ZCuHmrJp7R+aaH/CAxyjhMw+jkHANNyP5GVkHSKsLZ4yruv8AY5yyFWTqMoEz/PnNSCj7gQYlmzx3sAxnygqdpCEKUqeQdR1XsimOQRk+YkofnaQx/ddm7mTNR43ciQ1LZ6tmDN9PkPm8xoAkOp6L2UAn4Dfs96hzh5FISV85xZytxTJaPfjkaMSGpa+cwxs0a/JawcaTHGdfOq5kAo7uQgUkKz86wTbxvRdn9LoaWhlzpatw5fSFCbYGouksmrwnm0MtSsaVm3QZoiNS2a+NGTLrFg9JZEhjCmcDnu7KxgtNba2scR8ExkjRM+YOHqdp5ahEHQlaYR+/9bv64az9kTF3KrsUyPeM8uO/ejJIr6ej6Iwr0SaZscVMNlqZPROy5jt35hldiZNLttdsIxKhnWRE7kdlVweSSXAnsRjq0BlRoxNAvlHQcWpaMkQnRzxL6ru0qSM1ljWk+hklODJy5SBbvP2kDjDTstCJtvsgzZrvUaklQ9SV7mcCJJM2Oo40kxEj01F06krkJ+T2f/ks0Xbk8nM0r6czKqkKVXLy3KZTogZjgo5T01J0Jt7y/KZKrrFCJPKT6shofasBSeONZ7KpkXZW8huNdsBKwUgodWSI/u+lPZd2likROd1E+Tma1dVIcEYqZSLElLtgP5KZQcmoVw1RSEdSrzXoSha+bMAbsYyUQNbhvSFmUE5CAZLOiTrdyKVyRO5H5WOGjiWuiqvGKVNcgB1ZBTFqVUNUKV1x+rZovQtdgCFHJT8nV8LXt3RQVsRyjVlvQ6ONJ4ABeTALLEN0UPqvAuSpugAvt9FYLT8nSHCbjUI6CwHymeYN0JHuAhjsfcCH0IDTQM0ESG0pRygHdiRxpQWthk5piyoC5H+6kO6ThiM1ZIim910KJCzYyuqHtzZQhhhIvsTonCCBkyLaajkykiFYvBkN4oXy1IMGtlecmSYjoYQVlhSyzNdBmpDIhcvP0SxYm43xJA/Z0oN0nrUZo2oIQkmFUvCkHmTaKjYFsg7ZdDwbpKMnP0fzIJuOKWNSCxLNvAyOJK70AIXluTyJxk9tSz9xvPYjIN4piaOX3ci9+urVddxpefXe8OoKMCYhEgQS8xvDsIN5v9uE1pPNbn8ewKo1BrLJQYYa02LtcBCkYNvzXltdZVi5dm9u29BlTsqMozF3M6d+gqIx7LWbaZzNdm9oFDX6A2kFBl09pFdBtfh5moJtzPvtpLB7zXZ/boCdqIQ8beCkLhZrkiM/haviR69uCZyeVe99FCG5EjNaT7oCJKQy3yPKfmlwNe/fxzE9j+TKlVY3+mCn34ZXAuSreo1z8OK8EEg4C4ExfyTieRieltV+nBvyzxXSe79UyyV9NbqFI18t1o750u8O54HMQ4WiPYzEk4j2/ZddlHrcng/v+0DIsrjx3WK6kyIlMxbtx2biWIvEs17vfxgySTyM3aZi/mbaqOK6m+n8lZKceLBiz/O8pKwt2EEg/fsgUgHyg6r9pxMkQmIHI5zIe0G1Gz6hC8a9lbOaud5wAE2MQnEw7OWInlr3qkUj7QVJTt80niRdtdq17JRhMKh7B4l5HBTVIliwi4PHem7/I3XVoQemN/ApafV+91ny+cPsXaslnycNBm3rOCcP54XUQWYX5sPjHG+1lQczmP6k7MDI2/7eT+TIWxLi9HOa9tdxyo6qm69AmspGFOaAqZas3JeyxmA2QWWd3unm9M/qM7n2kB4BsqKwS8SzEAQkzBYtPAFdK2YjZyPduJvh0yeUkEaxz1QVlufdD0mhw34gsEmueGzJ6fXVG8tMo1ecbyJbuqdPAA7l2o/xWZBM1F8n8SSSOOenc9CuE7OPIz/iML2juqP+OuOqx5UUZKbpD0iiEEkc9Ot8YQTro1Lpu0vYpjV14m0UCl2+8LGi4nEwkJWYXregtZzFppzx4sE/fQZynD2YS7YerFy9LinWLVi7iuZ24pnUN0xVHPCNhi2jlJpVn+s1L1Di+YbO6hRvWXErofyCLsTUAhkZsx2WfPtl6WjFOyaXqY4EtvVp2qScT5zSzIGkTkTZP+O2HXs+MeXqC6PnMFcW7F7CaRtqzR6wVmKOWIk9fWq5Cv3PAG9Z2D2FLy3o0QHGkRUrBbKh7UqjMEhvp1pd4CUD9uiSdEP+ZCNX25Wnuk3OqK7Ovo1xpDtKY7zoMK4EaSUx+yOZ0mpDj8XHHKk41bv1tV1pBF/JjgTvKbKHepXnox19VxpXwwRRhx9GZR2JVYwXozL9ODB3SHX5KA24BT5szh6HTzwBRi1kRiU44IbB122RQbeXjLiOr0Il5MUb2xuA/pKCUF3uK0j9niT55aDbLgs6g8OHZTDgq0uvCz6zH7tVIO5ySwNeZlwJHpbBR7xus+rw41/MgERlQLAjYxUdPiztD7bYhQtknNFJ13FqjYmThTImRPCTArE7Q84EfJVtyuYOrP7dU9K6TeNQFcuITI3byWtGLOHJE3UFv0Ucfikwdo+tovVMwiczO8KTp3B1/33bDiw+sXuLftIZWbmFK0bSNXwZRHLpQatczo8gGWdt6qAslFFXUN3fS2CUnPtS2JubidKety3Q8lVgRPCLldRGrA7Bc9z+gi1fDf4WOoYqZMyWldiXgKtLaKzjjHfat7sP9hnzJTzJYRb77pTLDgprfLpxSnjlpjTu9QZX1iAHUk782Fdp1JcK454+KWtd7OaNi7iGYqYZ/zyLoyfigi8fKhzlGUYm/9BNJcO7DXFb+twmHrzgSEDk3IjUNz7VNhLf0foBpvCWFUaZ9JG3VoUbmD9QI/F9KOFcTUbrrFz+uzN5U3gb6sdPBbEWPpUlu8t67pQ9WobKy/BcjMTWyJFgwnNI9qwacszzvv52ES4wFn9PFHYlaORDyWEE7CzC8zJGTyaarvzcg7gjzgImPPVnuuboN16hbCyQ1JnH0F8zTr1Ofonw4EaU6XkgiL0t/GTMGHL6P2N/8hsPO35bYz2uwDDTECvjdfh7jJGNZvIMAiPi2VmmmHQL16uyMAVBzSmvftuLR8zWxHewzt3qvSHs+JO/fEa6s12ZwCT6Nuyj1fbvHjw+WPi23dyVMeTSP0K4fLfZ/qNHw6e72QY5qZGPnoxGm9nujx+3jltnvX2YjctlX5zbkeOXy+PZw/YPn7VOts60tV4uNq7vEMM4emvdcXx3s1iuW9NzAP4P/8lMY04stFYAAAAASUVORK5CYII=", Pj = "data:image/webp;base64,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", Rj = "" + new URL("ceo_rikkeisoft-74f339b7.webp", import.meta.url).href, Lj = "" + new URL("desinger_proudcloud-b5cb4aca.webp", import.meta.url).href, Ij = "data:image/jpeg;base64,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", Dj = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wgARCABkAGQDASIAAhEBAxEB/8QAHQABAAICAwEBAAAAAAAAAAAAAAUGBwgCAwQJAf/EABkBAAIDAQAAAAAAAAAAAAAAAAABAgMEBf/aAAwDAQACEAMQAAAB2pADiHnwvhjD4bf5R+e00H0YUy5gAAAAxBl/WJPWiXj8iZ9kV7vbZ821t5pLu10OOEogAA102LxIpamWKW7cXShZuRtSnWdscF57vycxoxgAAqVtI0cg8x0zn9eRsXv6q78tXiiXvpcUJ1gBj/AwtufPofVGZyps/wBGHozFxgJvJt8myGiEV2OH9BWoORXHPKNJ/ParEo85WGtItwYSak7SqWLv8rlqrjuRjal6OTiKXeRJRfIg14GbZyppqgYwrt01/Co7+kDvDP/EACUQAAEEAgEEAgMBAAAAAAAAAAMBAgQFAAYHERITIBAxFBUwIv/aAAgBAQABBQL0kyRQw2HLlVGJF5friOp9nrL7+LnIxu/7ouxSWsVcEju6PIJXS9Sv02Gn9+T7ha3XlTqsSMpUiQkcazreicX2pYOwe/Mzu0kZEKRkZGBcQUV8UyTQ1Ectft/vy1AJMULGsWC/rIOIjkiQ5KRrOvcGwilU8X25IF31SAawdIJhJxHNAWEHzKeD+ylsb2N9tqgrYUJzF8QJzmEglnyx1MV0ZdXVr2fw3LWiU8iIIZ1jKMAmyPyC6ZEWNT+8iQOIDY+Qi7FgAvRYkHvwDEG3WN6/V3CL1T52vdIWpin8zTiLL5H2CWsu6srbJevrBqYTO5IydMRXuXkEI4lrX7vdViV/MNkDK3l+skvg2UWyj7NeE2G6xq9MpP8AVwxEQZaeO1odf8bgsYJN/Mhb1FxcbkaaeOz51ZiOvQvYUnja9Tux7/BDsJLp8tPp2Nxn186QFp9kjjaMg8G/yyNpI4WuL9LjsH95/8QAIBEAAgEFAAIDAAAAAAAAAAAAAQIAAxEgITEEEBIyQf/aAAgBAwEBPwH3bESigbZhVCLRh8TbBRcxUsewJ+zyAo53AalNg+4eyobsTj4wBWNoRiL6xR2pnUeo9T7HEwxujD//xAAgEQABBAICAwEAAAAAAAAAAAABAAIRIAMhEDIEEjFB/9oACAECAQE/AedVKyOhAuBlAyJoU50hF34sUmrh6aIRTRApC8gkOhDaAIG1FHsGQbTMbGdRUfeGdaf/xAA8EAABAwICBQgIAwkAAAAAAAABAAIDBBESIRMiMUFRBSAwMkJxgZEQFCNSYaGxwSQzYkNTY3OCssLR4f/aAAgBAQAGPwLmOmnkbDE3a95sAi2nhnq7doaoPmgJqSohBO0WciKKqbK8dg5O8j0Jc44WjMkrQ05LaCE6o/eH3lcrYoqiBxjkjOJjuBUVQcp26srf1dBoIzaWrdo/6d/2Hj6C7cFYoOaMl6jcmCqBy4OAvfoOS+6T/FAEho4lNbGWnuQAvI74BGN0Tm8CVybhIF522J4E9BRPwAQxNcceLMkkZW8k0CHVJsTZFuTRhRwdYjIgb0725abdk5grk+RslyyQG8h3qGRws57A4jn07rXAmsfIrEYXfJPfKWgHK11ZmjmiJ7Lur3phcWCMZ4WZ38VBFa+tdBo3Zc+qjaLvAxt8EMOtbcj7BoPxVhBEGcXXTmuve6qi3c8NPl/3oX1kDMVC83Nv2Z/0he1l1l7Lq+8i87Z5ny/PL6dBJNM8RxRjE5ztgCfR0cGj5MJs6WQa0ndwWq4juV5Hl/eVkp+SOVJfw+L2E57H6T8OazTh01RJ1IY9veeAR9UooIG/xCXn7LPlB0Y4RNDUIqitqanEeo+QkeSoy1v5bcMhb9fTo4xjkOwKAR9fR3e7iUxkHKEojaLBj9cAeKtVU0FUOI1Cmtqqeajv2+u0ff5IT0tRHPEe0wqorX7HnUb7rdw9BKov57PqmxgXBGYO9FzXaDPZuWKabLgxOEbAwWRAP5bA0/X78wtjlext9jTzKPFsD7ppYbt3FZgGxugpJDlvU07tsji7mePMpGPzbd39pRa0WA9EmLc6yrHNyOjI53//xAAlEAEAAgEDAwQDAQAAAAAAAAABABEhMUFRYXGhMIGRsRAg0cH/2gAIAQEAAT8h/Qfc2T7hmjkFR22rxKfaLzOrkmqDCTVzgfRPwGwoDmFWYLPdH0f2eBidDQLJS7EoZFW2Blrh19BQXdGa5cC5NCUEwYgiqo2a9swuSeZD4Ce/oaIc5ttYdu9YDILNW8weyutOGEzxFOoraMBPv0EVs3aLh2yu93E1TNOQc6Q06dgS6jdncCTTi3Qii0jW+gOekpFg6oImQnSiRCl/un2wj+U7EPP9TncQgOJkbanl6IGWg+Z1g2XhvtUMBYBXMDRgB++NN8a27+rPeBbBq3yvksNMy1nm0jOrJlx7TP0oupavRd1kYnR7tH274yNzvM1AESsVuj6hTNfAeg9TK1A1ZTXrWobKbLrr20gqlYoHQWL4mGqigwMbVHIvQ4dq40AEbHIn6ZtBVFjkYDnOvE6eItdjEz4Ljx6Wfm8FmpeEu5hb8ljZy60gIDWcaKfth/ZnqpL8Q+4aQTFAWiBBlzv7lnibjdCu8qoYFTBUvh4ejE9Si2zj4vN/gAm0ujVfowRD6D4MLjeli7TLlO1V+7B/PKtXuy3tTOG3/CaTMGKWL1bIX+XJU5KXi9Bf8hh66CcQgsvpM9nUxDwMCr2J4jqW4IMO8GkeYcr5RhHWDpYiXWiQZJhAgwMYGVw7cRTNRdxmhDkgx+FZ/9oADAMBAAIAAwAAABDzikHTzzyxyB7zzy5UO3zzzvslbzz+znfrXwgs5EAbEF6AGP8AB//EAB8RAQACAgIDAQEAAAAAAAAAAAEAESAhEDFBgZGxcf/aAAgBAwEBPxDimKN49og9EXnuKr8YUJK+l+QS1avz+ygptgrCRkv6iFIawMuXLVKXOiIb0lmFodQQbvz5jocdfVx44//EAB4RAQACAwEAAwEAAAAAAAAAAAEAERAhMSBBUXGR/9oACAECAQE/EMWQVrzxENEGrkIh4QCsGlC/7LaFARg3zwl6ZZbEd0clWZrCxJdgbYIOpbI/c0UM0tUe3PmbwBAw4RWn9jHH/8QAJhABAQACAQQCAQUBAQAAAAAAAREAITFBUWFxgZEwIKGxwdHh8P/aAAgBAQABPxD9E6NNN5QP9wHwnS09Ss9nAa0ZBZoEhvgWHXjGyBRDpNBDVoMEsv4WTxDBFUugAtx2mRhBkXSabgV5QVr10eKAJTI5PuXdQII6TojpGOnEkISBMiOOGdmdH8EPqgQQm8cnjJhxr9kns6w9uArx/wC04JVFwPWvgwW1ednie2/pePwBYDG3boHn/TG3gLNB/uKREGtRp+K18eMngDSRruy/9yu2bRGm0nDzi1eynR06xJ3p3n4NNa++IWAAqwiXGsu/LWsnDb1unjIU9TXabRNaOmM6EVrKVwRXQtnvNVuTXYQYBRBUpvH4HGCXUEVrxhEAA4DR8L+s/EWnbWvTy7hl/QG2lfuz4wKU7DBIn16643pSm6RoAadO+OaNnhisaAGBsKymNUJpeCJs4NV8D7B8hwdgh+t5I4lRGB3QGEZoQUFrpcTuIRRsbU/rEB9CYTxHb6yyoWqm9KVDxjlBzdA/UH7/AAJTHsVg9On0S7BajManLcNvWDUShXUw82knqeO+BqHM62W/B4Yy6EqPYDOVuRiW4gBzcStYLX7SuPvLEZHaH8MHhwchj8IBwfNdiL2HqwCYwhRHhH9EF8HB9KEpq7VsGMYrSB49xXxKxBKdHPYTXyuDEJOGtIqyawDqIShuXhBe88YpIObKvC6YJCGcQ/gDquFYgZtfiJE8e8Wfb5JBSAABIcY/ONwrs4Nk1ohPyMPSx+AwagXqAJYJdmMOq1rXHoC90uuLhOjGs0q6adszobidjg7NzVPjTQui00N5kemUmB1bw2fsXzg0hUd7SrtdYR2VOvF9J84CNz095S/eIoDtxEQSlQCwTcD6xduJ1MCo5uFtBkEtTAF5GSOoz21v98TG6kUJsl4Zfvzmx6gT7xNxXPg1/S/OOes49CPwEPjFFTGvumXPhw11F/kzm4bgKOxiMwFVIWzyGGDwGbhvy4EWlBfrA4KGWhf2avtyitmdADPvNIYCM1pwJ9XBUYwwUPHvP//Z", Fj = "" + new URL("cto_Tsukiden-0aa19964.jpg", import.meta.url).href, kj = "" + new URL("rikkeisoft-aef587f9.svg", import.meta.url).href, Nj = "" + new URL("proudcloud-eea3865a.png", import.meta.url).href, Oj = "" + new URL("jlabs-a32d7494.png", import.meta.url).href, zj = "" + new URL("tsukiden_logo-d9c69047.png", import.meta.url).href, Uj = "" + new URL("carrent-d8f650fc.png", import.meta.url).href, Gj = "" + new URL("jobit-e05dd385.png", import.meta.url).href, Hj = "" + new URL("tripguide-8f56aec2.png", import.meta.url).href, Vj = "" + new URL("estate-478a9602.png", import.meta.url).href, Wj = "" + new URL("jobsite-7f0126cb.png", import.meta.url).href, jj = "" + new URL("clc-4cd21027.jpg", import.meta.url).href, Jj = "" + new URL("coin_codex-871cdafa.jpg", import.meta.url).href, Xj = "" + new URL("cypo-601553ce.jpg", import.meta.url).href, Qj = "" + new URL("erc20-babdfd0f.jpg", import.meta.url).href, Kj = "" + new URL("nft_art-a119f842.jpg", import.meta.url).href, Yj = "" + new URL("okes_wallet-829ba84e.jpg", import.meta.url).href, qj = "" + new URL("pluming_invoice-cf5ec6e5.jpg", import.meta.url).href, Zj = "" + new URL("resturant-3981ba58.jpg", import.meta.url).href, $j = "" + new URL("study-d5bdf493.jpg", import.meta.url).href, eJ = "" + new URL("uruloki-03e6b98c.jpg", import.meta.url).href, Xl = [{ id: "about", title: "About" }, { id: "work", title: "Work" }, { id: "contact", title: "Contact" }], Oy = [{ title: "WebSite", icon: pj }, { title: "Blockchain", icon: dj }, { title: "Amarzon Web Service", icon: fj }, { title: "Mobile App", icon: hj }], zy = [{ name: "JavaScript", icon: vj }, { name: "TypeScript", icon: wj }, { name: "React JS", icon: Mj }, { name: "Redux Toolkit", icon: _j }, { name: "Node JS", icon: Aj }, { name: "MongoDB", icon: xj }, { name: "Three JS", icon: Sj }, { name: "docker", icon: yj }, { name: "blockchain", icon: bj }, { name: "bitcoin", icon: Ej }, { name: "etherum", icon: Bj }, { name: "nft", icon: Tj }, { name: "solana", icon: Cj }], tJ = [{ title: "Full Stack PHP developer", company_name: "Proudcloud", icon: Nj, iconBg: "#383E56", date: "April 2016 - June 2018", points: ["Designed and developed custom PHP web applications using Laravel, MongoDB, CodeIgnite.", "Contributed to the building and deployment of a new eCommerce platform, orchestrating the integration of diverse systems, APIs, and third-party services to streamline customer order processing logic.", "Supported the establishment and optimization of CI/CD pipelines, ensuring smooth deployment processes and efficient codebase managemen", "Integrated a web-based file manager into a PHP custom site, resolving compatibility issues arising from the use of Java-based plugins, ensuring seamless functionality and user experience"] }, { title: "Senior Full Stack Developer", company_name: "Rikkeisoft Company", icon: kj, iconBg: "#E6DEDD", date: "June 2020 - April 2020", points: ["Designed and programmed a blockchain-based supply chain management system, leveraging blockchain technology to achieve a remarkable 50% reduction in tracking errors. This solution enhanced transparency, traceability, and efficiency throughout the supply chain", "Developed decentralized applications including NFT marketplaces, crowdfunding platforms, and decentralized exchanges, collectively attracting over 2,500 daily active users. These platformsoffered innovative solutions and fostered community engagement within the blockchain ecosystem.", "Implemented end-to-end ERP Blockchain API solutions for SyncFab customers, utilizing blockchain technology and other SyncFab services with Golang, Gorilla Mux, and Go-Web3. These solutions optimized supply chain processes, enabling secure and transparent data exchange among stakeholders.", "Developed decentralized applications and integrated DeFi protocols to enhance user experiences and expand access to financial services."] }, { title: "Senior Blockchain Developer", company_name: "JLabs", icon: Oj, iconBg: "#383E56", date: "April 2020 - May 2022", points: ["Spearheaded the development of custom tokens and associated infrastructure across multiple blockchain networks, ensuring alignment with business objectives and regulatory requirements.", "Led integration efforts with decentralized and centralized exchanges, bridges, and token sale platforms, optimizing liquidity and market access for issued tokens.", "Integrated decentralized and centralized exchanges, as well as bridges, to facilitate fluid token trading and liquidity provision, enhancing accessibility and market reach for issued tokens.", "Designed and developed battle royale games utilizing Ethereum and Polygon networks, optimizing gas fees by offloading real-time battles to Polygon while maintaining game speed and scalability."] }, { title: "Lead Blockchain Developer", company_name: "Tsukiden Global Solutions Inc", icon: zj, iconBg: "#383E56", date: "May 2022 - December 2023", points: ["Led the design and deployment of custom smart contracts for an NFT marketplace, collaborating closely with stakeholders to translate business requirements into technical specifications.", "Implemented gas optimization strategies to minimize transaction costs and enhance platform scalability, conducting extensive testing and performance tuning to optimize contract efficiency", "Innovated a reservation swap mechanism enabling users to secure listed items through a two-step payment process, integrating payment verification and token minting protocols to ensure transaction integrity and user trust.", "Implemented Merkle tree structures for signature verification, utilizing efficient hashing algorithms to validate large datasets with minimal computational overhead, enhancing security and scalability."] }], nJ = [{
  testimonial: `Working with Jerome Cano was an absolute pleasure. His attention to detail and commitment to delivering high-quality work exceeded my expectations.  
      I would highly recommend them to anyone in need of a talented and reliable freelancer.`, name: "Jay Fajardo", designation: "CEO", company: "Proudcloud", image: Pj
}, {
  testimonial: `I was blown away by Jerome Cano's creativity and professionalism. 
      He took the time to understand my vision and brought it to life in a way that exceeded my expectations.
       Their communication and responsiveness were also top-notch. I would definitely work with them again.`, name: "Evan Forster", designation: "Designer", company: "Proudcloud", image: Lj
}, {
  testimonial: `I had the pleasure of working with Jerome Cano on a complex project that required a high level of skill and expertise. 
      He not only delivered exceptional work, but also provided valuable insights and suggestions that helped to improve the project even further.`, name: "Bui Quang Huy", designation: "CEO", company: "Rikkeisoft Company", image: Rj
}, { testimonial: "I've had the pleasure of working with Jeremy on several projects, and each time they have exceeded my expectations. His work is always clean, efficient, and well-documented.", name: "Amifel Qaxandra Q", designation: "Software Enginner", company: "JLabs", image: Dj }, {
  testimonial: `I'm consistently impressed by Jeremy's ability to stay up-to-date with the latest trends and technologies in the industry. He's always looking for ways to improve his skills and bring new ideas to the table.
                `, name: "Rejev Edward Mediodia", designation: "CTO", company: "JLabs", image: Ij
}, { testimonial: "What I appreciate most about Jeremy is their ability to communicate complex technical concepts in a way that's easy for non-technical stakeholders to understand. He's a true asset to any team.", name: "Jonathan Magsombol", designation: "CTO", company: "Tsukiden Global Solution", image: Fj }], iJ = [{ name: "Real estate", description: "Web-based platform that allows users to search, book, and manage home rentals from various providers, providing a convenient and efficient solution for transportation needs.", tags: [{ name: "Vue", color: "blue-text-gradient" }, { name: "mongodb", color: "green-text-gradient" }, { name: "tailwind", color: "pink-text-gradient" }], image: Uj, link: "https://www.homely.com.au/" }, { name: "Job IT", description: "Web application that enables users to search for job openings, view estimated salary ranges for positions, and locate available jobs based on their current location.", tags: [{ name: "react", color: "blue-text-gradient" }, { name: "restapi", color: "green-text-gradient" }, { name: "scss", color: "pink-text-gradient" }], image: Gj, link: "https://www.evirtualassistants.com/" }, { name: "Shop IT", description: "Spreadshirt prints a huge variety of custom clothing like T-shirts, hoodies and more. Your order is handled daily with a lot of love  ❤️ from USA and delivered worldwide!", tags: [{ name: "nextjs", color: "blue-text-gradient" }, { name: "supabase", color: "green-text-gradient" }, { name: "css", color: "pink-text-gradient" }], image: Hj, link: "https://www.spreadshirt.com/" }, { name: "Invest site", description: "Estokk Revolutionize Real Estate Investment. Start with $50 and earn monthly rental return with our Ethereum blockchain-based technology.", tags: [{ name: "react", color: "blue-text-gradient" }, { name: "PostgreSql", color: "green-text-gradient" }, { name: "tailwind", color: "pink-text-gradient" }], image: Vj, link: "https://estokk.com/" }, { name: "Job site", description: "Worknrby is one of the leading platforms for the successful conduct of job search in Jaipur, bringing thousands of opportunities to you and assisting you in selecting the most suitable job vacancy in Jaipur.", tags: [{ name: "Angular", color: "blue-text-gradient" }, { name: "MySQL", color: "green-text-gradient" }, { name: "scss", color: "pink-text-gradient" }], image: Wj, link: "https://www.worknrby.com/" }, { name: "Uruloki", description: "Our platform allows you to create an order book for decentralized assets, and group multiple orders into a single strategy for arbitraging between assets.", tags: [{ name: "Next", color: "blue-text-gradient" }, { name: "MySQL", color: "green-text-gradient" }, { name: "smart contract", color: "pink-text-gradient" }, { name: "uniswap", color: "yellow-text-gradient" }], image: eJ, link: "https://uruloki.vercel.app" }, { name: "Cyop Protocol", description: "The CyOp Protocol is a cyberpunk crypto DAO. By strategically acquiring assets during bearish phases and liquidating for profit later, we build a revenue stream that gets distributed to all holders each cycle.", tags: [{ name: "Next", color: "blue-text-gradient" }, { name: "PostgreSQL", color: "green-text-gradient" }, { name: "smart contract", color: "pink-text-gradient" }, { name: "erc 20", color: "white-text-gradient" }], image: Xj, link: "https://coinmarketcap.com/currencies/cyop-protocol" }, { name: "Sqf coin ERC20 Contract", description: "Sqfcoin is a digital Real Estate market platform based on blockchain technology. Our platform gives you access to Tokenized Properties in a simple and safe way via smart contract. Check out our portfolio of available properties on our Marketplace, buy Sqfcoin with confidence and join the future of Tokenized Real Estate.", tags: [{ name: "Vue", color: "blue-text-gradient" }, { name: "remix", color: "pink-text-gradient" }, { name: "erc20", color: "green-text-gradient" }], image: Qj, link: "https://sqfcoin.com" }, { name: "CLC", description: "Chip Leader Al was built for both online and live tournaments. The hands that power the Chip Leader Al Engine are generated from real hands Chance Kornuth and Alex Foxen played.", tags: [{ name: "React", color: "blue-text-gradient" }, { name: "MongoDB", color: "green-text-gradient" }, { name: "Python", color: "pink-text-gradient" }], image: jj, link: "https://ai.chipleader.com" }, { name: "CoinCodex - Live Crypto", description: "The CoinCodex app makes it easy to follow Bitcoin, Ethereum, over 10,000 other coins. Join thousands of cryptocurrency user and stay updated with the CoinCodex crypto price tracker and portfolio app.", tags: [{ name: "React Navite", color: "blue-text-gradient" }, { name: "MongoDB", color: "green-text-gradient" }, { name: "smart contract", color: "pink-text-gradient" }, { name: "solana", color: "green-text-gradient" }], image: Jj, link: "https://play.google.com/store/apps/details?id=com.coincodex.coincodexapp&hl=en_US" }, { name: "Okse Wallet & Card", description: "The Okse Wallet is our way of making the user experience even more streamlined through easier access to different Networks and helping you spend Crypto with Virtual and Physical Debit Cards.", tags: [{ name: "Flutter", color: "blue-text-gradient" }], image: Yj, link: "https://play.google.com/store/apps/details?id=wallet.okse.io&hl=en_US&gl=US" }, { name: "Plumbing Invoices", description: "Includes client management features like recording basic information and using GPS location", tags: [{ name: "React Native", color: "blue-text-gradient" }], image: qj, link: "https://play.google.com/store/apps/details?id=com.PlumbingInvoices&hl=en_IN&gl=US" }, { name: "Let's Learn Together", description: "At Desmos Studio, we want to help everyone learn math, love math, and grow with math.", tags: [{ name: "Laravel", color: "blue-text-gradient" }, { name: "MySQL", color: "green-text-gradient" }, { name: "CSS", color: "pink-text-gradient" }], image: $j, link: "https://github.com/smartOlaf-developer" }, { name: "Restaurant Website", description: "Culinary delights, a stylish ambience and the fantastic location on the Bingen cultural bank, directly on the Rhine, are the basis for your very special ...", tags: [{ name: "CodeIgniter", color: "blue-text-gradient" }, { name: "MySQL", color: "green-text-gradient" }], image: Zj, link: "https://zollamtbingen.de" }, { name: "NFT Art Toy Marketplace", description: "ArToys is a hub for toy collectors, artists, and brands to come together. We offer a distinctive experience with easy access, daily surprises, and a lively community. Created by passionate toy collectors for collectors.", tags: [{ name: "Next", color: "blue-text-gradient" }, { name: "smart contract", color: "pink-text-gradient" }, { name: "NFT", color: "blue-text-gradient" }, { name: "Truffle", color: "green-text-gradient" }], image: Kj, link: "https://artoys.app/en?utm_source=chikorokosite&utm_medium=referral&utm_campaign=redirect&utm_term=main" }], rJ = () => { const [n, e] = U.useState(!1), [t, i] = U.useState(""); return ue("div", { children: ue("nav", { className: `${ri.paddingX} w-full flex items-center py-5 fixed top-0 z-20 bg-primary`, children: it("div", { className: "w-full flex justify-between items-center max-w-7xl margin-x-auto", children: [it(LR, { to: "/", className: "flex items-center gap-2", onClick: () => { i(""), window.scrollTo(0, 0) }, children: [ue("img", { src: uj, className: "w-9 h-9 object-contain" }), ue("p", { className: "text-white text-[18px] font-bold cursor-pointer", children: "Jerome Cano" })] }), ue("ul", { className: "list-none hidden sm:flex flex-row gap-10", children: Xl == null ? void 0 : Xl.map(r => ue("li", { className: `${t === (r == null ? void 0 : r.title) ? "text-white" : "text-secondary"} text-medium hover:text-white text-[18px] cursor-pointer`, onClick: () => i(r == null ? void 0 : r.title), children: ue("a", { href: `#${r == null ? void 0 : r.id}`, children: r == null ? void 0 : r.title }) }, r == null ? void 0 : r.id)) }), it("div", { className: "sm:hidden flex flex-1 justify-end items-center", children: [ue("img", { src: n ? gj : mj, className: "w-[28px] h-[28px] object-contain cursor-pointer", onClick: () => { e(!n) } }), ue("div", { className: `${n ? "flex" : "hidden"} p-6 Ceder-gradient absolute top-20 right-0 mx-x my-2 min-w-[180px] z-10 rounded-xl`, children: ue("ul", { className: "list-none flex flex-col justify-end items-start  gap-4", children: Xl == null ? void 0 : Xl.map(r => ue("li", { className: `${t === (r == null ? void 0 : r.title) ? "text-white" : "text-secondary"} text-medium text-[16px] font-poppins cursor-pointer`, onClick: () => { i(r == null ? void 0 : r.title), e(!n) }, children: ue("a", { href: `#${r == null ? void 0 : r.id}`, children: r == null ? void 0 : r.title }) }, r == null ? void 0 : r.id)) }) })] })] }) }) }) }; var T8 = {}; Object.defineProperty(T8, "__esModule", { value: !0 }); var Yu = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, sJ = function () { function n(e, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, t, i) { return t && n(e.prototype, t), i && n(e, i), e } }(), B8 = U, oJ = lJ(B8), aJ = gm; function lJ(n) { return n && n.__esModule ? n : { default: n } } function cJ(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } function uJ(n, e) { if (!n) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : n } function fJ(n, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); n.prototype = Object.create(e && e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e) } var hJ = function (n) { fJ(e, n); function e(t) { cJ(this, e); var i = uJ(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)); i.state = { style: {} }; var r = { reverse: !1, max: 35, perspective: 1e3, easing: "cubic-bezier(.03,.98,.52,.99)", scale: "1.1", speed: "1000", transition: !0, axis: null, reset: !0 }; return i.width = null, i.height = null, i.left = null, i.top = null, i.transitionTimeout = null, i.updateCall = null, i.element = null, i.settings = Object.assign({}, r, i.props.options), i.reverse = i.settings.reverse ? -1 : 1, i.onMouseEnter = i.onMouseEnter.bind(i, i.props.onMouseEnter), i.onMouseMove = i.onMouseMove.bind(i, i.props.onMouseMove), i.onMouseLeave = i.onMouseLeave.bind(i, i.props.onMouseLeave), i } return sJ(e, [{ key: "componentDidMount", value: function () { this.element = (0, aJ.findDOMNode)(this) } }, { key: "componentWillUnmount", value: function () { clearTimeout(this.transitionTimeout), cancelAnimationFrame(this.updateCall) } }, { key: "onMouseEnter", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return this.updateElementPosition(), this.setState(Object.assign({}, this.state, { style: Yu({}, this.state.style, { willChange: "transform" }) })), this.setTransition(), i(r) } }, { key: "reset", value: function () { var i = this; window.requestAnimationFrame(function () { i.setState(Object.assign({}, i.state, { style: Yu({}, i.state.style, { transform: "perspective(" + i.settings.perspective + "px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)" }) })) }) } }, { key: "onMouseMove", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return r.persist(), this.updateCall !== null && window.cancelAnimationFrame(this.updateCall), this.event = r, this.updateCall = requestAnimationFrame(this.update.bind(this, r)), i(r) } }, { key: "setTransition", value: function () { var i = this; clearTimeout(this.transitionTimeout), this.setState(Object.assign({}, this.state, { style: Yu({}, this.state.style, { transition: this.settings.speed + "ms " + this.settings.easing }) })), this.transitionTimeout = setTimeout(function () { i.setState(Object.assign({}, i.state, { style: Yu({}, i.state.style, { transition: "" }) })) }, this.settings.speed) } }, { key: "onMouseLeave", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return this.setTransition(), this.settings.reset && this.reset(), i(r) } }, { key: "getValues", value: function (i) { var r = (i.nativeEvent.clientX - this.left) / this.width, s = (i.nativeEvent.clientY - this.top) / this.height, o = Math.min(Math.max(r, 0), 1), a = Math.min(Math.max(s, 0), 1), l = (this.reverse * (this.settings.max / 2 - o * this.settings.max)).toFixed(2), u = (this.reverse * (a * this.settings.max - this.settings.max / 2)).toFixed(2), h = o * 100, d = a * 100; return { tiltX: l, tiltY: u, percentageX: h, percentageY: d } } }, { key: "updateElementPosition", value: function () { var i = this.element.getBoundingClientRect(); this.width = this.element.offsetWidth, this.height = this.element.offsetHeight, this.left = i.left, this.top = i.top } }, { key: "update", value: function (i) { var r = this.getValues(i); this.setState(Object.assign({}, this.state, { style: Yu({}, this.state.style, { transform: "perspective(" + this.settings.perspective + "px) rotateX(" + (this.settings.axis === "x" ? 0 : r.tiltY) + "deg) rotateY(" + (this.settings.axis === "y" ? 0 : r.tiltX) + "deg) scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")" }) })), this.updateCall = null } }, { key: "render", value: function () { var i = Object.assign({}, this.props.style, this.state.style); return oJ.default.createElement("div", { style: i, className: this.props.className, onMouseEnter: this.onMouseEnter, onMouseMove: this.onMouseMove, onMouseLeave: this.onMouseLeave }, this.props.children) } }]), e }(B8.Component), P8 = T8.default = hJ; const Z0 = n => ({ hidden: { y: -50, opacity: 0 }, show: { y: 0, opacity: 1, transition: { type: "spring", duration: 1.25, delay: n } } }), zh = (n, e, t, i) => ({ hidden: { x: n === "left" ? 100 : n === "right" ? -100 : 0, y: n === "up" ? 100 : n === "down" ? -100 : 0, opacity: 0 }, show: { x: 0, y: 0, opacity: 1, transition: { type: e, delay: t, duration: i, ease: "easeOut" } } }), MC = (n, e, t, i) => ({ hidden: { x: n === "left" ? "-100%" : n === "right" ? "100%" : 0, y: n === "up" || n === "down" ? "100%" : 0 }, show: { x: 0, y: 0, transition: { type: e, delay: t, duration: i, ease: "easeOut" } } }), dJ = (n, e) => ({ hidden: {}, show: { transition: { staggerChildren: n, delayChildren: e || 0 } } }), nu = (n, e) => function () { return it(Xi.section, { variants: dJ(), initial: "hidden", whileInView: "show", viewport: { once: !0, amount: .25 }, className: `${ri.padding} max-w-7xl mx-auto relative z-0`, children: [ue("span", { className: "hash-span", id: e, children: " " }), ue(n, {})] }) }, pJ = ({ title: n, icon: e, index: t }) => ue(P8, { className: "xs:w-[250px] w-full", children: ue(Xi.div, { variants: zh("right", "spring", .5 * t, .75), className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card", children: it("div", { options: { max: 45, scale: 1, speed: 450 }, className: "bg-tertiary rounded-[20px] py-5 px-12 min-h-[200px] flex justify-evenly items-center flex-col", children: [ue("img", { src: e, alt: n, className: "w-16 h-16 object-contain" }), ue("h3", { className: "text-white text-[20px] font-bold text-center", children: n })] }) }) }), mJ = () => it(s0, { children: [it(Xi.div, { variants: Z0(), children: [ue("p", { className: ri.sectionSubText, children: "Introduction" }), ue("h2", { className: ri.sectionHeadText, children: "Profile" })] }), ue(Xi.p, { variants: zh("", "", .1, 1), className: "mt-4 text-secondary text-[17px] max-w-6xl leading-[30px]", children: "Dynamic and dedicated Blockchain Developer with over 8 years of hands-on experience in architecting and deploying decentralized applications (dApps). Specializing in the Ethereum platform, with a comprehensive proficiency in Solidity programming language, I have successfully designed and implemented various blockchain solutions across multiple networks including Polygon, Solana, Bittensor, and more. My expertise extends across the development spectrum, from decentralized exchanges (DEX) to dApps and NFT marketplaces, positioning me as a versatile professional capable of delivering innovative solutions in the rapidly evolving blockchain landscape. Additionally, my proficiency in frontend and backend development, coupled with experience in cloud technologies, ensures comprehensive end-to-end solutions that meet both technical and user requirements. Driven by a passion for blockchain technology and its transformative potential, I am committed to staying abreast of emerging trends and advancements, continuously refining my skills to deliver cutting-edge solutions that drive business growth and enhance user experiences." }), ue("div", { className: "mt-20 flex flex-wrap gap-10", children: Oy == null ? void 0 : Oy.map((n, e) => ue(pJ, { index: e, ...n }, n == null ? void 0 : n.title)) })] }), gJ = nu(mJ, "about"), yJ = () => ue("div", { className: "flex justify-center flex-wrap gap-10", children: zy == null ? void 0 : zy.map((n, e) => ue("div", { className: "w-28 h-28", children: ue(jU, { icon: n.icon }) }, e)) }), vJ = nu(yJ, ""); var $0 = {}, t0 = {}, xJ = { get exports() { return t0 }, set exports(n) { t0 = n } };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (n) { (function () { var e = {}.hasOwnProperty; function t() { for (var i = [], r = 0; r < arguments.length; r++) { var s = arguments[r]; if (s) { var o = typeof s; if (o === "string" || o === "number") i.push(s); else if (Array.isArray(s)) { if (s.length) { var a = t.apply(null, s); a && i.push(a) } } else if (o === "object") { if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) { i.push(s.toString()); continue } for (var l in s) e.call(s, l) && s[l] && i.push(l) } } } return i.join(" ") } n.exports ? (t.default = t, n.exports = t) : window.classNames = t })() })(xJ); $0.__esModule = !0; $0.default = void 0; var AJ = g3(U), po = g3(jm), MJ = g3(t0); function g3(n) { return n && n.__esModule ? n : { default: n } } const R8 = ({ animate: n = !0, className: e = "", layout: t = "2-columns", lineColor: i = "#FFF", children: r }) => (typeof window == "object" && document.documentElement.style.setProperty("--line-color", i), AJ.default.createElement("div", { className: (0, MJ.default)(e, "vertical-timeline", { "vertical-timeline--animate": n, "vertical-timeline--two-columns": t === "2-columns", "vertical-timeline--one-column-left": t === "1-column" || t === "1-column-left", "vertical-timeline--one-column-right": t === "1-column-right" }) }, r)); R8.propTypes = { children: po.default.oneOfType([po.default.arrayOf(po.default.node), po.default.node]).isRequired, className: po.default.string, animate: po.default.bool, layout: po.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]), lineColor: po.default.string }; var _J = R8; $0.default = _J; var eg = {}; function Q2() { return Q2 = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, Q2.apply(this, arguments) } function wJ(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, K2(n, e) } function K2(n, e) { return K2 = Object.setPrototypeOf || function (i, r) { return i.__proto__ = r, i }, K2(n, e) } function SJ(n, e) { if (n == null) return {}; var t = {}, i = Object.keys(n), r, s; for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]); return t } var Y2 = new Map, jp = new WeakMap, _C = 0, L8 = void 0; function CJ(n) { L8 = n } function EJ(n) { return n ? (jp.has(n) || (_C += 1, jp.set(n, _C.toString())), jp.get(n)) : "0" } function bJ(n) { return Object.keys(n).sort().filter(function (e) { return n[e] !== void 0 }).map(function (e) { return e + "_" + (e === "root" ? EJ(n.root) : n[e]) }).toString() } function TJ(n) { var e = bJ(n), t = Y2.get(e); if (!t) { var i = new Map, r, s = new IntersectionObserver(function (o) { o.forEach(function (a) { var l, u = a.isIntersecting && r.some(function (h) { return a.intersectionRatio >= h }); n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = u), (l = i.get(a.target)) == null || l.forEach(function (h) { h(u, a) }) }) }, n); r = s.thresholds || (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0]), t = { id: e, observer: s, elements: i }, Y2.set(e, t) } return t } function y3(n, e, t, i) { if (t === void 0 && (t = {}), i === void 0 && (i = L8), typeof window.IntersectionObserver > "u" && i !== void 0) { var r = n.getBoundingClientRect(); return e(i, { isIntersecting: i, target: n, intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0, time: 0, boundingClientRect: r, intersectionRect: r, rootBounds: r }), function () { } } var s = TJ(t), o = s.id, a = s.observer, l = s.elements, u = l.get(n) || []; return l.has(n) || l.set(n, u), u.push(e), a.observe(n), function () { u.splice(u.indexOf(e), 1), u.length === 0 && (l.delete(n), a.unobserve(n)), l.size === 0 && (a.disconnect(), Y2.delete(o)) } } var BJ = ["children", "as", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"]; function wC(n) { return typeof n.children != "function" } var n0 = function (n) { wJ(e, n); function e(i) { var r; return r = n.call(this, i) || this, r.node = null, r._unobserveCb = null, r.handleNode = function (s) { r.node && (r.unobserve(), !s && !r.props.triggerOnce && !r.props.skip && r.setState({ inView: !!r.props.initialInView, entry: void 0 })), r.node = s || null, r.observeNode() }, r.handleChange = function (s, o) { s && r.props.triggerOnce && r.unobserve(), wC(r.props) || r.setState({ inView: s, entry: o }), r.props.onChange && r.props.onChange(s, o) }, r.state = { inView: !!i.initialInView, entry: void 0 }, r } var t = e.prototype; return t.componentDidUpdate = function (r) { (r.rootMargin !== this.props.rootMargin || r.root !== this.props.root || r.threshold !== this.props.threshold || r.skip !== this.props.skip || r.trackVisibility !== this.props.trackVisibility || r.delay !== this.props.delay) && (this.unobserve(), this.observeNode()) }, t.componentWillUnmount = function () { this.unobserve(), this.node = null }, t.observeNode = function () { if (!(!this.node || this.props.skip)) { var r = this.props, s = r.threshold, o = r.root, a = r.rootMargin, l = r.trackVisibility, u = r.delay, h = r.fallbackInView; this._unobserveCb = y3(this.node, this.handleChange, { threshold: s, root: o, rootMargin: a, trackVisibility: l, delay: u }, h) } }, t.unobserve = function () { this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null) }, t.render = function () { if (!wC(this.props)) { var r = this.state, s = r.inView, o = r.entry; return this.props.children({ inView: s, entry: o, ref: this.handleNode }) } var a = this.props, l = a.children, u = a.as, h = SJ(a, BJ); return U.createElement(u || "div", Q2({ ref: this.handleNode }, h), l) }, e }(U.Component); n0.displayName = "InView"; n0.defaultProps = { threshold: 0, triggerOnce: !1, initialInView: !1 }; function PJ(n) { var e = n === void 0 ? {} : n, t = e.threshold, i = e.delay, r = e.trackVisibility, s = e.rootMargin, o = e.root, a = e.triggerOnce, l = e.skip, u = e.initialInView, h = e.fallbackInView, d = U.useRef(), p = U.useState({ inView: !!u }), m = p[0], v = p[1], y = U.useCallback(function (A) { d.current !== void 0 && (d.current(), d.current = void 0), !l && A && (d.current = y3(A, function (_, M) { v({ inView: _, entry: M }), M.isIntersecting && a && d.current && (d.current(), d.current = void 0) }, { root: o, rootMargin: s, threshold: t, trackVisibility: r, delay: i }, h)) }, [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, h, i]); U.useEffect(function () { !d.current && m.entry && !a && !l && v({ inView: !!u }) }); var x = [y, m.inView, m.entry]; return x.ref = x[0], x.inView = x[1], x.entry = x[2], x } const RJ = Object.freeze(Object.defineProperty({ __proto__: null, InView: n0, default: n0, defaultFallbackInView: CJ, observe: y3, useInView: PJ }, Symbol.toStringTag, { value: "Module" })), LJ = BB(RJ); eg.__esModule = !0; eg.default = void 0; var mo = v3(U), Kt = v3(jm), Jp = v3(t0), IJ = LJ; function v3(n) { return n && n.__esModule ? n : { default: n } } const I8 = ({ children: n = "", className: e = "", contentArrowStyle: t = null, contentStyle: i = null, date: r = "", dateClassName: s = "", icon: o = null, iconClassName: a = "", iconOnClick: l = null, onTimelineElementClick: u = null, iconStyle: h = null, id: d = "", position: p = "", style: m = null, textClassName: v = "", intersectionObserverProps: y = { rootMargin: "0px 0px -40px 0px", triggerOnce: !0 }, visible: x = !1 }) => mo.default.createElement(IJ.InView, y, ({ inView: A, ref: _ }) => mo.default.createElement("div", { ref: _, id: d, className: (0, Jp.default)(e, "vertical-timeline-element", { "vertical-timeline-element--left": p === "left", "vertical-timeline-element--right": p === "right", "vertical-timeline-element--no-children": n === "" }), style: m }, mo.default.createElement(mo.default.Fragment, null, mo.default.createElement("span", { style: h, onClick: l, className: (0, Jp.default)(a, "vertical-timeline-element-icon", { "bounce-in": A || x, "is-hidden": !(A || x) }) }, o), mo.default.createElement("div", { style: i, onClick: u, className: (0, Jp.default)(v, "vertical-timeline-element-content", { "bounce-in": A || x, "is-hidden": !(A || x) }) }, mo.default.createElement("div", { style: t, className: "vertical-timeline-element-content-arrow" }), n, mo.default.createElement("span", { className: (0, Jp.default)(s, "vertical-timeline-element-date") }, r))))); I8.propTypes = { children: Kt.default.oneOfType([Kt.default.arrayOf(Kt.default.node), Kt.default.node]), className: Kt.default.string, contentArrowStyle: Kt.default.shape({}), contentStyle: Kt.default.shape({}), date: Kt.default.node, dateClassName: Kt.default.string, icon: Kt.default.element, iconClassName: Kt.default.string, iconStyle: Kt.default.shape({}), iconOnClick: Kt.default.func, onTimelineElementClick: Kt.default.func, id: Kt.default.string, position: Kt.default.string, style: Kt.default.shape({}), textClassName: Kt.default.string, visible: Kt.default.bool, intersectionObserverProps: Kt.default.shape({ root: Kt.default.object, rootMargin: Kt.default.string, threshold: Kt.default.number, triggerOnce: Kt.default.bool }) }; var DJ = I8; eg.default = DJ; var D8 = { VerticalTimeline: $0.default, VerticalTimelineElement: eg.default }; const FJ = ({ title: n, points: e, icon: t, company_name: i, iconBg: r, date: s }) => it(D8.VerticalTimelineElement, { contentStyle: { background: "#1d1836", color: "#fff" }, contentArrowStyle: { borderRight: "7px solid #232631" }, date: s, iconStyle: { background: r }, icon: ue("div", { className: "w-full h-full flex items-center justify-center", children: ue("img", { src: t, alt: i, className: "w-[60%] h-[60%] object-contain" }) }), children: [it("div", { children: [ue("h3", { className: "text-white text-[24px] font-bold", children: n }), ue("p", { className: "text-secondary text-[16px] font-semibold", children: i })] }), ue("ul", { className: "mt-5 list-disc ml-5 space-y-2", children: e == null ? void 0 : e.map((o, a) => ue("li", { className: "text-white-100 text-[14px] pl-1 tracking-wider", children: o }, a)) })] }), kJ = () => it(s0, { children: [it(Xi.div, { variants: Z0(), children: [ue("p", { className: ri.sectionSubText, children: "What I have done so far" }), ue("h2", { className: ri.sectionHeadText, children: "Work Experience" })] }), ue("div", { className: "mt-20 flex flex-col", children: ue(D8.VerticalTimeline, { children: tJ.map((n, e) => ue(FJ, { index: e, ...n }, e)) }) })] }), NJ = nu(kJ, "work"), OJ = ({ index: n, name: e, description: t, tags: i, image: r, source_code_link: s, onClick: o }) => ue(Xi.div, { variants: zh("up", "spring", n * .5, .75), onClick: o, children: it(P8, { options: { max: 45, scale: 1, speed: 450 }, className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full", children: [ue("div", { className: "relative w-full h-[230px]", children: ue("img", { src: r, alt: "project_image", className: "w-full h-full object-cover rounded-2xl" }) }), it("div", { className: "mt-5", children: [ue("h3", { className: "text-white font-bold text-[24px]", children: e }), ue("p", { className: "mt-2 text-secondary text-[14px]", children: t })] }), ue("div", { className: "mt-4 flex flex-wrap gap-2", children: i.map(a => it("p", { className: `text-[14px] ${a.color}`, children: ["#", a.name] }, `${e}-${a.name}`)) })] }) }), zJ = () => { const n = e => () => { e && window.open(e, "_blank") }; return it(s0, { children: [it(Xi.div, { variants: Z0(), children: [ue("p", { className: `${ri.sectionSubText} `, children: "My work" }), ue("h2", { className: `${ri.sectionHeadText}`, children: "Projects." })] }), ue("div", { className: "w-full flex", children: ue(Xi.p, { variants: zh("", "", .1, 1), className: "mt-3 text-secondary text-[17px] max-w-6xl leading-[30px]", children: "Following projects showcases my skills and experience through real-world examples of my work. Each project is briefly described with links to code repositories and live demos in it. It reflects my ability to solve complex problems, work with different technologies, and manage projects effectively." }) }), ue("div", { className: "mt-20 flex flex-wrap gap-7", children: iJ.map((e, t) => ue(OJ, { index: t, ...e, onClick: n(e.link) }, `project-${t}`)) })] }) }, UJ = nu(zJ, ""), GJ = ({ index: n, testimonial: e, name: t, designation: i, company: r, image: s }) => it(Xi.div, { variants: zh("", "spring", n * .5, .75), className: "bg-Ceder-200 p-10 rounded-3xl xs:w-[320px] w-full", children: [ue("p", { className: "text-white font-Ceder text-[48px]", children: '"' }), it("div", { className: "mt-1", children: [ue("p", { className: "text-white tracking-wider text-[18px]", children: e }), it("div", { className: "mt-7 flex justify-between items-center gap-1", children: [it("div", { className: "flex-1 flex flex-col", children: [it("p", { className: "text-white font-medium text-[16px]", children: [ue("span", { className: "blue-text-gradient", children: "@" }), " ", t] }), it("p", { className: "mt-1 text-secondary text-[12px]", children: [i, " of ", r] })] }), ue("img", { src: s, alt: `feedback_by-${t}`, className: "w-10 h-10 rounded-full object-cover" })] })] })] }), HJ = () => it("div", { className: "mt-12 bg-Ceder-100 rounded-[20px]", children: [ue("div", { className: `bg-tertiary rounded-2xl ${ri.padding} min-h-[300px]`, children: it(Xi.div, { variants: Z0(), children: [ue("p", { className: ri.sectionSubText, children: "What others say" }), ue("h2", { className: ri.sectionHeadText, children: "Testimonials." })] }) }), ue("div", { className: `-mt-20 pb-14 ${ri.paddingX} flex flex-wrap gap-7`, children: nJ.map((n, e) => ue(GJ, { index: e, ...n }, n.name)) })] }), VJ = nu(HJ, ""), lh = { _origin: "https://api.emailjs.com" }, WJ = (n, e = "https://api.emailjs.com") => { lh._userID = n, lh._origin = e }, F8 = (n, e, t) => { if (!n) throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!t) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class SC { constructor(e) { this.status = e ? e.status : 0, this.text = e ? e.responseText : "Network Error" } } const k8 = (n, e, t = {}) => new Promise((i, r) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: o }) => { const a = new SC(o); a.status === 200 || a.text === "OK" ? i(a) : r(a) }), s.addEventListener("error", ({ target: o }) => { r(new SC(o)) }), s.open("POST", lh._origin + n, !0), Object.keys(t).forEach(o => { s.setRequestHeader(o, t[o]) }), s.send(e) }), jJ = (n, e, t, i) => { const r = i || lh._userID; return F8(r, n, e), k8("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.10.0", user_id: r, service_id: n, template_id: e, template_params: t }), { "Content-type": "application/json" }) }, JJ = n => { let e; if (typeof n == "string" ? e = document.querySelector(n) : e = n, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, XJ = (n, e, t, i) => { const r = i || lh._userID, s = JJ(t); F8(r, n, e); const o = new FormData(s); return o.append("lib_version", "3.10.0"), o.append("service_id", n), o.append("template_id", e), o.append("user_id", r), k8("/api/v1.0/email/send-form", o) }, QJ = { init: WJ, send: jJ, sendForm: XJ }, KJ = () => {
  const n = U.useRef(), [e, t] = U.useState({ name: "", email: "", message: "" }), [i, r] = U.useState(!1), s = a => { const { target: l } = a, { name: u, value: h } = l; t({ ...e, [u]: h }) }, o = a => { a.preventDefault(), r(!0), QJ.send({}.VITE_APP_EMAILJS_SERVICE_ID, {}.VITE_APP_EMAILJS_TEMPLATE_ID, { from_name: e.name, to_name: "Michael Cano", from_email: e.email, to_email: "mc2933088@gmail.com", message: e.message }, {}.VITE_APP_EMAILJS_PUBLIC_KEY).then(() => { r(!1), alert("Thank you. I will get back to you as soon as possible."), t({ name: "", email: "", message: "" }) }, l => { r(!1), console.error(l), alert("Ahh, something went wrong. Please try again.") }) }; return it(s0, {
    children: [it("div", {
      className: "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden", children: [it(Xi.div, {
        variants: MC("left", "tween", .2, 1), className: "flex-[0.75] bg-Ceder-100 p-8 rounded-2xl", children: [ue("p", { className: ri.sectionSubText, children: "Get in touch" }), ue("h3", { className: ri.sectionHeadText, children: "Contact." }), it("form", {
          ref: n, onSubmit: o, className: "mt-12 flex flex-col gap-8", children: [it("label", { className: "flex flex-col", children: [ue("span", { className: "text-white font-medium mb-4", children: "Your Name" }), ue("input", { type: "text", name: "name", value: e.name, onChange: s, placeholder: "My name is Jerome Cano", className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium", disabled: !0 })] }), it("label", { className: "flex flex-col", children: [ue("span", { className: "text-white font-medium mb-4", children: "Your email" }), ue("input", { type: "email", name: "email", value: e.email, onChange: s, placeholder: "azuredevil053@gmail.com", className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium", disabled: !0 })] }), it("label", {
            className: "flex flex-col", children: [ue("span", { className: "text-white font-medium mb-4", children: "Your Message" }), ue("textarea", {
              rows: 7, name: "message", value: e.message, onChange: s, placeholder: `You can also contact with me on Skype or Telegram.
  -------------------------------------
  live:.cid.d273217cdc3a472 
  This is my Skype address.
  -------------------------------------
  https://t.me/untechguru2
  This is my Telegram address.`, className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium", disabled: !0
            })]
          }), ue("button", { type: "submit", className: "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary", children: i ? "Sending..." : "Send" })]
        })]
      }), ue(Xi.div, { variants: MC("right", "tween", .2, 1), className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]", children: ue(VU, {}) })]
    }), it("div", { className: "mt-20 flex flex justify-center item-center", children: [ue(Ny, { className: "ml-3 mt-3", network: "twitter", url: "https://x.com/jeromecano2124" }), ue(Ny, { className: "ml-3 mt-3", network: "linkedin", url: "https://www.linkedin.com/in/jerome-cano-433bb3319" }), ue(Ny, { className: "ml-3 mt-3", network: "github", url: "https://github.com/jeroemcano2124" })] })]
  })
}, YJ = nu(KJ, "contact"), qJ = () => ue(BR, { children: it("div", { className: "relative z-0 bg-primary", children: [it("div", { className: "bg-hero-pattern bg-cover bg-no-repeat bg-center", children: [ue(rJ, {}), ue(cj, {})] }), ue(gJ, {}), ue(NJ, {}), ue(vJ, {}), ue(UJ, {}), ue(VJ, {}), it("div", { className: "relative z-0", children: [ue(YJ, {}), ue(KU, {})] })] }) }); Gy.createRoot(document.getElementById("root")).render(ue(r0.StrictMode, { children: ue(qJ, {}) }));